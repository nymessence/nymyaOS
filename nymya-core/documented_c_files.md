# Documented C Files from nymya-core Project

This document was automatically generated by a script to capture the content of .c files.

---

## File: `complex_conj.c`

### Content

```c
// src/complex_conj.c

#include "nymya.h"

/**
 * complex_conj - Returns the complex conjugate of a complex_double.
 *
 * In kernel mode, complex_double is a struct with fixed-point fields.
 * In user mode, complex_double is _Complex double from <complex.h>.
 *
 * @c: Input complex_double value.
 *
 * Returns:
 * The complex conjugate of the input.
 */
complex_double complex_conj(complex_double c) {
#ifdef __KERNEL__
    complex_double result;
    result.re = c.re;
    result.im = -c.im;
    return result;
#else
    return conj(c);
#endif
}


```

---

## File: `complex_exp_i.c`

### Content

```c
// complex_exp_i.c

#include "nymya.h"

#ifdef __KERNEL__
#include <linux/kernel.h>
#include <linux/types.h>

/**
 * complex_exp_i - Computes e^(i*theta) for fixed-point numbers in kernel-space.
 *
 * @theta_fp: The angle in radians, as a Q32.32 fixed-point value.
 * Returns the complex number representing e^(i*theta).
 */
complex_double complex_exp_i(int64_t theta_fp) {
    complex_double result;
    result.re = fixed_cos(theta_fp);
    result.im = fixed_sin(theta_fp);
    return result;
}

// EXPORT_SYMBOL_GPL(complex_exp_i);

#else // Userland implementation

#include <complex.h>
#include <math.h>
#include <stdio.h>

/**
 * complex_exp_i - Computes e^(i*theta) for native double-precision complex numbers in userland.
 *
 * @theta: The angle in radians, as a double-precision floating-point value.
 * Returns the complex number representing e^(i*theta).
 */
complex_double complex_exp_i(double theta) {
    return cos(theta) + I * sin(theta);
}

#endif
```

---

## File: `complex_im.c`

### Content

```c
// complex_im.c

#include "nymya.h"

/**
 * complex_im - Returns the imaginary component of a complex_double.
 *
 * In kernel mode: returns fixed-point int64_t.
 * In userspace: returns floating-point double.
 *
 * @c: The complex number input.
 *
 * Returns:
 * Imaginary component of the input complex number.
 */
#ifdef __KERNEL__
int64_t complex_im(complex_double c) {
    return c.im;
}
#else
double complex_im(complex_double c) {
    return cimag(c);
}
#endif


```

---

## File: `complex_mul.c`

### Content

```c
// src/complex_mul.c

#include "nymya.h"

#ifdef __KERNEL__

/**
 * complex_mul - Multiply two fixed-point complex numbers.
 * @a: First operand, Q32.32 fixed-point complex_double struct.
 * @b: Second operand, Q32.32 fixed-point complex_double struct.
 *
 * Uses 128-bit intermediates to compute:
 *   (a.re + i·a.im) * (b.re + i·b.im) =
 *   (a.re*b.re - a.im*b.im) + i*(a.re*b.im + a.im*b.re)
 * Then shifts each product right by 32 bits to maintain Q32.32 format.
 *
 * Returns:
 *   The product as a complex_double in Q32.32 fixed-point.
 */
complex_double complex_mul(complex_double a, complex_double b) {
    __int128 re_part = (__int128)a.re * b.re - (__int128)a.im * b.im;
    __int128 im_part = (__int128)a.re * b.im + (__int128)a.im * b.re;

    complex_double result;
    result.re = (int64_t)(re_part >> 32);
    result.im = (int64_t)(im_part >> 32);
    return result;
}

#else

#include <complex.h>

/**
 * complex_mul - Multiply two native complex_double numbers in userland.
 * @a: First operand, native _Complex double.
 * @b: Second operand, native _Complex double.
 *
 * Returns:
 *   The product (a * b) as native complex_double.
 */
complex_double complex_mul(complex_double a, complex_double b) {
    return a * b;
}

#endif


```

---

## File: `complex_re.c`

### Content

```c
// src/complex_re.c

#include "nymya.h"

#ifdef __KERNEL__

/**
 * complex_re - Extract the real part of a fixed-point complex number.
 * @c: complex_double in Q32.32 fixed-point format.
 *
 * Returns:
 *   The real component as an int64_t in Q32.32.
 */
int64_t complex_re(complex_double c) {
    return c.re;
}

#else

#include <complex.h>

/**
 * complex_re - Extract the real part of a native complex double number.
 * @c: complex_double (native _Complex double).
 *
 * Returns:
 *   The real component as a double.
 */
double complex_re(complex_double c) {
    return creal(c);
}

#endif


```

---

## File: `fixed_complex_multiply.c`

### Content

```c
#include "nymya.h" // Include the header file for definitions like complex_double and FIXED_POINT_SCALE

// This file contains the kernel-specific implementation of fixed-point complex multiplication.
// It must be compiled with the __KERNEL__ macro defined to correctly use complex_double.

#ifdef __KERNEL__

/**
 * fixed_complex_multiply - Multiplies two fixed-point complex numbers.
 * @re1: Real part of the first complex number in Q32.32 fixed-point.
 * @im1: Imaginary part of the first complex number in Q32.32 fixed-point.
 * @re2: Real part of the second complex number in Q32.32 fixed-point.
 * @im2: Imaginary part of the second complex number in Q32.32 fixed-point.
 *
 * Multiplies two complex numbers (re1 + im1 * i) and (re2 + im2 * i)
 * using the fixed-point Q32.32 format. The result is also in Q32.32 format.
 *
 * Formula:
 * (re1 + im1 * i) * (re2 + im2 * i) = (re1 * re2 - im1 * im2) + (re1 * im2 + im1 * re2) * i
 *
 * Uses 128-bit intermediate types (`__int128`) to prevent overflow during intermediate
 * multiplications before shifting back to the 64-bit fixed-point format.
 *
 * This function is declared globally in `nymya.h` and is intended to be
 * visible across compilation units. Other files should typically use `complex_mul`
 * from `nymya.h` which operates on `complex_double` structs.
 *
 * Returns:
 * A `complex_double` struct containing both the real and imaginary parts of the product.
 */
complex_double fixed_complex_multiply(int64_t re1, int64_t im1, int64_t re2, int64_t im2)
{
    // Calculate the real part of the product: (re1 * re2) - (im1 * im2)
    // Use __int128 for intermediate calculations to prevent overflow.
    __int128 re_part = (__int128)re1 * re2 - (__int128)im1 * im2;

    // Calculate the imaginary part of the product: (re1 * im2) + (im1 * re2)
    // Use __int128 for intermediate calculations to prevent overflow.
    __int128 im_part = (__int128)re1 * im2 + (__int128)im1 * re2;

    complex_double result; // Declare result as complex_double

    // Shift right by 32 bits (equivalent to dividing by FIXED_POINT_SCALE)
    // to bring the result back to the Q32.32 fixed-point format.
    result.re = (int64_t)(re_part >> 32);
    result.im = (int64_t)(im_part >> 32);

    return result; // Return the complex_double struct containing both parts
}

#endif // __KERNEL__
```

---

## File: `fixed_conj.c`

### Content

```c
// src/fixed_conj.c

#include "nymya.h"

/**
 * fixed_conj - Returns the conjugate of a fixed-point complex number as a packed int64_t.
 * 
 * The conjugate of a complex number is obtained by negating the imaginary part.
 * 
 * @re: The real part of the fixed-point complex number (int64_t).
 * @im: The imaginary part of the fixed-point complex number (int64_t).
 * 
 * Returns:
 * - A packed int64_t, where the higher 32 bits are the real part and 
 *   the lower 32 bits are the negated imaginary part.
 */
int64_t fixed_conj(int64_t re, int64_t im) {
    // Negate the imaginary part for the conjugate
    int64_t conj_im = -im;

    // Pack real and imaginary parts into a single int64_t (higher 32 bits = real, lower 32 bits = imaginary)
    int64_t conj = (re << 32) | (conj_im & 0xFFFFFFFF); // Mask to ensure it fits into 32 bits

    return conj;
}


```

---

## File: `fixed_cos.c`

### Content

```c
#include "nymya.h"

/**
 * fixed_cos - Fixed-point cosine approximation.
 * @theta: angle in Q32.32 fixed-point format (radians).
 *
 * Uses a 6th-order Taylor series:
 *   cos(x) ≈ 1 − x^2/2 + x^4/24 − x^6/720
 *
 * All intermediate results are in Q32.32, using 128‑bit to avoid overflow.
 *
 * Return: cosine(theta) in Q32.32 fixed-point.
 */
int64_t fixed_cos(int64_t theta)
{
    // alias scale
    const int64_t ONE = FIXED_POINT_SCALE;

    // x
    __int128 x = theta;

    // x^2
    __int128 x2 = (x * x) >> 32;
    // x^4 = (x2 * x2) >>32
    __int128 x4 = (x2 * x2) >> 32;
    // x^6 = (x4 * x2) >>32
    __int128 x6 = (x4 * x2) >> 32;

    // Compute terms in Q32.32:
    __int128 term0 = ONE;                       // 1
    __int128 term1 = x2 / 2;                    // x^2/2
    __int128 term2 = x4 / 24;                   // x^4/24
    __int128 term3 = x6 / 720;                  // x^6/720

    // cos ≈ term0 − term1 + term2 − term3
    __int128 result = term0 - term1 + term2 - term3;

    return (int64_t)result;
}

```

---

## File: `fixed_point_cos.c`

### Content

```c
// src/fixed_point_cos.c

#include "nymya.h"
#include "nymya.h"
int64_t fixed_point_mul(int64_t a, int64_t b);

/**
 * fixed_point_cos - Calculate the cosine of a fixed-point angle.
 * @angle_fp: The angle in Q32.32 fixed-point format.
 *
 * Normalizes the angle to the range [-PI, PI] and uses a Taylor series
 * expansion to approximate cosine: cos(x) ≈ 1 − x²/2.
 *
 * Returns:
 *   The cosine of angle_fp as a Q32.32 fixed-point int64_t.
 */
int64_t fixed_point_cos(int64_t angle_fp) {
    // Normalize to [-PI, PI]
    while (angle_fp > FIXED_POINT_PI)
        angle_fp -= (FIXED_POINT_PI << 1);
    while (angle_fp < -FIXED_POINT_PI)
        angle_fp += (FIXED_POINT_PI << 1);

    // Taylor series: cos(x) ≈ 1 − x²/2
    int64_t one = FIXED_POINT_SCALE;
    int64_t x2 = fixed_point_mul(angle_fp, angle_fp);
    int64_t half = (int64_t)(0.5 * FIXED_POINT_SCALE);
    int64_t term2 = fixed_point_mul(x2, half);
    return one - term2;
}

```

---

## File: `fixed_point_sin.c`

### Content

```c
// src/fixed_point_sin.c

#include "nymya.h"
#include "nymya.h"
int64_t fixed_point_mul(int64_t a, int64_t b);

/**
 * fixed_point_sin - Calculate the sine of a fixed-point angle.
 * @angle_fp: The angle in Q32.32 fixed-point format.
 *
 * Normalizes the angle to the range [-PI, PI] and uses a Taylor series
 * expansion to approximate sine: sin(x) ≈ x − x³/6.
 *
 * Returns:
 *   The sine of angle_fp as a Q32.32 fixed-point int64_t.
 */
int64_t fixed_point_sin(int64_t angle_fp) {
    // Normalize to [-PI, PI]
    while (angle_fp > FIXED_POINT_PI)
        angle_fp -= (FIXED_POINT_PI << 1);
    while (angle_fp < -FIXED_POINT_PI)
        angle_fp += (FIXED_POINT_PI << 1);

    // Taylor series: sin(x) ≈ x − x³/6
    int64_t x = angle_fp;
    int64_t x2 = fixed_point_mul(x, x);
    int64_t x3 = fixed_point_mul(x2, x);
    int64_t sixth = (int64_t)((1.0/6.0) * FIXED_POINT_SCALE);
    int64_t term2 = fixed_point_mul(x3, sixth);
    return x - term2;
}

```

---

## File: `fixed_sin.c`

### Content

```c
#include "nymya.h"

/**
 * fixed_sin - Fixed-point sine approximation.
 * @theta: angle in Q32.32 fixed-point format (radians).
 *
 * Approximates sin(theta) using a 7th-order Taylor series expansion around 0:
 *    sin(x) ≈ x − x³/6 + x⁵/120 − x⁷/5040
 *
 * Uses 128-bit intermediate arithmetic to avoid overflow and maintain precision.
 *
 * Note: Best accuracy near zero; inputs outside ±π/2 should be wrapped appropriately.
 *
 * Return:
 *   sine(theta) in Q32.32 fixed-point format.
 */
int64_t fixed_sin(const int64_t theta)
{
    __int128 x = theta;
    __int128 x2 = (x * x) >> 32;       // x² in Q32.32
    __int128 x3 = (x2 * x) >> 32;      // x³
    __int128 x5 = (x3 * x2) >> 32;     // x⁵
    __int128 x7 = (x5 * x2) >> 32;     // x⁷

    __int128 term1 = x;                // x
    __int128 term2 = x3 / 6;           // x³/6
    __int128 term3 = x5 / 120;         // x⁵/120
    __int128 term4 = x7 / 5040;        // x⁷/5040

    __int128 result = term1 - term2 + term3 - term4;

    return (int64_t)result;
}


```

---

## File: `log.c`

### Content

```c
// src/log.c
//
// Defines the log_symbolic_event function for both kernel and userland.
// In the kernel, it uses pr_info for logging. In userland, it uses printf.

#include "nymya.h" // Assumed to define common types like uint64_t and nymya_qubit

#ifdef __KERNEL__
    #include <linux/kernel.h> // For pr_info
    #include <linux/module.h> // For EXPORT_SYMBOL_GPL
    #include <linux/types.h>  // For uint64_t if not already in nymya.h

    /**
     * log_symbolic_event - Kernel-side implementation for logging symbolic events.
     * @gate: The name of the gate or event.
     * @id: The ID of the primary qubit involved.
     * @tag: An optional tag for the qubit.
     * @msg: A descriptive message for the event.
     *
     * This function provides a basic logging mechanism for quantum gate operations
     * or other symbolic events within the kernel. It uses pr_info to output
     * a message to the kernel log.
     *
     * Returns: 0 on success.
     */
    int log_symbolic_event(const char* gate, uint64_t id, const char* tag, const char* msg) {
        // For kernel logging (pr_info), %llu is generally correct for uint64_t
        pr_info("NYMYA_KERNEL_EVENT: [%s] Qubit ID %llu (%s): %s\n",
                gate, id, tag ? tag : "untagged", msg);
        return 0;
    }
    // Export the symbol so other kernel modules can use this logging function.
    EXPORT_SYMBOL_GPL(log_symbolic_event);

#else // Userland implementation

    #include <stdio.h>    // For printf
    #include <stdint.h>   // For uint64_t
    #include <inttypes.h> // For PRIu64 macro

    /**
     * log_symbolic_event - Userland implementation for logging symbolic events.
     * @gate: The name of the gate or event.
     * @id: The ID of the primary qubit involved.
     * @tag: An optional tag for the qubit.
     * @msg: A descriptive message for the event.
     *
     * This function provides a basic logging mechanism for quantum gate operations
     * or other symbolic events in userland. It uses printf to output a message
     * to standard output.
     *
     * Returns: 0 on success.
     */
    int log_symbolic_event(const char* gate, uint64_t id, const char* tag, const char* msg) {
        // Using PRIu64 for platform-independent printing of uint64_t
        printf("NYMYA_USERLAND_EVENT: [%s] Qubit ID %" PRIu64 " (%s): %s\n",
               gate, id, tag ? tag : "untagged", msg);
        return 0;
    }

#endif // __KERNEL__


```

