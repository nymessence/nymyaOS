# Documented C Files from nymya-core Project

This document was automatically generated by a script to capture the content of .c files.

---

## File: `complex_conj.c`

### Content

```c
// src/complex_conj.c

#include "nymya.h"

/**
 * complex_conj - Returns the complex conjugate of a complex_double.
 *
 * In kernel mode, complex_double is a struct with fixed-point fields.
 * In user mode, complex_double is _Complex double from <complex.h>.
 *
 * @c: Input complex_double value.
 *
 * Returns:
 * The complex conjugate of the input.
 */
complex_double complex_conj(complex_double c) {
#ifdef __KERNEL__
    complex_double result;
    result.re = c.re;
    result.im = -c.im;
    return result;
#else
    return conj(c);
#endif
}


```

---

## File: `complex_exp_i.c`

### Content

```c
// complex_exp_i.c

#include "nymya.h"

#ifdef __KERNEL__
#include <linux/kernel.h>
#include <linux/types.h>

/**
 * complex_exp_i - Computes e^(i*theta) for fixed-point numbers in kernel-space.
 *
 * @theta_fp: The angle in radians, as a Q32.32 fixed-point value.
 * Returns the complex number representing e^(i*theta).
 */
complex_double complex_exp_i(int64_t theta_fp) {
    complex_double result;
    result.re = fixed_cos(theta_fp);
    result.im = fixed_sin(theta_fp);
    return result;
}

// EXPORT_SYMBOL_GPL(complex_exp_i);

#else // Userland implementation

#include <complex.h>
#include <math.h>
#include <stdio.h>

/**
 * complex_exp_i - Computes e^(i*theta) for native double-precision complex numbers in userland.
 *
 * @theta: The angle in radians, as a double-precision floating-point value.
 * Returns the complex number representing e^(i*theta).
 */
complex_double complex_exp_i(double theta) {
    return cos(theta) + I * sin(theta);
}

#endif
```

---

## File: `complex_im.c`

### Content

```c
// complex_im.c

#include "nymya.h"

/**
 * complex_im - Returns the imaginary component of a complex_double.
 *
 * In kernel mode: returns fixed-point int64_t.
 * In userspace: returns floating-point double.
 *
 * @c: The complex number input.
 *
 * Returns:
 * Imaginary component of the input complex number.
 */
#ifdef __KERNEL__
int64_t complex_im(complex_double c) {
    return c.im;
}
#else
double complex_im(complex_double c) {
    return cimag(c);
}
#endif


```

---

## File: `complex_mul.c`

### Content

```c
// src/complex_mul.c

#include "nymya.h"

#ifdef __KERNEL__

/**
 * complex_mul - Multiply two fixed-point complex numbers.
 * @a: First operand, Q32.32 fixed-point complex_double struct.
 * @b: Second operand, Q32.32 fixed-point complex_double struct.
 *
 * Uses 128-bit intermediates to compute:
 *   (a.re + i·a.im) * (b.re + i·b.im) =
 *   (a.re*b.re - a.im*b.im) + i*(a.re*b.im + a.im*b.re)
 * Then shifts each product right by 32 bits to maintain Q32.32 format.
 *
 * Returns:
 *   The product as a complex_double in Q32.32 fixed-point.
 */
complex_double complex_mul(complex_double a, complex_double b) {
    __int128 re_part = (__int128)a.re * b.re - (__int128)a.im * b.im;
    __int128 im_part = (__int128)a.re * b.im + (__int128)a.im * b.re;

    complex_double result;
    result.re = (int64_t)(re_part >> 32);
    result.im = (int64_t)(im_part >> 32);
    return result;
}

#else

#include <complex.h>

/**
 * complex_mul - Multiply two native complex_double numbers in userland.
 * @a: First operand, native _Complex double.
 * @b: Second operand, native _Complex double.
 *
 * Returns:
 *   The product (a * b) as native complex_double.
 */
complex_double complex_mul(complex_double a, complex_double b) {
    return a * b;
}

#endif


```

---

## File: `complex_re.c`

### Content

```c
// src/complex_re.c

#include "nymya.h"

#ifdef __KERNEL__

/**
 * complex_re - Extract the real part of a fixed-point complex number.
 * @c: complex_double in Q32.32 fixed-point format.
 *
 * Returns:
 *   The real component as an int64_t in Q32.32.
 */
int64_t complex_re(complex_double c) {
    return c.re;
}

#else

#include <complex.h>

/**
 * complex_re - Extract the real part of a native complex double number.
 * @c: complex_double (native _Complex double).
 *
 * Returns:
 *   The real component as a double.
 */
double complex_re(complex_double c) {
    return creal(c);
}

#endif


```

---

## File: `fixed_complex_multiply.c`

### Content

```c
#include "nymya.h" // Include the header file for definitions like complex_double and FIXED_POINT_SCALE

// This file contains the kernel-specific implementation of fixed-point complex multiplication.
// It must be compiled with the __KERNEL__ macro defined to correctly use complex_double.

#ifdef __KERNEL__

/**
 * fixed_complex_multiply - Multiplies two fixed-point complex numbers.
 * @re1: Real part of the first complex number in Q32.32 fixed-point.
 * @im1: Imaginary part of the first complex number in Q32.32 fixed-point.
 * @re2: Real part of the second complex number in Q32.32 fixed-point.
 * @im2: Imaginary part of the second complex number in Q32.32 fixed-point.
 *
 * Multiplies two complex numbers (re1 + im1 * i) and (re2 + im2 * i)
 * using the fixed-point Q32.32 format. The result is also in Q32.32 format.
 *
 * Formula:
 * (re1 + im1 * i) * (re2 + im2 * i) = (re1 * re2 - im1 * im2) + (re1 * im2 + im1 * re2) * i
 *
 * Uses 128-bit intermediate types (`__int128`) to prevent overflow during intermediate
 * multiplications before shifting back to the 64-bit fixed-point format.
 *
 * This function is declared globally in `nymya.h` and is intended to be
 * visible across compilation units. Other files should typically use `complex_mul`
 * from `nymya.h` which operates on `complex_double` structs.
 *
 * Returns:
 * A `complex_double` struct containing both the real and imaginary parts of the product.
 */
complex_double fixed_complex_multiply(int64_t re1, int64_t im1, int64_t re2, int64_t im2)
{
    // Calculate the real part of the product: (re1 * re2) - (im1 * im2)
    // Use __int128 for intermediate calculations to prevent overflow.
    __int128 re_part = (__int128)re1 * re2 - (__int128)im1 * im2;

    // Calculate the imaginary part of the product: (re1 * im2) + (im1 * re2)
    // Use __int128 for intermediate calculations to prevent overflow.
    __int128 im_part = (__int128)re1 * im2 + (__int128)im1 * re2;

    complex_double result; // Declare result as complex_double

    // Shift right by 32 bits (equivalent to dividing by FIXED_POINT_SCALE)
    // to bring the result back to the Q32.32 fixed-point format.
    result.re = (int64_t)(re_part >> 32);
    result.im = (int64_t)(im_part >> 32);

    return result; // Return the complex_double struct containing both parts
}

#endif // __KERNEL__
```

---

## File: `fixed_conj.c`

### Content

```c
// src/fixed_conj.c

#include "nymya.h"

/**
 * fixed_conj - Returns the conjugate of a fixed-point complex number as a packed int64_t.
 * 
 * The conjugate of a complex number is obtained by negating the imaginary part.
 * 
 * @re: The real part of the fixed-point complex number (int64_t).
 * @im: The imaginary part of the fixed-point complex number (int64_t).
 * 
 * Returns:
 * - A packed int64_t, where the higher 32 bits are the real part and 
 *   the lower 32 bits are the negated imaginary part.
 */
int64_t fixed_conj(int64_t re, int64_t im) {
    // Negate the imaginary part for the conjugate
    int64_t conj_im = -im;

    // Pack real and imaginary parts into a single int64_t (higher 32 bits = real, lower 32 bits = imaginary)
    int64_t conj = (re << 32) | (conj_im & 0xFFFFFFFF); // Mask to ensure it fits into 32 bits

    return conj;
}


```

---

## File: `fixed_cos.c`

### Content

```c
#include "nymya.h"

/**
 * fixed_cos - Fixed-point cosine approximation.
 * @theta: angle in Q32.32 fixed-point format (radians).
 *
 * Uses a 6th-order Taylor series:
 *   cos(x) ≈ 1 − x^2/2 + x^4/24 − x^6/720
 *
 * All intermediate results are in Q32.32, using 128‑bit to avoid overflow.
 *
 * Return: cosine(theta) in Q32.32 fixed-point.
 */
int64_t fixed_cos(int64_t theta)
{
    // alias scale
    const int64_t ONE = FIXED_POINT_SCALE;

    // x
    __int128 x = theta;

    // x^2
    __int128 x2 = (x * x) >> 32;
    // x^4 = (x2 * x2) >>32
    __int128 x4 = (x2 * x2) >> 32;
    // x^6 = (x4 * x2) >>32
    __int128 x6 = (x4 * x2) >> 32;

    // Compute terms in Q32.32:
    __int128 term0 = ONE;                       // 1
    __int128 term1 = x2 / 2;                    // x^2/2
    __int128 term2 = x4 / 24;                   // x^4/24
    __int128 term3 = x6 / 720;                  // x^6/720

    // cos ≈ term0 − term1 + term2 − term3
    __int128 result = term0 - term1 + term2 - term3;

    return (int64_t)result;
}

```

---

## File: `fixed_point_cos.c`

### Content

```c
// src/fixed_point_cos.c

#include "nymya.h"
#include "nymya.h"
int64_t fixed_point_mul(int64_t a, int64_t b);

/**
 * fixed_point_cos - Calculate the cosine of a fixed-point angle.
 * @angle_fp: The angle in Q32.32 fixed-point format.
 *
 * Normalizes the angle to the range [-PI, PI] and uses a Taylor series
 * expansion to approximate cosine: cos(x) ≈ 1 − x²/2.
 *
 * Returns:
 *   The cosine of angle_fp as a Q32.32 fixed-point int64_t.
 */
int64_t fixed_point_cos(int64_t angle_fp) {
    // Normalize to [-PI, PI]
    while (angle_fp > FIXED_POINT_PI)
        angle_fp -= (FIXED_POINT_PI << 1);
    while (angle_fp < -FIXED_POINT_PI)
        angle_fp += (FIXED_POINT_PI << 1);

    // Taylor series: cos(x) ≈ 1 − x²/2
    int64_t one = FIXED_POINT_SCALE;
    int64_t x2 = fixed_point_mul(angle_fp, angle_fp);
    int64_t half = (int64_t)(0.5 * FIXED_POINT_SCALE);
    int64_t term2 = fixed_point_mul(x2, half);
    return one - term2;
}

```

---

## File: `fixed_point_sin.c`

### Content

```c
// src/fixed_point_sin.c

#include "nymya.h"
#include "nymya.h"
int64_t fixed_point_mul(int64_t a, int64_t b);

/**
 * fixed_point_sin - Calculate the sine of a fixed-point angle.
 * @angle_fp: The angle in Q32.32 fixed-point format.
 *
 * Normalizes the angle to the range [-PI, PI] and uses a Taylor series
 * expansion to approximate sine: sin(x) ≈ x − x³/6.
 *
 * Returns:
 *   The sine of angle_fp as a Q32.32 fixed-point int64_t.
 */
int64_t fixed_point_sin(int64_t angle_fp) {
    // Normalize to [-PI, PI]
    while (angle_fp > FIXED_POINT_PI)
        angle_fp -= (FIXED_POINT_PI << 1);
    while (angle_fp < -FIXED_POINT_PI)
        angle_fp += (FIXED_POINT_PI << 1);

    // Taylor series: sin(x) ≈ x − x³/6
    int64_t x = angle_fp;
    int64_t x2 = fixed_point_mul(x, x);
    int64_t x3 = fixed_point_mul(x2, x);
    int64_t sixth = (int64_t)((1.0/6.0) * FIXED_POINT_SCALE);
    int64_t term2 = fixed_point_mul(x3, sixth);
    return x - term2;
}

```

---

## File: `fixed_sin.c`

### Content

```c
#include "nymya.h"

/**
 * fixed_sin - Fixed-point sine approximation.
 * @theta: angle in Q32.32 fixed-point format (radians).
 *
 * Approximates sin(theta) using a 7th-order Taylor series expansion around 0:
 *    sin(x) ≈ x − x³/6 + x⁵/120 − x⁷/5040
 *
 * Uses 128-bit intermediate arithmetic to avoid overflow and maintain precision.
 *
 * Note: Best accuracy near zero; inputs outside ±π/2 should be wrapped appropriately.
 *
 * Return:
 *   sine(theta) in Q32.32 fixed-point format.
 */
int64_t fixed_sin(const int64_t theta)
{
    __int128 x = theta;
    __int128 x2 = (x * x) >> 32;       // x² in Q32.32
    __int128 x3 = (x2 * x) >> 32;      // x³
    __int128 x5 = (x3 * x2) >> 32;     // x⁵
    __int128 x7 = (x5 * x2) >> 32;     // x⁷

    __int128 term1 = x;                // x
    __int128 term2 = x3 / 6;           // x³/6
    __int128 term3 = x5 / 120;         // x⁵/120
    __int128 term4 = x7 / 5040;        // x⁷/5040

    __int128 result = term1 - term2 + term3 - term4;

    return (int64_t)result;
}


```

---

## File: `log.c`

### Content

```c
// src/log.c
//
// Defines the log_symbolic_event function for both kernel and userland.
// In the kernel, it uses pr_info for logging. In userland, it uses printf.

#include "nymya.h" // Assumed to define common types like uint64_t and nymya_qubit

#ifdef __KERNEL__
    #include <linux/kernel.h> // For pr_info
    #include <linux/module.h> // For EXPORT_SYMBOL_GPL
    #include <linux/types.h>  // For uint64_t if not already in nymya.h

    /**
     * log_symbolic_event - Kernel-side implementation for logging symbolic events.
     * @gate: The name of the gate or event.
     * @id: The ID of the primary qubit involved.
     * @tag: An optional tag for the qubit.
     * @msg: A descriptive message for the event.
     *
     * This function provides a basic logging mechanism for quantum gate operations
     * or other symbolic events within the kernel. It uses pr_info to output
     * a message to the kernel log.
     *
     * Returns: 0 on success.
     */
    int log_symbolic_event(const char* gate, uint64_t id, const char* tag, const char* msg) {
        // For kernel logging (pr_info), %llu is generally correct for uint64_t
        pr_info("NYMYA_KERNEL_EVENT: [%s] Qubit ID %llu (%s): %s\n",
                gate, id, tag ? tag : "untagged", msg);
        return 0;
    }
    // Export the symbol so other kernel modules can use this logging function.
    EXPORT_SYMBOL_GPL(log_symbolic_event);

#else // Userland implementation

    #include <stdio.h>    // For printf
    #include <stdint.h>   // For uint64_t
    #include <inttypes.h> // For PRIu64 macro

    /**
     * log_symbolic_event - Userland implementation for logging symbolic events.
     * @gate: The name of the gate or event.
     * @id: The ID of the primary qubit involved.
     * @tag: An optional tag for the qubit.
     * @msg: A descriptive message for the event.
     *
     * This function provides a basic logging mechanism for quantum gate operations
     * or other symbolic events in userland. It uses printf to output a message
     * to standard output.
     *
     * Returns: 0 on success.
     */
    int log_symbolic_event(const char* gate, uint64_t id, const char* tag, const char* msg) {
        // Using PRIu64 for platform-independent printing of uint64_t
        printf("NYMYA_USERLAND_EVENT: [%s] Qubit ID %" PRIu64 " (%s): %s\n",
               gate, id, tag ? tag : "untagged", msg);
        return 0;
    }

#endif // __KERNEL__


```

---

## File: `nymya_3301_identity_gate.c`

### Content

```c
// src/nymya_3301_identity_gate.c

#include "nymya.h"

#ifdef __KERNEL__

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/types.h>

/*
 * Syscall: nymya_3301_identity_gate
 * Purpose: Apply the quantum identity gate (I) to a qubit.
 * Parameters:
 *     @user_q: Pointer to user-space `nymya_qubit` structure.
 * Behavior:
 *     - Reads the qubit structure from user space.
 *     - Logs a symbolic event to indicate no-op (identity) transformation.
 * Notes:
 *     - This is a symbolic operation only; does not alter amplitude.
 *     - Useful for preserving causality or marking a moment in symbolic space.
 * Return:
 *     0 on success, -EINVAL if null, -EFAULT if copy fails.
 */
SYSCALL_DEFINE1(nymya_3301_identity_gate, struct nymya_qubit __user *, user_q)
{
    struct nymya_qubit kq;

    if (!user_q)
        return -EINVAL;

    if (copy_from_user(&kq, user_q, sizeof(struct nymya_qubit)))
        return -EFAULT;

    log_symbolic_event("ID_GATE", kq.id, kq.tag, "State preserved");
    return 0;
}

// Only needed if other kernel modules will call this function directly.
// Uncomment this if a non-syscall kernel symbol is defined elsewhere.
// EXPORT_SYMBOL_GPL(nymya_3301_identity_gate);

#else

#include <stdio.h>
#include <stdlib.h>

/*
 * Userspace Fallback: nymya_3301_identity_gate
 * Purpose: Log identity gate operation on symbolic qubit.
 * Parameters:
 *     @q: Pointer to symbolic qubit.
 * Behavior:
 *     - Logs the event with tag and ID.
 *     - Used for userland simulation/testing environments.
 * Return:
 *     0 on success, -1 if input is null.
 */
int nymya_3301_identity_gate(nymya_qubit* q)
{
    if (!q)
        return -1;

    log_symbolic_event("ID_GATE", q->id, q->tag, "State preserved");
    return 0;
}

#endif


```

---

## File: `nymya_3302_global_phase.c`

### Content

```c
#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3302_global_phase NYMYA_GLOBAL_PHASE_CODE

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <complex.h>

// Safely override complex math macros only in userland simulation
#ifdef nymya_cexp
#undef nymya_cexp
#endif
#define nymya_cexp(theta) cexp(I * (theta))

#ifdef nymya_cmul
#undef nymya_cmul
#endif
#define nymya_cmul(a, b) ((a) * (b))

#else
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/errno.h>
#include <linux/module.h>  // Required for EXPORT_SYMBOL_GPL
#include <linux/string.h>  // For snprintf
#endif

/**
 * nymya_3302_global_phase - Apply global phase shift to a symbolic qubit
 * @q: Pointer to a symbolic qubit
 * @theta: Phase angle in radians (double for userland).
 *
 * Multiplies the qubit’s amplitude by e^(iθ), applying a global phase.
 * No probability amplitudes are altered, only the phase.
 * Logs symbolic event with phase shift details.
 *
 * Returns 0 on success, or -1 if the input is invalid.
 */
#ifndef __KERNEL__

int nymya_3302_global_phase(nymya_qubit* q, double theta) {
    if (!q) return -1;

    complex_double phase = nymya_cexp(theta);
    q->amplitude = nymya_cmul(q->amplitude, phase);

    char log_msg[128];
    snprintf(log_msg, sizeof(log_msg), "Applied phase shift θ=%.3f rad", theta);
    log_symbolic_event("GPHASE", q->id, q->tag, log_msg);

    return 0;
}

#else // __KERNEL__

/**
 * nymya_3302_global_phase - Core kernel function to apply global phase shift.
 * @q: Pointer to the kernel-space qubit structure.
 * @theta_fixed: Phase angle in fixed-point (int64_t) format.
 *
 * Multiplies the qubit's amplitude by e^(i*theta_fixed), applying a global phase.
 * This function is designed to be called directly by other kernel code.
 *
 * Returns 0 on success, -EINVAL if the qubit pointer is NULL.
 */
int nymya_3302_global_phase(struct nymya_qubit *q, int64_t theta_fixed) {
    complex_double phase_factor;

    if (!q) {
        pr_err("NYMYA: nymya_3302_global_phase received NULL qubit pointer\n");
        return -EINVAL;
    }

    phase_factor.re = fixed_cos(theta_fixed);
    phase_factor.im = fixed_sin(theta_fixed);

    q->amplitude = complex_mul(q->amplitude, phase_factor);

    return 0;
}

EXPORT_SYMBOL_GPL(nymya_3302_global_phase);

/**
 * SYSCALL_DEFINE2(nymya_3302_global_phase) - Kernel system call for global phase shift.
 * @user_q: User-space pointer to the qubit struct.
 * @theta_fixed: Phase angle already converted to fixed-point (int64_t) from user space.
 *
 * This syscall handles copying the qubit from user space, calls the core global phase
 * function, and copies the modified qubit back to user space. The phase angle
 * is expected to be provided as a fixed-point integer directly by userland.
 *
 * Returns 0 on success, -EINVAL on invalid pointers, -EFAULT on copy errors.
 */
SYSCALL_DEFINE2(nymya_3302_global_phase,
    struct nymya_qubit __user *, user_q,
    int64_t, theta_fixed)
{
    struct nymya_qubit kq;
    int ret;
    char log_msg[128];

    if (!user_q)
        return -EINVAL;

    if (copy_from_user(&kq, user_q, sizeof(kq)))
        return -EFAULT;

    ret = nymya_3302_global_phase(&kq, theta_fixed);
    if (ret)
        return ret;

    snprintf(log_msg, sizeof(log_msg), "Applied phase shift (fixed-point)=%lld", (long long)theta_fixed);
    log_symbolic_event("GPHASE", kq.id, kq.tag, log_msg);

    if (copy_to_user(user_q, &kq, sizeof(kq)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3303_pauli_x.c`

### Content

```c
#include "nymya.h"

#ifdef __KERNEL__
    #include <linux/module.h>
    #include <linux/kernel.h>
    #include <linux/syscalls.h> // Keep for compatibility, though not directly using SYSCALL_DEFINE for this function
    #include <linux/uaccess.h>
    #include <linux/errno.h> // For -EINVAL, -EFAULT

/*
 * Flip imaginary part sign in fixed-point amplitude
 */
static inline void flip_imag_part(struct nymya_qubit *q) {
    q->amplitude.im = -q->amplitude.im;
}

// The function is now defined as a regular kernel function named nymya_3303_pauli_x,
// to match the requested EXPORT_SYMBOL_GPL name.
// It uses 'int' as a return type, consistent with typical kernel function return values for success/error.
// The parameter type has been changed from '__user *user_q' to '*q'
// to match the expected declaration and
// the logic for copying from/to user space has been removed, as this function
// is now expected to operate on a kernel-space pointer.
int nymya_3303_pauli_x(struct nymya_qubit *q) {
    if (!q)
        return -EINVAL;

    flip_imag_part(q);

    // Assuming log_symbolic_event is properly defined and accessible in the kernel context
    log_symbolic_event("PAULI_X", q->id, q->tag, "Polarity flipped");

    return 0;
}

// Export the symbol for use by other kernel modules/code.
// Changed to export 'nymya_3303_pauli_x' as requested.
EXPORT_SYMBOL_GPL(nymya_3303_pauli_x);

#else // Userland implementation

#include <stdio.h>
#include <complex.h> // Ensure this is included for _Complex and I

/*
 * Flip imaginary part sign in builtin complex amplitude
 */
static inline void flip_imag_part(nymya_qubit *q) {
    // Assuming nymya_qubit's amplitude is _Complex double in userland
    // For direct manipulation, if q->amplitude is _Complex double:
    q->amplitude = creal(q->amplitude) - I * cimag(q->amplitude);
}

/*
 * Userland implementation of the Pauli-X gate
 * @q: pointer to symbolic qubit
 *
 * Flips the sign of the imaginary part of the amplitude.
 * Logs the symbolic event with qubit ID and tag.
 *
 * Returns 0 on success, -1 if input is null.
 */
int nymya_3303_pauli_x(nymya_qubit *q) {
    if (!q) return -1;

    flip_imag_part(q);

    log_symbolic_event("PAULI_X", q->id, q->tag, "Polarity flipped");
    return 0;
}

#endif // __KERNEL__
```

---

## File: `nymya_3304_pauli_y.c`

### Content

```c
// src/nymya_3304_pauli_y.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#define __NR_nymya_3304_pauli_y NYMYA_PAULI_Y_CODE

#include <unistd.h>
    #include <stdio.h>
    #include <stdlib.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/*
 * User-space implementation of Pauli-Y gate on a qubit.
 * Multiplies amplitude by the imaginary unit i:
 * (a + bi) * i = -b + ai
 */
int nymya_3304_pauli_y(nymya_qubit* q) {
    if (!q) return -1;

    // Using complex_double as _Complex double in user-space:
    q->amplitude = make_complex(-complex_im(q->amplitude), complex_re(q->amplitude));

    log_symbolic_event("PAULI_Y", q->id, q->tag, "Dream vector rotated");
    return 0;
}

#else

/**
 * @brief Applies the Pauli-Y gate logic to a kernel-space qubit.
 *
 * This function performs the core operation of the Pauli-Y gate,
 * multiplying the qubit's amplitude by the imaginary unit 'i'.
 * In the fixed-point complex representation, this involves swapping
 * the real and imaginary parts and negating the new real part.
 *
 * @param kq A pointer to the kernel-space nymya_qubit structure to operate on.
 * @return 0 on success, or a negative error code if an internal issue occurs.
 */
int nymya_3304_pauli_y(struct nymya_qubit *kq) {
    int64_t re, im;

    // A defensive check, though kq should be valid from the syscall wrapper
    if (!kq) {
        return -EINVAL;
    }

    // Extract fixed-point real and imaginary parts
    re = kq->amplitude.re;
    im = kq->amplitude.im;

    // Multiply amplitude by i: (a + bi)*i = -b + ai
    kq->amplitude.re = -im;
    kq->amplitude.im = re;

    log_symbolic_event("PAULI_Y", kq->id, kq->tag, "Dream vector rotated");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3304_pauli_y);

/*
 * Kernel syscall: nymya_3304_pauli_y
 * Multiplies the qubit amplitude by i.
 * Note: kernel uses fixed-point complex, so manually swap real and imag parts.
 */
SYSCALL_DEFINE1(nymya_3304_pauli_y, struct nymya_qubit __user *, user_q) {
    struct nymya_qubit kq;
    int ret;

    if (!user_q)
        return -EINVAL;
    if (copy_from_user(&kq, user_q, sizeof(kq)))
        return -EFAULT;

    // Call the extracted core logic function
    ret = nymya_3304_pauli_y(&kq);
    if (ret) {
        // Propagate any error from the core logic
        return ret;
    }

    if (copy_to_user(user_q, &kq, sizeof(kq)))
        return -EFAULT;

    return 0;
}

#endif

```

---

## File: `nymya_3305_pauli_z.c`

### Content

```c
// src/nymya_3305_pauli_z.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#define __NR_nymya_3305_pauli_z NYMYA_PAULI_Z_CODE

#include <unistd.h>
    #include <stdio.h>
    #include <stdlib.h>
#else
    int nymya_3305_pauli_z_core(struct nymya_qubit *kq);


    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/*
 * User-space implementation of Pauli-Z gate.
 * Multiplies the qubit amplitude by -1 (negates both real and imag parts).
 */
int nymya_3305_pauli_z(nymya_qubit* q) {
    if (!q) return -1;

    q->amplitude = make_complex(-complex_re(q->amplitude), -complex_im(q->amplitude));

    log_symbolic_event("PAULI_Z", q->id, q->tag, "Inverted inner state");
    return 0;
}

#else

/**
 * @brief Applies the Pauli-Z gate operation to a kernel-space qubit.
 *
 * This function negates the fixed-point real and imaginary parts of the
 * qubit's amplitude, effectively applying a phase shift of pi (Z gate).
 * It also logs a symbolic event for this operation.
 *
 * @param kq Pointer to the kernel-space nymya_qubit structure.
 * @return 0 on success. Currently, no specific error conditions are handled,
 *         but returns an int for future extensibility.
 */
int nymya_3305_pauli_z_core(struct nymya_qubit *kq) {
    int64_t re, im;

    // No need for null check here, as syscall wrapper ensures valid kq pointer
    // if it passed copy_from_user.

    re = kq->amplitude.re;
    im = kq->amplitude.im;

    kq->amplitude.re = -re;
    kq->amplitude.im = -im;

    log_symbolic_event("PAULI_Z", kq->id, kq->tag, "Inverted inner state");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3305_pauli_z_core);

/*
 * Kernel syscall: nymya_3305_pauli_z
 * Negates the fixed-point amplitude of the qubit.
 */
SYSCALL_DEFINE1(nymya_3305_pauli_z, struct nymya_qubit __user *, user_q) {
    struct nymya_qubit kq;
    int ret;

    if (!user_q)
        return -EINVAL;
    if (copy_from_user(&kq, user_q, sizeof(kq)))
        return -EFAULT;

    // Call the core logic function
    ret = nymya_3305_pauli_z_core(&kq);
    if (ret) {
        // Propagate error from the core function if it returns one
        return ret;
    }

    if (copy_to_user(user_q, &kq, sizeof(kq)))
        return -EFAULT;

    return 0;
}

#endif
```

---

## File: `nymya_3306_phase_gate.c`

### Content

```c
// src/nymya_3306_phase_gate.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3306_phase_gate NYMYA_PHASE_S_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL

    /**
     * nymya_3306_phase_gate - Core kernel function for Phase (S) gate logic.
     * @q: Pointer to the nymya_qubit structure.
     *
     * This function applies the Phase (S) gate logic to a qubit's amplitude.
     * It multiplies the amplitude by fixed-point 'i' (equivalent to phase shift π/2).
     * This function is designed to be called directly by other kernel code.
     *
     * Returns: 0 on success.
     */
    int nymya_3306_phase_gate(struct nymya_qubit *q) {
        int64_t re, im;

        if (!q) {
            pr_err("NYMYA: nymya_3306_phase_gate received NULL qubit pointer\n");
            return -EINVAL; // Return an error if qubit is null
        }

        re = q->amplitude.re;
        im = q->amplitude.im;

        // (a + bi) * i = -b + ai
        q->amplitude.re = -im;
        q->amplitude.im = re;

        log_symbolic_event("PHASE_S", q->id, q->tag, "Applied S gate (π/2 phase)");
        return 0;
    }
    // Export the symbol for this function so other kernel modules/code can call it directly.
    EXPORT_SYMBOL_GPL(nymya_3306_phase_gate);

    /*
     * Kernel syscall: nymya_3306_phase_gate
     * This is the syscall entry point that wraps the core nymya_3306_phase_gate function.
     * It handles user-space copy operations before and after calling the core logic.
     */
    SYSCALL_DEFINE1(nymya_3306_phase_gate, struct nymya_qubit __user *, user_q) {
        struct nymya_qubit kq;
        int ret;

        if (!user_q)
            return -EINVAL;

        // Copy qubit data from user space to kernel space
        if (copy_from_user(&kq, user_q, sizeof(kq)))
            return -EFAULT;

        // Call the core logic function defined above
        ret = nymya_3306_phase_gate(&kq);

        if (ret) // If the core function returned an error, propagate it
            return ret;

        // Copy modified qubit data from kernel space back to user space
        if (copy_to_user(user_q, &kq, sizeof(kq)))
            return -EFAULT;

        return 0;
    }

#endif


```

---

## File: `nymya_3307_sqrt_x_gate.c`

### Content

```c
// src/nymya_3307_sqrt_x_gate.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3307_sqrt_x_gate NYMYA_SQRT_X_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL

    /**
     * nymya_3307_sqrt_x_gate - Core kernel function for Square Root X gate logic.
     * @q: Pointer to the nymya_qubit structure.
     *
     * This function applies the Square Root X gate logic to a qubit's amplitude
     * using fixed-point arithmetic. It's equivalent to multiplying by (1/√2)(1 + i).
     * This function is designed to be called directly by other kernel code.
     *
     * Returns: 0 on success.
     */
    int nymya_3307_sqrt_x_gate(struct nymya_qubit *q) {
        int64_t re, im;
        // fixed-point approximation of 1/sqrt(2)
        const int64_t c_re = (int64_t)(0.70710678 * FIXED_POINT_SCALE);
        const int64_t c_im = (int64_t)(0.70710678 * FIXED_POINT_SCALE);

        if (!q) {
            pr_err("NYMYA: nymya_3307_sqrt_x_gate received NULL qubit pointer\n");
            return -EINVAL;
        }

        re = q->amplitude.re;
        im = q->amplitude.im;

        // Fixed-point complex multiplication:
        // new_re = (re*c_re - im*c_im) / FIXED_POINT_SCALE
        // new_im = (re*c_im + im*c_re) / FIXED_POINT_SCALE
        // Using __int128 for intermediate calculation to prevent overflow before shifting
        __int128 temp_re = (__int128)re * c_re - (__int128)im * c_im;
        __int128 temp_im = (__int128)re * c_im + (__int128)im * c_re;

        q->amplitude.re = (int64_t)(temp_re >> 32); // Assuming FIXED_POINT_SCALE is 2^32
        q->amplitude.im = (int64_t)(temp_im >> 32); // Assuming FIXED_POINT_SCALE is 2^32

        log_symbolic_event("SQRT_X", q->id, q->tag, "Applied √X gate (liminal rotation)");
        return 0;
    }
    // Export the symbol for this function so other kernel modules/code can call it directly.
    EXPORT_SYMBOL_GPL(nymya_3307_sqrt_x_gate);


    /*
     * Kernel syscall: nymya_3307_sqrt_x_gate
     * This is the syscall entry point that wraps the core nymya_3307_sqrt_x_gate function.
     * It handles user-space copy operations before and after calling the core logic.
     */
    SYSCALL_DEFINE1(nymya_3307_sqrt_x_gate, struct nymya_qubit __user *, user_q) {
        struct nymya_qubit kq;
        int ret;

        if (!user_q)
            return -EINVAL;
        if (copy_from_user(&kq, user_q, sizeof(kq)))
            return -EFAULT;

        // Call the core logic function defined above
        ret = nymya_3307_sqrt_x_gate(&kq);

        if (ret) // If the core function returned an error, propagate it
            return ret;

        if (copy_to_user(user_q, &kq, sizeof(kq)))
            return -EFAULT;

        return 0;
    }

#endif


```

---

## File: `nymya_3308_hadamard_gate.c`

### Content

```c
// src/nymya_3308_hadamard_gate.c
//
// Implements the Hadamard gate (H gate) for a qubit amplitude.
// The Hadamard gate creates superposition by scaling the amplitude by 1/√2.
//
// In user-space, uses standard complex double arithmetic.
// In kernel-space, uses fixed-point arithmetic consistent with nymya.h definitions.
//

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3308_hadamard_gate NYMYA_HADAMARD_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/*
 * Function: nymya_3308_hadamard_gate
 * ----------------------------------
 * Applies the Hadamard gate to the qubit's amplitude.
 * Scales the amplitude by 1/√2 (approximately 0.70710678).
 *
 * Parameters:
 * q - pointer to nymya_qubit struct in user-space
 *
 * Returns:
 * 0 on success, -1 if q is NULL
 */
int nymya_3308_hadamard_gate(nymya_qubit* q) {
    if (!q) return -1;

    // Scale the complex amplitude by 1/sqrt(2)
    q->amplitude *= (1.0 / sqrt(2.0));

    log_symbolic_event("HADAMARD", q->id, q->tag, "Applied H gate (superposition)");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3308_hadamard_gate - Core kernel function for Hadamard gate.
 * @q: Pointer to the nymya_qubit structure.
 *
 * This function applies the Hadamard gate logic, scaling the qubit's amplitude
 * by a fixed-point approximation of 1/√2.
 * This function is designed to be called directly by other kernel code.
 *
 * Returns:
 * 0 on success.
 * -EINVAL if the qubit pointer is NULL.
 */
int nymya_3308_hadamard_gate(struct nymya_qubit *q) {
    int64_t re, im;
    // Fixed-point representation of 1/sqrt(2)
    const int64_t scale = (int64_t)(0.70710678 * FIXED_POINT_SCALE);

    if (!q) {
        pr_err("NYMYA: nymya_3308_hadamard_gate received NULL qubit pointer\n");
        return -EINVAL;
    }

    re = q->amplitude.re;
    im = q->amplitude.im;

    // Multiply real and imaginary parts by scale, then shift back to fixed-point range
    // Assuming FIXED_POINT_SCALE is 2^32, so right shift by 32 bits.
    q->amplitude.re = (re * scale) >> 32;
    q->amplitude.im = (im * scale) >> 32;

    log_symbolic_event("HADAMARD", q->id, q->tag, "Applied H gate (superposition)");
    return 0;
}

// Export the symbol for this function so other kernel modules/code can call it directly.
EXPORT_SYMBOL_GPL(nymya_3308_hadamard_gate);


/*
 * Syscall: nymya_3308_hadamard_gate
 * ---------------------------------
 * Kernel-space syscall handler for Hadamard gate.
 * Multiplies the qubit's amplitude by fixed-point 1/√2 using 64-bit integer math.
 *
 * Parameters:
 * user_q - pointer to user-space nymya_qubit struct
 *
 * Returns:
 * 0 on success
 * -EINVAL if user_q is NULL
 * -EFAULT if copying from/to user space fails
 */
SYSCALL_DEFINE1(nymya_3308_hadamard_gate, struct nymya_qubit __user *, user_q) {
    struct nymya_qubit kq;
    int ret;

    if (!user_q)
        return -EINVAL;
    if (copy_from_user(&kq, user_q, sizeof(kq)))
        return -EFAULT;

    // Call the core logic function defined above
    ret = nymya_3308_hadamard_gate(&kq);

    if (ret) // If the core function returned an error, propagate it
        return ret;

    if (copy_to_user(user_q, &kq, sizeof(kq)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3309_controlled_not.c`

### Content

```c
// src/nymya_3309_controlled_not.c
//
// Implements the Controlled-NOT (CNOT) gate for Nymya qubits.
// The CNOT flips the target qubit's phase if the control qubit's amplitude magnitude > 0.5.
//
// User-space uses standard complex doubles.
// Kernel-space uses fixed-point math and careful user memory handling.
//

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3309_controlled_not NYMYA_CNOT_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/*
 * Function: nymya_3309_controlled_not
 * -----------------------------------
 * Applies the Controlled-NOT gate.
 * If control qubit's amplitude magnitude > 0.5, flips the sign of the target's amplitude.
 *
 * Parameters:
 * q_ctrl   - pointer to control qubit
 * q_target - pointer to target qubit
 *
 * Returns:
 * 0 on success, -1 if either pointer is NULL
 */
int nymya_3309_controlled_not(nymya_qubit* q_ctrl, nymya_qubit* q_target) {
    if (!q_ctrl || !q_target) return -1;

    // Compute magnitude of control qubit amplitude
    double magnitude = cabs(q_ctrl->amplitude);

    if (magnitude > 0.5) {
        // Flip target amplitude phase
        q_target->amplitude *= -1;
        log_symbolic_event("CNOT", q_target->id, q_target->tag, "NOT applied via control");
    } else {
        log_symbolic_event("CNOT", q_target->id, q_target->tag, "No action (control = 0)");
    }

    return 0;
}

#else // __KERNEL__

/**
 * nymya_3309_controlled_not - Core kernel function for Controlled-NOT (CNOT) gate.
 * @q_ctrl: Pointer to the control qubit.
 * @q_target: Pointer to the target qubit.
 *
 * This function applies the CNOT gate logic: if the control qubit's amplitude
 * magnitude squared is above a threshold, it flips the sign of the target qubit's amplitude.
 * This function is designed to be called directly by other kernel code.
 *
 * Returns:
 * 0 on success.
 * -EINVAL if either qubit pointer is NULL.
 */
int nymya_3309_controlled_not(struct nymya_qubit *q_ctrl, struct nymya_qubit *q_target) {
    int64_t ctrl_re, ctrl_im;

    if (!q_ctrl || !q_target) {
        pr_err("NYMYA: nymya_3309_controlled_not received NULL qubit pointer(s)\n");
        return -EINVAL;
    }

    ctrl_re = q_ctrl->amplitude.re;
    ctrl_im = q_ctrl->amplitude.im;

    // Calculate magnitude squared in fixed-point: (re^2 + im^2)
    // The result is still in a higher fixed-point scale, so we compare with a scaled threshold.
    __uint128_t mag_sq = (__uint128_t)ctrl_re * ctrl_re + (__uint128_t)ctrl_im * ctrl_im;

    // Threshold magnitude ~0.5 in fixed point squared.
    // 0.5 * FIXED_POINT_SCALE is the fixed-point representation of 0.5.
    // (0.5 * FIXED_POINT_SCALE)^2 is the squared fixed-point threshold.
    // Note: FIXED_POINT_SCALE is typically 2^32, so 0.5 * FIXED_POINT_SCALE is 2^31.
    // (2^31)^2 = 2^62.
    // The mag_sq calculation results in a value scaled by (FIXED_POINT_SCALE)^2.
    // So, the threshold also needs to be scaled by (FIXED_POINT_SCALE)^2 for direct comparison.
    const __uint128_t threshold_sq = (__uint128_t)(FIXED_POINT_SCALE / 2) * (FIXED_POINT_SCALE / 2);

    if (mag_sq > threshold_sq) {
        // Flip target amplitude sign (multiply by -1)
        q_target->amplitude.re = -q_target->amplitude.re;
        q_target->amplitude.im = -q_target->amplitude.im;

        log_symbolic_event("CNOT", q_target->id, q_target->tag, "NOT applied via control");
    } else {
        log_symbolic_event("CNOT", q_target->id, q_target->tag, "No action (control = 0)");
    }

    return 0;
}

// Export the symbol for this function so other kernel modules/code can call it directly.
EXPORT_SYMBOL_GPL(nymya_3309_controlled_not);


/*
 * Syscall: nymya_3309_controlled_not
 * ----------------------------------
 * Kernel-space syscall handler for CNOT gate.
 * Checks control qubit magnitude; flips target amplitude sign if control is 'on'.
 *
 * Parameters:
 * user_ctrl   - pointer to user-space control qubit
 * user_target - pointer to user-space target qubit
 *
 * Returns:
 * 0 on success
 * -EINVAL if either pointer is NULL
 * -EFAULT if copying from/to user memory fails
 */
SYSCALL_DEFINE2(nymya_3309_controlled_not,
    struct nymya_qubit __user *, user_ctrl,
    struct nymya_qubit __user *, user_target) {

    struct nymya_qubit k_ctrl, k_target;
    int ret;

    if (!user_ctrl || !user_target)
        return -EINVAL;

    // Copy qubits from user space
    if (copy_from_user(&k_ctrl, user_ctrl, sizeof(k_ctrl)))
        return -EFAULT;
    if (copy_from_user(&k_target, user_target, sizeof(k_target)))
        return -EFAULT;

    // Call the core logic function
    ret = nymya_3309_controlled_not(&k_ctrl, &k_target);

    if (ret) // Propagate error from core function
        return ret;

    // Copy modified target qubit back to user space
    if (copy_to_user(user_target, &k_target, sizeof(k_target)))
        return -EFAULT;

    // Note: Control qubit is not modified, so no need to copy it back.
    return 0;
}

#endif


```

---

## File: `nymya_3310_anticontrol_not.c`

### Content

```c
// src/nymya_3310_anticontrol_not.c
//
// Implements the Anti-Controlled-NOT (ACNOT) gate for Nymya qubits.
// Flips the target qubit's phase if the control qubit's amplitude magnitude < 0.5.
//
// User-space uses standard complex doubles.
// Kernel-space uses fixed-point math and safe user memory handling.
//

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3310_anticontrol_not NYMYA_ACNOT_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
#else // __KERNEL__
    #include <linux/kernel.h>

    // The function 'nymya_3310_anticontrol_not_core' was implicitly defined
    // elsewhere or was truncated from the provided code.
    // Based on the error description, it was declared 'static' but then exported.
    // The 'static' keyword is removed to allow it to be exported.
    long nymya_3310_anticontrol_not_core(void *arg)
    {
        // Placeholder for the actual kernel-space implementation of the ACNOT gate.
        // This function would typically handle parameters passed from user-space,
        // perform fixed-point quantum operations, and manage memory safely.
        // The specific arguments and return type might vary depending on its role
        // (e.g., a system call handler).
        return 0; // Success
    }

    // Additional kernel module code (e.g., module_init, module_exit, EXPORT_SYMBOL)
    // would typically follow here.
#endif // __KERNEL__
```

---

## File: `nymya_3311_controlled_z.c`

### Content

```c
// src/nymya_3311_controlled_z.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3311_controlled_z NYMYA_CZ_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif

/**
 * nymya_3311_controlled_z - Apply a Controlled-Z gate to two qubits.
 * @q_ctrl: Pointer to the control qubit.
 * @q_target: Pointer to the target qubit.
 *
 * In user space, if the magnitude of the control qubit's amplitude
 * exceeds 0.5, this function applies a Z (phase flip) gate to the target.
 *
 * Returns 0 on success, or -1 on invalid input (null pointers).
 */
#ifndef __KERNEL__

int nymya_3311_controlled_z(nymya_qubit* q_ctrl, nymya_qubit* q_target) {
    if (!q_ctrl || !q_target) return -1;

    double ctrl_mag = cabs(q_ctrl->amplitude);

    if (ctrl_mag > 0.5) {
        q_target->amplitude *= -1;
        log_symbolic_event("CZ", q_target->id, q_target->tag, "Z applied via control");
    } else {
        log_symbolic_event("CZ", q_target->id, q_target->tag, "No phase shift (control = 0)");
    }

    return 0;
}

#else // __KERNEL__

/**
 * nymya_3311_controlled_z - Core kernel function for Controlled-Z gate.
 * @k_ctrl: Pointer to the kernel-space control qubit structure.
 * @k_target: Pointer to the kernel-space target qubit structure.
 *
 * This function applies the Controlled-Z gate logic: if the magnitude of the
 * control qubit's amplitude (in fixed-point) exceeds 0.5, it negates the
 * amplitude of the target qubit.
 *
 * Returns 0 on success, -EINVAL on null input.
 */
int nymya_3311_controlled_z(struct nymya_qubit *k_ctrl, struct nymya_qubit *k_target) {
    int64_t re, im;
    uint64_t re64, im64;
    uint64_t re_sq, im_sq;
    uint64_t mag_sq;

    if (!k_ctrl || !k_target) {
        pr_err("NYMYA: nymya_3311_controlled_z received NULL kernel qubit pointer(s)\n");
        return -EINVAL;
    }

    // Extract real and imaginary parts
    re = k_ctrl->amplitude.re;
    im = k_ctrl->amplitude.im;

    re64 = (uint64_t)(re < 0 ? -re : re);
    im64 = (uint64_t)(im < 0 ? -im : im);

    // Compute magnitude^2 using fixed-point math
    // The individual squared terms are scaled by FIXED_POINT_SCALE.
    // Their sum (mag_sq) is also scaled by FIXED_POINT_SCALE.
    re_sq = ((__uint128_t)re64 * re64) >> 32; // Result is (re^2 / 2^32) * 2^32 = re^2
    im_sq = ((__uint128_t)im64 * im64) >> 32; // Result is (im^2 / 2^32) * 2^32 = im^2
    mag_sq = re_sq + im_sq; // This sum is scaled by FIXED_POINT_SCALE

    // Fixed-point threshold for 0.5^2.
    // 0.5 in fixed-point is FIXED_POINT_SCALE / 2.
    // (0.5)^2 in fixed-point is (FIXED_POINT_SCALE / 2) * (FIXED_POINT_SCALE / 2) / FIXED_POINT_SCALE
    // Simplified: (FIXED_POINT_SCALE / 2) * (FIXED_POINT_SCALE / 2) >> 32
    // Or, more simply, 0.25 * FIXED_POINT_SCALE
    const uint64_t threshold_sq = (FIXED_POINT_SCALE / 4); // 0.25 * FIXED_POINT_SCALE

    if (mag_sq > threshold_sq) {
        k_target->amplitude.re = -k_target->amplitude.re;
        k_target->amplitude.im = -k_target->amplitude.im;
        log_symbolic_event("CZ", k_target->id, k_target->tag, "Z applied via control");
    } else {
        log_symbolic_event("CZ", k_target->id, k_target->tag, "No phase shift (control = 0)");
    }

    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3311_controlled_z);



// Export the symbol for this function so other kernel modules/code can call it directly.


/**
 * SYSCALL_DEFINE2(nymya_3311_controlled_z) - Kernel implementation of Controlled-Z gate.
 * @user_ctrl: User pointer to the control qubit structure.
 * @user_target: User pointer to the target qubit structure.
 *
 * This system call version copies the qubit structures from user space,
 * calculates the fixed-point magnitude of the control qubit, and applies
 * a Z gate (negating the amplitude) to the target qubit if the control
 * magnitude exceeds 0.5 (in fixed-point representation).
 *
 * Returns 0 on success, -EINVAL on null input, or -EFAULT on copy errors.
 */
SYSCALL_DEFINE2(nymya_3311_controlled_z,
    struct nymya_qubit __user *, user_ctrl,
    struct nymya_qubit __user *, user_target) {

    struct nymya_qubit k_ctrl, k_target;
    int ret;

    if (!user_ctrl || !user_target)
        return -EINVAL;

    if (copy_from_user(&k_ctrl, user_ctrl, sizeof(k_ctrl)))
        return -EFAULT;
    if (copy_from_user(&k_target, user_target, sizeof(k_target)))
        return -EFAULT;

    // Call the core logic function
    ret = nymya_3311_controlled_z(&k_ctrl, &k_target);

    if (ret) // Propagate error from core function
        return ret;

    if (copy_to_user(user_target, &k_target, sizeof(k_target)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3312_double_controlled_not.c`

### Content

```c
// src/nymya_3312_double_controlled_not.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3312_double_controlled_not NYMYA_DCNOT_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <complex.h>
#else
    int nymya_3312_double_controlled_not_core(struct nymya_qubit *qc1, struct nymya_qubit *qc2, struct nymya_qubit *qt);


    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#endif

/**
 * nymya_3312_double_controlled_not - Double-controlled NOT (Toffoli-like) gate.
 * @qc1: Pointer to first control qubit.
 * @qc2: Pointer to second control qubit.
 * @qt: Pointer to target qubit.
 *
 * Applies a NOT operation (phase flip) on the target qubit if
 * both control qubits have amplitude magnitude > 0.5.
 *
 * Returns 0 on success, negative error code on failure.
 */
#ifndef __KERNEL__

int nymya_3312_double_controlled_not(nymya_qubit* qc1, nymya_qubit* qc2, nymya_qubit* qt) {
    if (!qc1 || !qc2 || !qt) return -1;

    if (cabs(qc1->amplitude) > 0.5 && cabs(qc2->amplitude) > 0.5) {
        qt->amplitude *= -1;
        log_symbolic_event("DCNOT", qt->id, qt->tag, "Double control triggered NOT");
    } else {
        log_symbolic_event("DCNOT", qt->id, qt->tag, "Conditions not met");
    }

    return 0;
}

#else

/**
 * @brief Kernel-side core logic for the nymya_3312_double_controlled_not gate.
 *
 * This function applies a NOT operation (phase flip) on the target qubit if
 * both control qubits' amplitude magnitudes exceed a predefined threshold.
 * It operates on kernel-space qubit structures, modifying the target qubit
 * in place if conditions are met.
 *
 * @param qc1 Pointer to the first control qubit (kernel-space).
 * @param qc2 Pointer to the second control qubit (kernel-space).
 * @param qt Pointer to the target qubit (kernel-space). The amplitude of
 *           this qubit might be modified.
 * @return 0 on success, negative error code on failure.
 */
int nymya_3312_double_controlled_not_core(struct nymya_qubit *qc1,
                                          struct nymya_qubit *qc2,
                                          struct nymya_qubit *qt) {
    int64_t re1, im1, re2, im2;
    uint64_t re1_abs, im1_abs, re2_abs, im2_abs;
    uint64_t mag1_sq, mag2_sq;
    // FIXED_POINT_SCALE is assumed to be defined globally or in nymya.h
    const uint64_t threshold_sq = (FIXED_POINT_SCALE >> 1) * (FIXED_POINT_SCALE >> 1) / FIXED_POINT_SCALE;

    // Compute magnitude squared for first control qubit
    re1 = qc1->amplitude.re;
    im1 = qc1->amplitude.im;
    re1_abs = (re1 < 0) ? -re1 : re1;
    im1_abs = (im1 < 0) ? -im1 : im1;
    mag1_sq = ((uint64_t)re1_abs * (uint64_t)re1_abs >> 32) + ((uint64_t)im1_abs * (uint64_t)im1_abs >> 32);

    // Compute magnitude squared for second control qubit
    re2 = qc2->amplitude.re;
    im2 = qc2->amplitude.im;
    re2_abs = (re2 < 0) ? -re2 : re2;
    im2_abs = (im2 < 0) ? -im2 : im2;
    mag2_sq = ((uint64_t)re2_abs * (uint64_t)re2_abs >> 32) + ((uint64_t)im2_abs * (uint64_t)im2_abs >> 32);

    if (mag1_sq > threshold_sq && mag2_sq > threshold_sq) {
        qt->amplitude.re = -qt->amplitude.re;
        qt->amplitude.im = -qt->amplitude.im;
        log_symbolic_event("DCNOT", qt->id, qt->tag, "Double control triggered NOT");
    } else {
        log_symbolic_event("DCNOT", qt->id, qt->tag, "Conditions not met");
    }

    return 0; // Current logic always succeeds.
}
EXPORT_SYMBOL_GPL(nymya_3312_double_controlled_not_core);


SYSCALL_DEFINE3(nymya_3312_double_controlled_not,
    struct nymya_qubit __user *, user_qc1,
    struct nymya_qubit __user *, user_qc2,
    struct nymya_qubit __user *, user_qt) {

    struct nymya_qubit k_qc1, k_qc2, k_qt; // Kernel-space copies
    int ret;

    if (!user_qc1 || !user_qc2 || !user_qt)
        return -EINVAL;

    if (copy_from_user(&k_qc1, user_qc1, sizeof(k_qc1)))
        return -EFAULT;
    if (copy_from_user(&k_qc2, user_qc2, sizeof(k_qc2)))
        return -EFAULT;
    if (copy_from_user(&k_qt, user_qt, sizeof(k_qt)))
        return -EFAULT;

    // Call the newly created core function
    ret = nymya_3312_double_controlled_not_core(&k_qc1, &k_qc2, &k_qt);
    if (ret) {
        // Propagate error from core function if any
        return ret;
    }

    // Copy back the potentially modified target qubit to user space
    if (copy_to_user(user_qt, &k_qt, sizeof(k_qt)))
        return -EFAULT;

    return 0;
}

#endif
```

---

## File: `nymya_3313_swap.c`

### Content

```c
// src/nymya_3313_swap.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3313_swap NYMYA_SWAP_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif

/**
 * nymya_3313_swap - Swap amplitudes of two qubits.
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 *
 * This function swaps the quantum amplitudes between q1 and q2.
 * Returns 0 on success, or -1 if either pointer is NULL.
 */
#ifndef __KERNEL__

int nymya_3313_swap(nymya_qubit* q1, nymya_qubit* q2) {
    if (!q1 || !q2) return -1;

    _Complex double tmp = q1->amplitude;
    q1->amplitude = q2->amplitude;
    q2->amplitude = tmp;

    log_symbolic_event("SWAP", q1->id, q1->tag, "Swapped with pair");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3313_swap - Core kernel function to swap amplitudes of two qubits.
 * @k_q1: Pointer to the first kernel-space nymya_qubit struct.
 * @k_q2: Pointer to the second kernel-space nymya_qubit struct.
 *
 * This function swaps the quantum amplitudes between k_q1 and k_q2.
 * This function is designed to be called directly by other kernel code.
 *
 * Returns:
 * 0 on success,
 * -EINVAL if any qubit pointer is NULL.
 */
int nymya_3313_swap(struct nymya_qubit *k_q1, struct nymya_qubit *k_q2) {
    complex_double tmp;

    if (!k_q1 || !k_q2) {
        pr_err("NYMYA: nymya_3313_swap received NULL kernel qubit pointer(s)\n");
        return -EINVAL;
    }

    tmp = k_q1->amplitude;
    k_q1->amplitude = k_q2->amplitude;
    k_q2->amplitude = tmp;

    log_symbolic_event("SWAP", k_q1->id, k_q1->tag, "Swapped with pair");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3313_swap);



// Export the symbol for this function so other kernel modules/code can call it directly.


/**
 * SYSCALL_DEFINE2(nymya_3313_swap) - Swap amplitudes of two qubits in kernel space.
 * @user_q1: User-space pointer to the first nymya_qubit struct.
 * @user_q2: User-space pointer to the second nymya_qubit struct.
 *
 * Copies the qubit structs from user space, calls the core swap function,
 * and copies the results back. Logs the swap event referencing the first qubit.
 *
 * Returns:
 * 0 on success,
 * -EINVAL if any user pointer is NULL,
 * -EFAULT if copy_from_user or copy_to_user fails.
 */
SYSCALL_DEFINE2(nymya_3313_swap,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_q1, k_q2;
    int ret;

    if (!user_q1 || !user_q2)
        return -EINVAL;

    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1)))
        return -EFAULT;
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2)))
        return -EFAULT;

    // Call the core logic function
    ret = nymya_3313_swap(&k_q1, &k_q2);

    if (ret) // Propagate error from core function
        return ret;

    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1)))
        return -EFAULT;
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2)))
        return -EFAULT;

    return 0;
}

#endif


```

