# Documented C Files from nymya-core Project

This document was automatically generated by a script to capture the content of .c files.

---

## File: `complex_conj.c`

### Content

```c
// src/complex_conj.c

#include "nymya.h"

/**
 * complex_conj - Returns the complex conjugate of a complex_double.
 *
 * In kernel mode, complex_double is a struct with fixed-point fields.
 * In user mode, complex_double is _Complex double from <complex.h>.
 *
 * @c: Input complex_double value.
 *
 * Returns:
 * The complex conjugate of the input.
 */
complex_double complex_conj(complex_double c) {
#ifdef __KERNEL__
    complex_double result;
    result.re = c.re;
    result.im = -c.im;
    return result;
#else
    return conj(c);
#endif
}


```

---

## File: `complex_exp_i.c`

### Content

```c
// complex_exp_i.c

#include "nymya.h"

#ifdef __KERNEL__
#include <linux/kernel.h>
#include <linux/types.h>

/**
 * complex_exp_i - Computes e^(i*theta) for fixed-point numbers in kernel-space.
 *
 * @theta_fp: The angle in radians, as a Q32.32 fixed-point value.
 * Returns the complex number representing e^(i*theta).
 */
complex_double complex_exp_i(int64_t theta_fp) {
    complex_double result;
    result.re = fixed_cos(theta_fp);
    result.im = fixed_sin(theta_fp);
    return result;
}

// EXPORT_SYMBOL_GPL(complex_exp_i);

#else // Userland implementation

#include <complex.h>
#include <math.h>
#include <stdio.h>

/**
 * complex_exp_i - Computes e^(i*theta) for native double-precision complex numbers in userland.
 *
 * @theta: The angle in radians, as a double-precision floating-point value.
 * Returns the complex number representing e^(i*theta).
 */
complex_double complex_exp_i(double theta) {
    return cos(theta) + I * sin(theta);
}

#endif
```

---

## File: `complex_im.c`

### Content

```c
// complex_im.c

#include "nymya.h"

/**
 * complex_im - Returns the imaginary component of a complex_double.
 *
 * In kernel mode: returns fixed-point int64_t.
 * In userspace: returns floating-point double.
 *
 * @c: The complex number input.
 *
 * Returns:
 * Imaginary component of the input complex number.
 */
#ifdef __KERNEL__
int64_t complex_im(complex_double c) {
    return c.im;
}
#else
double complex_im(complex_double c) {
    return cimag(c);
}
#endif


```

---

## File: `complex_mul.c`

### Content

```c
// src/complex_mul.c

#include "nymya.h"

#ifdef __KERNEL__

/**
 * complex_mul - Multiply two fixed-point complex numbers.
 * @a: First operand, Q32.32 fixed-point complex_double struct.
 * @b: Second operand, Q32.32 fixed-point complex_double struct.
 *
 * Uses 128-bit intermediates to compute:
 *   (a.re + i·a.im) * (b.re + i·b.im) =
 *   (a.re*b.re - a.im*b.im) + i*(a.re*b.im + a.im*b.re)
 * Then shifts each product right by 32 bits to maintain Q32.32 format.
 *
 * Returns:
 *   The product as a complex_double in Q32.32 fixed-point.
 */
complex_double complex_mul(complex_double a, complex_double b) {
    __int128 re_part = (__int128)a.re * b.re - (__int128)a.im * b.im;
    __int128 im_part = (__int128)a.re * b.im + (__int128)a.im * b.re;

    complex_double result;
    result.re = (int64_t)(re_part >> 32);
    result.im = (int64_t)(im_part >> 32);
    return result;
}

#else

#include <complex.h>

/**
 * complex_mul - Multiply two native complex_double numbers in userland.
 * @a: First operand, native _Complex double.
 * @b: Second operand, native _Complex double.
 *
 * Returns:
 *   The product (a * b) as native complex_double.
 */
complex_double complex_mul(complex_double a, complex_double b) {
    return a * b;
}

#endif


```

---

## File: `complex_re.c`

### Content

```c
// src/complex_re.c

#include "nymya.h"

#ifdef __KERNEL__

/**
 * complex_re - Extract the real part of a fixed-point complex number.
 * @c: complex_double in Q32.32 fixed-point format.
 *
 * Returns:
 *   The real component as an int64_t in Q32.32.
 */
int64_t complex_re(complex_double c) {
    return c.re;
}

#else

#include <complex.h>

/**
 * complex_re - Extract the real part of a native complex double number.
 * @c: complex_double (native _Complex double).
 *
 * Returns:
 *   The real component as a double.
 */
double complex_re(complex_double c) {
    return creal(c);
}

#endif


```

---

## File: `fixed_complex_multiply.c`

### Content

```c
#include "nymya.h" // Include the header file for definitions like complex_double and FIXED_POINT_SCALE

// This file contains the kernel-specific implementation of fixed-point complex multiplication.
// It must be compiled with the __KERNEL__ macro defined to correctly use complex_double.

#ifdef __KERNEL__

/**
 * fixed_complex_multiply - Multiplies two fixed-point complex numbers.
 * @re1: Real part of the first complex number in Q32.32 fixed-point.
 * @im1: Imaginary part of the first complex number in Q32.32 fixed-point.
 * @re2: Real part of the second complex number in Q32.32 fixed-point.
 * @im2: Imaginary part of the second complex number in Q32.32 fixed-point.
 *
 * Multiplies two complex numbers (re1 + im1 * i) and (re2 + im2 * i)
 * using the fixed-point Q32.32 format. The result is also in Q32.32 format.
 *
 * Formula:
 * (re1 + im1 * i) * (re2 + im2 * i) = (re1 * re2 - im1 * im2) + (re1 * im2 + im1 * re2) * i
 *
 * Uses 128-bit intermediate types (`__int128`) to prevent overflow during intermediate
 * multiplications before shifting back to the 64-bit fixed-point format.
 *
 * This function is declared globally in `nymya.h` and is intended to be
 * visible across compilation units. Other files should typically use `complex_mul`
 * from `nymya.h` which operates on `complex_double` structs.
 *
 * Returns:
 * A `complex_double` struct containing both the real and imaginary parts of the product.
 */
complex_double fixed_complex_multiply(int64_t re1, int64_t im1, int64_t re2, int64_t im2)
{
    // Calculate the real part of the product: (re1 * re2) - (im1 * im2)
    // Use __int128 for intermediate calculations to prevent overflow.
    __int128 re_part = (__int128)re1 * re2 - (__int128)im1 * im2;

    // Calculate the imaginary part of the product: (re1 * im2) + (im1 * re2)
    // Use __int128 for intermediate calculations to prevent overflow.
    __int128 im_part = (__int128)re1 * im2 + (__int128)im1 * re2;

    complex_double result; // Declare result as complex_double

    // Shift right by 32 bits (equivalent to dividing by FIXED_POINT_SCALE)
    // to bring the result back to the Q32.32 fixed-point format.
    result.re = (int64_t)(re_part >> 32);
    result.im = (int64_t)(im_part >> 32);

    return result; // Return the complex_double struct containing both parts
}

#endif // __KERNEL__
```

---

## File: `fixed_conj.c`

### Content

```c
// src/fixed_conj.c

#include "nymya.h"

/**
 * fixed_conj - Returns the conjugate of a fixed-point complex number as a packed int64_t.
 * 
 * The conjugate of a complex number is obtained by negating the imaginary part.
 * 
 * @re: The real part of the fixed-point complex number (int64_t).
 * @im: The imaginary part of the fixed-point complex number (int64_t).
 * 
 * Returns:
 * - A packed int64_t, where the higher 32 bits are the real part and 
 *   the lower 32 bits are the negated imaginary part.
 */
int64_t fixed_conj(int64_t re, int64_t im) {
    // Negate the imaginary part for the conjugate
    int64_t conj_im = -im;

    // Pack real and imaginary parts into a single int64_t (higher 32 bits = real, lower 32 bits = imaginary)
    int64_t conj = (re << 32) | (conj_im & 0xFFFFFFFF); // Mask to ensure it fits into 32 bits

    return conj;
}


```

---

## File: `fixed_cos.c`

### Content

```c
#include "nymya.h"

/**
 * fixed_cos - Fixed-point cosine approximation.
 * @theta: angle in Q32.32 fixed-point format (radians).
 *
 * Uses a 6th-order Taylor series:
 *   cos(x) ≈ 1 − x^2/2 + x^4/24 − x^6/720
 *
 * All intermediate results are in Q32.32, using 128‑bit to avoid overflow.
 *
 * Return: cosine(theta) in Q32.32 fixed-point.
 */
int64_t fixed_cos(int64_t theta)
{
    // alias scale
    const int64_t ONE = FIXED_POINT_SCALE;

    // x
    __int128 x = theta;

    // x^2
    __int128 x2 = (x * x) >> 32;
    // x^4 = (x2 * x2) >>32
    __int128 x4 = (x2 * x2) >> 32;
    // x^6 = (x4 * x2) >>32
    __int128 x6 = (x4 * x2) >> 32;

    // Compute terms in Q32.32:
    __int128 term0 = ONE;                       // 1
    __int128 term1 = x2 / 2;                    // x^2/2
    __int128 term2 = x4 / 24;                   // x^4/24
    __int128 term3 = x6 / 720;                  // x^6/720

    // cos ≈ term0 − term1 + term2 − term3
    __int128 result = term0 - term1 + term2 - term3;

    return (int64_t)result;
}

```

---

## File: `fixed_point_cos.c`

### Content

```c
// src/fixed_point_cos.c

#include "nymya.h"
#include "nymya.h"
int64_t fixed_point_mul(int64_t a, int64_t b);

/**
 * fixed_point_cos - Calculate the cosine of a fixed-point angle.
 * @angle_fp: The angle in Q32.32 fixed-point format.
 *
 * Normalizes the angle to the range [-PI, PI] and uses a Taylor series
 * expansion to approximate cosine: cos(x) ≈ 1 − x²/2.
 *
 * Returns:
 *   The cosine of angle_fp as a Q32.32 fixed-point int64_t.
 */
int64_t fixed_point_cos(int64_t angle_fp) {
    // Normalize to [-PI, PI]
    while (angle_fp > FIXED_POINT_PI)
        angle_fp -= (FIXED_POINT_PI << 1);
    while (angle_fp < -FIXED_POINT_PI)
        angle_fp += (FIXED_POINT_PI << 1);

    // Taylor series: cos(x) ≈ 1 − x²/2
    int64_t one = FIXED_POINT_SCALE;
    int64_t x2 = fixed_point_mul(angle_fp, angle_fp);
    int64_t half = (int64_t)(0.5 * FIXED_POINT_SCALE);
    int64_t term2 = fixed_point_mul(x2, half);
    return one - term2;
}

```

---

## File: `fixed_point_sin.c`

### Content

```c
// src/fixed_point_sin.c

#include "nymya.h"
#include "nymya.h"
int64_t fixed_point_mul(int64_t a, int64_t b);

/**
 * fixed_point_sin - Calculate the sine of a fixed-point angle.
 * @angle_fp: The angle in Q32.32 fixed-point format.
 *
 * Normalizes the angle to the range [-PI, PI] and uses a Taylor series
 * expansion to approximate sine: sin(x) ≈ x − x³/6.
 *
 * Returns:
 *   The sine of angle_fp as a Q32.32 fixed-point int64_t.
 */
int64_t fixed_point_sin(int64_t angle_fp) {
    // Normalize to [-PI, PI]
    while (angle_fp > FIXED_POINT_PI)
        angle_fp -= (FIXED_POINT_PI << 1);
    while (angle_fp < -FIXED_POINT_PI)
        angle_fp += (FIXED_POINT_PI << 1);

    // Taylor series: sin(x) ≈ x − x³/6
    int64_t x = angle_fp;
    int64_t x2 = fixed_point_mul(x, x);
    int64_t x3 = fixed_point_mul(x2, x);
    int64_t sixth = (int64_t)((1.0/6.0) * FIXED_POINT_SCALE);
    int64_t term2 = fixed_point_mul(x3, sixth);
    return x - term2;
}

```

---

## File: `fixed_sin.c`

### Content

```c
#include "nymya.h"

/**
 * fixed_sin - Fixed-point sine approximation.
 * @theta: angle in Q32.32 fixed-point format (radians).
 *
 * Approximates sin(theta) using a 7th-order Taylor series expansion around 0:
 *    sin(x) ≈ x − x³/6 + x⁵/120 − x⁷/5040
 *
 * Uses 128-bit intermediate arithmetic to avoid overflow and maintain precision.
 *
 * Note: Best accuracy near zero; inputs outside ±π/2 should be wrapped appropriately.
 *
 * Return:
 *   sine(theta) in Q32.32 fixed-point format.
 */
int64_t fixed_sin(const int64_t theta)
{
    __int128 x = theta;
    __int128 x2 = (x * x) >> 32;       // x² in Q32.32
    __int128 x3 = (x2 * x) >> 32;      // x³
    __int128 x5 = (x3 * x2) >> 32;     // x⁵
    __int128 x7 = (x5 * x2) >> 32;     // x⁷

    __int128 term1 = x;                // x
    __int128 term2 = x3 / 6;           // x³/6
    __int128 term3 = x5 / 120;         // x⁵/120
    __int128 term4 = x7 / 5040;        // x⁷/5040

    __int128 result = term1 - term2 + term3 - term4;

    return (int64_t)result;
}


```

---

## File: `log.c`

### Content

```c
// src/log.c
//
// Defines the log_symbolic_event function for both kernel and userland.
// In the kernel, it uses pr_info for logging. In userland, it uses printf.

#include "nymya.h" // Assumed to define common types like uint64_t and nymya_qubit

#ifdef __KERNEL__
    #include <linux/kernel.h> // For pr_info
    #include <linux/module.h> // For EXPORT_SYMBOL_GPL
    #include <linux/types.h>  // For uint64_t if not already in nymya.h

    /**
     * log_symbolic_event - Kernel-side implementation for logging symbolic events.
     * @gate: The name of the gate or event.
     * @id: The ID of the primary qubit involved.
     * @tag: An optional tag for the qubit.
     * @msg: A descriptive message for the event.
     *
     * This function provides a basic logging mechanism for quantum gate operations
     * or other symbolic events within the kernel. It uses pr_info to output
     * a message to the kernel log.
     *
     * Returns: 0 on success.
     */
    int log_symbolic_event(const char* gate, uint64_t id, const char* tag, const char* msg) {
        // For kernel logging (pr_info), %llu is generally correct for uint64_t
        pr_info("NYMYA_KERNEL_EVENT: [%s] Qubit ID %llu (%s): %s\n",
                gate, id, tag ? tag : "untagged", msg);
        return 0;
    }
    // Export the symbol so other kernel modules can use this logging function.
    EXPORT_SYMBOL_GPL(log_symbolic_event);

#else // Userland implementation

    #include <stdio.h>    // For printf
    #include <stdint.h>   // For uint64_t
    #include <inttypes.h> // For PRIu64 macro

    /**
     * log_symbolic_event - Userland implementation for logging symbolic events.
     * @gate: The name of the gate or event.
     * @id: The ID of the primary qubit involved.
     * @tag: An optional tag for the qubit.
     * @msg: A descriptive message for the event.
     *
     * This function provides a basic logging mechanism for quantum gate operations
     * or other symbolic events in userland. It uses printf to output a message
     * to standard output.
     *
     * Returns: 0 on success.
     */
    int log_symbolic_event(const char* gate, uint64_t id, const char* tag, const char* msg) {
        // Using PRIu64 for platform-independent printing of uint64_t
        printf("NYMYA_USERLAND_EVENT: [%s] Qubit ID %" PRIu64 " (%s): %s\n",
               gate, id, tag ? tag : "untagged", msg);
        return 0;
    }

#endif // __KERNEL__


```

---

## File: `nymya_3301_identity_gate.c`

### Content

```c
// src/nymya_3301_identity_gate.c

#include "nymya.h"

#ifdef __KERNEL__

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/types.h>

/*
 * Syscall: nymya_3301_identity_gate
 * Purpose: Apply the quantum identity gate (I) to a qubit.
 * Parameters:
 *     @user_q: Pointer to user-space `nymya_qubit` structure.
 * Behavior:
 *     - Reads the qubit structure from user space.
 *     - Logs a symbolic event to indicate no-op (identity) transformation.
 * Notes:
 *     - This is a symbolic operation only; does not alter amplitude.
 *     - Useful for preserving causality or marking a moment in symbolic space.
 * Return:
 *     0 on success, -EINVAL if null, -EFAULT if copy fails.
 */
SYSCALL_DEFINE1(nymya_3301_identity_gate, struct nymya_qubit __user *, user_q)
{
    struct nymya_qubit kq;

    if (!user_q)
        return -EINVAL;

    if (copy_from_user(&kq, user_q, sizeof(struct nymya_qubit)))
        return -EFAULT;

    log_symbolic_event("ID_GATE", kq.id, kq.tag, "State preserved");
    return 0;
}

// Only needed if other kernel modules will call this function directly.
// Uncomment this if a non-syscall kernel symbol is defined elsewhere.
// EXPORT_SYMBOL_GPL(nymya_3301_identity_gate);

#else

#include <stdio.h>
#include <stdlib.h>

/*
 * Userspace Fallback: nymya_3301_identity_gate
 * Purpose: Log identity gate operation on symbolic qubit.
 * Parameters:
 *     @q: Pointer to symbolic qubit.
 * Behavior:
 *     - Logs the event with tag and ID.
 *     - Used for userland simulation/testing environments.
 * Return:
 *     0 on success, -1 if input is null.
 */
int nymya_3301_identity_gate(nymya_qubit* q)
{
    if (!q)
        return -1;

    log_symbolic_event("ID_GATE", q->id, q->tag, "State preserved");
    return 0;
}

#endif


```

---

## File: `nymya_3302_global_phase.c`

### Content

```c
#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3302_global_phase NYMYA_GLOBAL_PHASE_CODE

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <complex.h>

// Safely override complex math macros only in userland simulation
#ifdef nymya_cexp
#undef nymya_cexp
#endif
#define nymya_cexp(theta) cexp(I * (theta))

#ifdef nymya_cmul
#undef nymya_cmul
#endif
#define nymya_cmul(a, b) ((a) * (b))

#else
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/errno.h>
#include <linux/module.h>  // Required for EXPORT_SYMBOL_GPL
#include <linux/string.h>  // For snprintf
#endif

/**
 * nymya_3302_global_phase - Apply global phase shift to a symbolic qubit
 * @q: Pointer to a symbolic qubit
 * @theta: Phase angle in radians (double for userland).
 *
 * Multiplies the qubit’s amplitude by e^(iθ), applying a global phase.
 * No probability amplitudes are altered, only the phase.
 * Logs symbolic event with phase shift details.
 *
 * Returns 0 on success, or -1 if the input is invalid.
 */
#ifndef __KERNEL__

int nymya_3302_global_phase(nymya_qubit* q, double theta) {
    if (!q) return -1;

    complex_double phase = nymya_cexp(theta);
    q->amplitude = nymya_cmul(q->amplitude, phase);

    char log_msg[128];
    snprintf(log_msg, sizeof(log_msg), "Applied phase shift θ=%.3f rad", theta);
    log_symbolic_event("GPHASE", q->id, q->tag, log_msg);

    return 0;
}

#else // __KERNEL__

/**
 * nymya_3302_global_phase - Core kernel function to apply global phase shift.
 * @q: Pointer to the kernel-space qubit structure.
 * @theta_fixed: Phase angle in fixed-point (int64_t) format.
 *
 * Multiplies the qubit's amplitude by e^(i*theta_fixed), applying a global phase.
 * This function is designed to be called directly by other kernel code.
 *
 * Returns 0 on success, -EINVAL if the qubit pointer is NULL.
 */
int nymya_3302_global_phase(struct nymya_qubit *q, int64_t theta_fixed) {
    complex_double phase_factor;

    if (!q) {
        pr_err("NYMYA: nymya_3302_global_phase received NULL qubit pointer\n");
        return -EINVAL;
    }

    phase_factor.re = fixed_cos(theta_fixed);
    phase_factor.im = fixed_sin(theta_fixed);

    q->amplitude = complex_mul(q->amplitude, phase_factor);

    return 0;
}

EXPORT_SYMBOL_GPL(nymya_3302_global_phase);

/**
 * SYSCALL_DEFINE2(nymya_3302_global_phase) - Kernel system call for global phase shift.
 * @user_q: User-space pointer to the qubit struct.
 * @theta_fixed: Phase angle already converted to fixed-point (int64_t) from user space.
 *
 * This syscall handles copying the qubit from user space, calls the core global phase
 * function, and copies the modified qubit back to user space. The phase angle
 * is expected to be provided as a fixed-point integer directly by userland.
 *
 * Returns 0 on success, -EINVAL on invalid pointers, -EFAULT on copy errors.
 */
SYSCALL_DEFINE2(nymya_3302_global_phase,
    struct nymya_qubit __user *, user_q,
    int64_t, theta_fixed)
{
    struct nymya_qubit kq;
    int ret;
    char log_msg[128];

    if (!user_q)
        return -EINVAL;

    if (copy_from_user(&kq, user_q, sizeof(kq)))
        return -EFAULT;

    ret = nymya_3302_global_phase(&kq, theta_fixed);
    if (ret)
        return ret;

    snprintf(log_msg, sizeof(log_msg), "Applied phase shift (fixed-point)=%lld", (long long)theta_fixed);
    log_symbolic_event("GPHASE", kq.id, kq.tag, log_msg);

    if (copy_to_user(user_q, &kq, sizeof(kq)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3303_pauli_x.c`

### Content

```c
#include "nymya.h"

#ifdef __KERNEL__
    #include <linux/module.h>
    #include <linux/kernel.h>
    #include <linux/syscalls.h> // Keep for compatibility, though not directly using SYSCALL_DEFINE for this function
    #include <linux/uaccess.h>
    #include <linux/errno.h> // For -EINVAL, -EFAULT

/*
 * Flip imaginary part sign in fixed-point amplitude
 */
static inline void flip_imag_part(struct nymya_qubit *q) {
    q->amplitude.im = -q->amplitude.im;
}

// The function is now defined as a regular kernel function named nymya_3303_pauli_x,
// to match the requested EXPORT_SYMBOL_GPL name.
// It uses 'int' as a return type, consistent with typical kernel function return values for success/error.
// The parameter type has been changed from '__user *user_q' to '*q'
// to match the expected declaration and
// the logic for copying from/to user space has been removed, as this function
// is now expected to operate on a kernel-space pointer.
int nymya_3303_pauli_x(struct nymya_qubit *q) {
    if (!q)
        return -EINVAL;

    flip_imag_part(q);

    // Assuming log_symbolic_event is properly defined and accessible in the kernel context
    log_symbolic_event("PAULI_X", q->id, q->tag, "Polarity flipped");

    return 0;
}

// Export the symbol for use by other kernel modules/code.
// Changed to export 'nymya_3303_pauli_x' as requested.
EXPORT_SYMBOL_GPL(nymya_3303_pauli_x);

#else // Userland implementation

#include <stdio.h>
#include <complex.h> // Ensure this is included for _Complex and I

/*
 * Flip imaginary part sign in builtin complex amplitude
 */
static inline void flip_imag_part(nymya_qubit *q) {
    // Assuming nymya_qubit's amplitude is _Complex double in userland
    // For direct manipulation, if q->amplitude is _Complex double:
    q->amplitude = creal(q->amplitude) - I * cimag(q->amplitude);
}

/*
 * Userland implementation of the Pauli-X gate
 * @q: pointer to symbolic qubit
 *
 * Flips the sign of the imaginary part of the amplitude.
 * Logs the symbolic event with qubit ID and tag.
 *
 * Returns 0 on success, -1 if input is null.
 */
int nymya_3303_pauli_x(nymya_qubit *q) {
    if (!q) return -1;

    flip_imag_part(q);

    log_symbolic_event("PAULI_X", q->id, q->tag, "Polarity flipped");
    return 0;
}

#endif // __KERNEL__
```

---

## File: `nymya_3304_pauli_y.c`

### Content

```c
// src/nymya_3304_pauli_y.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#define __NR_nymya_3304_pauli_y NYMYA_PAULI_Y_CODE

#include <unistd.h>
    #include <stdio.h>
    #include <stdlib.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/*
 * User-space implementation of Pauli-Y gate on a qubit.
 * Multiplies amplitude by the imaginary unit i:
 * (a + bi) * i = -b + ai
 */
int nymya_3304_pauli_y(nymya_qubit* q) {
    if (!q) return -1;

    // Using complex_double as _Complex double in user-space:
    q->amplitude = make_complex(-complex_im(q->amplitude), complex_re(q->amplitude));

    log_symbolic_event("PAULI_Y", q->id, q->tag, "Dream vector rotated");
    return 0;
}

#else

/**
 * @brief Applies the Pauli-Y gate logic to a kernel-space qubit.
 *
 * This function performs the core operation of the Pauli-Y gate,
 * multiplying the qubit's amplitude by the imaginary unit 'i'.
 * In the fixed-point complex representation, this involves swapping
 * the real and imaginary parts and negating the new real part.
 *
 * @param kq A pointer to the kernel-space nymya_qubit structure to operate on.
 * @return 0 on success, or a negative error code if an internal issue occurs.
 */
int nymya_3304_pauli_y(struct nymya_qubit *kq) {
    int64_t re, im;

    // A defensive check, though kq should be valid from the syscall wrapper
    if (!kq) {
        return -EINVAL;
    }

    // Extract fixed-point real and imaginary parts
    re = kq->amplitude.re;
    im = kq->amplitude.im;

    // Multiply amplitude by i: (a + bi)*i = -b + ai
    kq->amplitude.re = -im;
    kq->amplitude.im = re;

    log_symbolic_event("PAULI_Y", kq->id, kq->tag, "Dream vector rotated");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3304_pauli_y);

/*
 * Kernel syscall: nymya_3304_pauli_y
 * Multiplies the qubit amplitude by i.
 * Note: kernel uses fixed-point complex, so manually swap real and imag parts.
 */
SYSCALL_DEFINE1(nymya_3304_pauli_y, struct nymya_qubit __user *, user_q) {
    struct nymya_qubit kq;
    int ret;

    if (!user_q)
        return -EINVAL;
    if (copy_from_user(&kq, user_q, sizeof(kq)))
        return -EFAULT;

    // Call the extracted core logic function
    ret = nymya_3304_pauli_y(&kq);
    if (ret) {
        // Propagate any error from the core logic
        return ret;
    }

    if (copy_to_user(user_q, &kq, sizeof(kq)))
        return -EFAULT;

    return 0;
}

#endif

```

---

## File: `nymya_3305_pauli_z.c`

### Content

```c
// src/nymya_3305_pauli_z.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#define __NR_nymya_3305_pauli_z NYMYA_PAULI_Z_CODE

#include <unistd.h>
    #include <stdio.h>
    #include <stdlib.h>
#else
    int nymya_3305_pauli_z_core(struct nymya_qubit *kq);


    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/*
 * User-space implementation of Pauli-Z gate.
 * Multiplies the qubit amplitude by -1 (negates both real and imag parts).
 */
int nymya_3305_pauli_z(nymya_qubit* q) {
    if (!q) return -1;

    q->amplitude = make_complex(-complex_re(q->amplitude), -complex_im(q->amplitude));

    log_symbolic_event("PAULI_Z", q->id, q->tag, "Inverted inner state");
    return 0;
}

#else

/**
 * @brief Applies the Pauli-Z gate operation to a kernel-space qubit.
 *
 * This function negates the fixed-point real and imaginary parts of the
 * qubit's amplitude, effectively applying a phase shift of pi (Z gate).
 * It also logs a symbolic event for this operation.
 *
 * @param kq Pointer to the kernel-space nymya_qubit structure.
 * @return 0 on success. Currently, no specific error conditions are handled,
 *         but returns an int for future extensibility.
 */
int nymya_3305_pauli_z_core(struct nymya_qubit *kq) {
    int64_t re, im;

    // No need for null check here, as syscall wrapper ensures valid kq pointer
    // if it passed copy_from_user.

    re = kq->amplitude.re;
    im = kq->amplitude.im;

    kq->amplitude.re = -re;
    kq->amplitude.im = -im;

    log_symbolic_event("PAULI_Z", kq->id, kq->tag, "Inverted inner state");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3305_pauli_z_core);

/*
 * Kernel syscall: nymya_3305_pauli_z
 * Negates the fixed-point amplitude of the qubit.
 */
SYSCALL_DEFINE1(nymya_3305_pauli_z, struct nymya_qubit __user *, user_q) {
    struct nymya_qubit kq;
    int ret;

    if (!user_q)
        return -EINVAL;
    if (copy_from_user(&kq, user_q, sizeof(kq)))
        return -EFAULT;

    // Call the core logic function
    ret = nymya_3305_pauli_z_core(&kq);
    if (ret) {
        // Propagate error from the core function if it returns one
        return ret;
    }

    if (copy_to_user(user_q, &kq, sizeof(kq)))
        return -EFAULT;

    return 0;
}

#endif
```

---

## File: `nymya_3306_phase_gate.c`

### Content

```c
// src/nymya_3306_phase_gate.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3306_phase_gate NYMYA_PHASE_S_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL

    /**
     * nymya_3306_phase_gate - Core kernel function for Phase (S) gate logic.
     * @q: Pointer to the nymya_qubit structure.
     *
     * This function applies the Phase (S) gate logic to a qubit's amplitude.
     * It multiplies the amplitude by fixed-point 'i' (equivalent to phase shift π/2).
     * This function is designed to be called directly by other kernel code.
     *
     * Returns: 0 on success.
     */
    int nymya_3306_phase_gate(struct nymya_qubit *q) {
        int64_t re, im;

        if (!q) {
            pr_err("NYMYA: nymya_3306_phase_gate received NULL qubit pointer\n");
            return -EINVAL; // Return an error if qubit is null
        }

        re = q->amplitude.re;
        im = q->amplitude.im;

        // (a + bi) * i = -b + ai
        q->amplitude.re = -im;
        q->amplitude.im = re;

        log_symbolic_event("PHASE_S", q->id, q->tag, "Applied S gate (π/2 phase)");
        return 0;
    }
    // Export the symbol for this function so other kernel modules/code can call it directly.
    EXPORT_SYMBOL_GPL(nymya_3306_phase_gate);

    /*
     * Kernel syscall: nymya_3306_phase_gate
     * This is the syscall entry point that wraps the core nymya_3306_phase_gate function.
     * It handles user-space copy operations before and after calling the core logic.
     */
    SYSCALL_DEFINE1(nymya_3306_phase_gate, struct nymya_qubit __user *, user_q) {
        struct nymya_qubit kq;
        int ret;

        if (!user_q)
            return -EINVAL;

        // Copy qubit data from user space to kernel space
        if (copy_from_user(&kq, user_q, sizeof(kq)))
            return -EFAULT;

        // Call the core logic function defined above
        ret = nymya_3306_phase_gate(&kq);

        if (ret) // If the core function returned an error, propagate it
            return ret;

        // Copy modified qubit data from kernel space back to user space
        if (copy_to_user(user_q, &kq, sizeof(kq)))
            return -EFAULT;

        return 0;
    }

#endif


```

---

## File: `nymya_3307_sqrt_x_gate.c`

### Content

```c
// src/nymya_3307_sqrt_x_gate.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3307_sqrt_x_gate NYMYA_SQRT_X_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL

    /**
     * nymya_3307_sqrt_x_gate - Core kernel function for Square Root X gate logic.
     * @q: Pointer to the nymya_qubit structure.
     *
     * This function applies the Square Root X gate logic to a qubit's amplitude
     * using fixed-point arithmetic. It's equivalent to multiplying by (1/√2)(1 + i).
     * This function is designed to be called directly by other kernel code.
     *
     * Returns: 0 on success.
     */
    int nymya_3307_sqrt_x_gate(struct nymya_qubit *q) {
        int64_t re, im;
        // fixed-point approximation of 1/sqrt(2)
        const int64_t c_re = (int64_t)(0.70710678 * FIXED_POINT_SCALE);
        const int64_t c_im = (int64_t)(0.70710678 * FIXED_POINT_SCALE);

        if (!q) {
            pr_err("NYMYA: nymya_3307_sqrt_x_gate received NULL qubit pointer\n");
            return -EINVAL;
        }

        re = q->amplitude.re;
        im = q->amplitude.im;

        // Fixed-point complex multiplication:
        // new_re = (re*c_re - im*c_im) / FIXED_POINT_SCALE
        // new_im = (re*c_im + im*c_re) / FIXED_POINT_SCALE
        // Using __int128 for intermediate calculation to prevent overflow before shifting
        __int128 temp_re = (__int128)re * c_re - (__int128)im * c_im;
        __int128 temp_im = (__int128)re * c_im + (__int128)im * c_re;

        q->amplitude.re = (int64_t)(temp_re >> 32); // Assuming FIXED_POINT_SCALE is 2^32
        q->amplitude.im = (int64_t)(temp_im >> 32); // Assuming FIXED_POINT_SCALE is 2^32

        log_symbolic_event("SQRT_X", q->id, q->tag, "Applied √X gate (liminal rotation)");
        return 0;
    }
    // Export the symbol for this function so other kernel modules/code can call it directly.
    EXPORT_SYMBOL_GPL(nymya_3307_sqrt_x_gate);


    /*
     * Kernel syscall: nymya_3307_sqrt_x_gate
     * This is the syscall entry point that wraps the core nymya_3307_sqrt_x_gate function.
     * It handles user-space copy operations before and after calling the core logic.
     */
    SYSCALL_DEFINE1(nymya_3307_sqrt_x_gate, struct nymya_qubit __user *, user_q) {
        struct nymya_qubit kq;
        int ret;

        if (!user_q)
            return -EINVAL;
        if (copy_from_user(&kq, user_q, sizeof(kq)))
            return -EFAULT;

        // Call the core logic function defined above
        ret = nymya_3307_sqrt_x_gate(&kq);

        if (ret) // If the core function returned an error, propagate it
            return ret;

        if (copy_to_user(user_q, &kq, sizeof(kq)))
            return -EFAULT;

        return 0;
    }

#endif


```

---

## File: `nymya_3308_hadamard_gate.c`

### Content

```c
// src/nymya_3308_hadamard_gate.c
//
// Implements the Hadamard gate (H gate) for a qubit amplitude.
// The Hadamard gate creates superposition by scaling the amplitude by 1/√2.
//
// In user-space, uses standard complex double arithmetic.
// In kernel-space, uses fixed-point arithmetic consistent with nymya.h definitions.
//

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3308_hadamard_gate NYMYA_HADAMARD_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/*
 * Function: nymya_3308_hadamard_gate
 * ----------------------------------
 * Applies the Hadamard gate to the qubit's amplitude.
 * Scales the amplitude by 1/√2 (approximately 0.70710678).
 *
 * Parameters:
 * q - pointer to nymya_qubit struct in user-space
 *
 * Returns:
 * 0 on success, -1 if q is NULL
 */
int nymya_3308_hadamard_gate(nymya_qubit* q) {
    if (!q) return -1;

    // Scale the complex amplitude by 1/sqrt(2)
    q->amplitude *= (1.0 / sqrt(2.0));

    log_symbolic_event("HADAMARD", q->id, q->tag, "Applied H gate (superposition)");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3308_hadamard_gate - Core kernel function for Hadamard gate.
 * @q: Pointer to the nymya_qubit structure.
 *
 * This function applies the Hadamard gate logic, scaling the qubit's amplitude
 * by a fixed-point approximation of 1/√2.
 * This function is designed to be called directly by other kernel code.
 *
 * Returns:
 * 0 on success.
 * -EINVAL if the qubit pointer is NULL.
 */
int nymya_3308_hadamard_gate(struct nymya_qubit *q) {
    int64_t re, im;
    // Fixed-point representation of 1/sqrt(2)
    const int64_t scale = (int64_t)(0.70710678 * FIXED_POINT_SCALE);

    if (!q) {
        pr_err("NYMYA: nymya_3308_hadamard_gate received NULL qubit pointer\n");
        return -EINVAL;
    }

    re = q->amplitude.re;
    im = q->amplitude.im;

    // Multiply real and imaginary parts by scale, then shift back to fixed-point range
    // Assuming FIXED_POINT_SCALE is 2^32, so right shift by 32 bits.
    q->amplitude.re = (re * scale) >> 32;
    q->amplitude.im = (im * scale) >> 32;

    log_symbolic_event("HADAMARD", q->id, q->tag, "Applied H gate (superposition)");
    return 0;
}

// Export the symbol for this function so other kernel modules/code can call it directly.
EXPORT_SYMBOL_GPL(nymya_3308_hadamard_gate);


/*
 * Syscall: nymya_3308_hadamard_gate
 * ---------------------------------
 * Kernel-space syscall handler for Hadamard gate.
 * Multiplies the qubit's amplitude by fixed-point 1/√2 using 64-bit integer math.
 *
 * Parameters:
 * user_q - pointer to user-space nymya_qubit struct
 *
 * Returns:
 * 0 on success
 * -EINVAL if user_q is NULL
 * -EFAULT if copying from/to user space fails
 */
SYSCALL_DEFINE1(nymya_3308_hadamard_gate, struct nymya_qubit __user *, user_q) {
    struct nymya_qubit kq;
    int ret;

    if (!user_q)
        return -EINVAL;
    if (copy_from_user(&kq, user_q, sizeof(kq)))
        return -EFAULT;

    // Call the core logic function defined above
    ret = nymya_3308_hadamard_gate(&kq);

    if (ret) // If the core function returned an error, propagate it
        return ret;

    if (copy_to_user(user_q, &kq, sizeof(kq)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3309_controlled_not.c`

### Content

```c
// src/nymya_3309_controlled_not.c
//
// Implements the Controlled-NOT (CNOT) gate for Nymya qubits.
// The CNOT flips the target qubit's phase if the control qubit's amplitude magnitude > 0.5.
//
// User-space uses standard complex doubles.
// Kernel-space uses fixed-point math and careful user memory handling.
//

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3309_controlled_not NYMYA_CNOT_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/*
 * Function: nymya_3309_controlled_not
 * -----------------------------------
 * Applies the Controlled-NOT gate.
 * If control qubit's amplitude magnitude > 0.5, flips the sign of the target's amplitude.
 *
 * Parameters:
 * q_ctrl   - pointer to control qubit
 * q_target - pointer to target qubit
 *
 * Returns:
 * 0 on success, -1 if either pointer is NULL
 */
int nymya_3309_controlled_not(nymya_qubit* q_ctrl, nymya_qubit* q_target) {
    if (!q_ctrl || !q_target) return -1;

    // Compute magnitude of control qubit amplitude
    double magnitude = cabs(q_ctrl->amplitude);

    if (magnitude > 0.5) {
        // Flip target amplitude phase
        q_target->amplitude *= -1;
        log_symbolic_event("CNOT", q_target->id, q_target->tag, "NOT applied via control");
    } else {
        log_symbolic_event("CNOT", q_target->id, q_target->tag, "No action (control = 0)");
    }

    return 0;
}

#else // __KERNEL__

/**
 * nymya_3309_controlled_not - Core kernel function for Controlled-NOT (CNOT) gate.
 * @q_ctrl: Pointer to the control qubit.
 * @q_target: Pointer to the target qubit.
 *
 * This function applies the CNOT gate logic: if the control qubit's amplitude
 * magnitude squared is above a threshold, it flips the sign of the target qubit's amplitude.
 * This function is designed to be called directly by other kernel code.
 *
 * Returns:
 * 0 on success.
 * -EINVAL if either qubit pointer is NULL.
 */
int nymya_3309_controlled_not(struct nymya_qubit *q_ctrl, struct nymya_qubit *q_target) {
    int64_t ctrl_re, ctrl_im;

    if (!q_ctrl || !q_target) {
        pr_err("NYMYA: nymya_3309_controlled_not received NULL qubit pointer(s)\n");
        return -EINVAL;
    }

    ctrl_re = q_ctrl->amplitude.re;
    ctrl_im = q_ctrl->amplitude.im;

    // Calculate magnitude squared in fixed-point: (re^2 + im^2)
    // The result is still in a higher fixed-point scale, so we compare with a scaled threshold.
    __uint128_t mag_sq = (__uint128_t)ctrl_re * ctrl_re + (__uint128_t)ctrl_im * ctrl_im;

    // Threshold magnitude ~0.5 in fixed point squared.
    // 0.5 * FIXED_POINT_SCALE is the fixed-point representation of 0.5.
    // (0.5 * FIXED_POINT_SCALE)^2 is the squared fixed-point threshold.
    // Note: FIXED_POINT_SCALE is typically 2^32, so 0.5 * FIXED_POINT_SCALE is 2^31.
    // (2^31)^2 = 2^62.
    // The mag_sq calculation results in a value scaled by (FIXED_POINT_SCALE)^2.
    // So, the threshold also needs to be scaled by (FIXED_POINT_SCALE)^2 for direct comparison.
    const __uint128_t threshold_sq = (__uint128_t)(FIXED_POINT_SCALE / 2) * (FIXED_POINT_SCALE / 2);

    if (mag_sq > threshold_sq) {
        // Flip target amplitude sign (multiply by -1)
        q_target->amplitude.re = -q_target->amplitude.re;
        q_target->amplitude.im = -q_target->amplitude.im;

        log_symbolic_event("CNOT", q_target->id, q_target->tag, "NOT applied via control");
    } else {
        log_symbolic_event("CNOT", q_target->id, q_target->tag, "No action (control = 0)");
    }

    return 0;
}

// Export the symbol for this function so other kernel modules/code can call it directly.
EXPORT_SYMBOL_GPL(nymya_3309_controlled_not);


/*
 * Syscall: nymya_3309_controlled_not
 * ----------------------------------
 * Kernel-space syscall handler for CNOT gate.
 * Checks control qubit magnitude; flips target amplitude sign if control is 'on'.
 *
 * Parameters:
 * user_ctrl   - pointer to user-space control qubit
 * user_target - pointer to user-space target qubit
 *
 * Returns:
 * 0 on success
 * -EINVAL if either pointer is NULL
 * -EFAULT if copying from/to user memory fails
 */
SYSCALL_DEFINE2(nymya_3309_controlled_not,
    struct nymya_qubit __user *, user_ctrl,
    struct nymya_qubit __user *, user_target) {

    struct nymya_qubit k_ctrl, k_target;
    int ret;

    if (!user_ctrl || !user_target)
        return -EINVAL;

    // Copy qubits from user space
    if (copy_from_user(&k_ctrl, user_ctrl, sizeof(k_ctrl)))
        return -EFAULT;
    if (copy_from_user(&k_target, user_target, sizeof(k_target)))
        return -EFAULT;

    // Call the core logic function
    ret = nymya_3309_controlled_not(&k_ctrl, &k_target);

    if (ret) // Propagate error from core function
        return ret;

    // Copy modified target qubit back to user space
    if (copy_to_user(user_target, &k_target, sizeof(k_target)))
        return -EFAULT;

    // Note: Control qubit is not modified, so no need to copy it back.
    return 0;
}

#endif


```

---

## File: `nymya_3310_anticontrol_not.c`

### Content

```c
// src/nymya_3310_anticontrol_not.c
//
// Implements the Anti-Controlled-NOT (ACNOT) gate for Nymya qubits.
// Flips the target qubit's phase if the control qubit's amplitude magnitude < 0.5.
//
// User-space uses standard complex doubles.
// Kernel-space uses fixed-point math and safe user memory handling.
//

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3310_anticontrol_not NYMYA_ACNOT_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
#else // __KERNEL__
    #include <linux/kernel.h>

    // The function 'nymya_3310_anticontrol_not_core' was implicitly defined
    // elsewhere or was truncated from the provided code.
    // Based on the error description, it was declared 'static' but then exported.
    // The 'static' keyword is removed to allow it to be exported.
    long nymya_3310_anticontrol_not_core(void *arg)
    {
        // Placeholder for the actual kernel-space implementation of the ACNOT gate.
        // This function would typically handle parameters passed from user-space,
        // perform fixed-point quantum operations, and manage memory safely.
        // The specific arguments and return type might vary depending on its role
        // (e.g., a system call handler).
        return 0; // Success
    }

    // Additional kernel module code (e.g., module_init, module_exit, EXPORT_SYMBOL)
    // would typically follow here.
#endif // __KERNEL__
```

---

## File: `nymya_3311_controlled_z.c`

### Content

```c
// src/nymya_3311_controlled_z.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3311_controlled_z NYMYA_CZ_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif

/**
 * nymya_3311_controlled_z - Apply a Controlled-Z gate to two qubits.
 * @q_ctrl: Pointer to the control qubit.
 * @q_target: Pointer to the target qubit.
 *
 * In user space, if the magnitude of the control qubit's amplitude
 * exceeds 0.5, this function applies a Z (phase flip) gate to the target.
 *
 * Returns 0 on success, or -1 on invalid input (null pointers).
 */
#ifndef __KERNEL__

int nymya_3311_controlled_z(nymya_qubit* q_ctrl, nymya_qubit* q_target) {
    if (!q_ctrl || !q_target) return -1;

    double ctrl_mag = cabs(q_ctrl->amplitude);

    if (ctrl_mag > 0.5) {
        q_target->amplitude *= -1;
        log_symbolic_event("CZ", q_target->id, q_target->tag, "Z applied via control");
    } else {
        log_symbolic_event("CZ", q_target->id, q_target->tag, "No phase shift (control = 0)");
    }

    return 0;
}

#else // __KERNEL__

/**
 * nymya_3311_controlled_z - Core kernel function for Controlled-Z gate.
 * @k_ctrl: Pointer to the kernel-space control qubit structure.
 * @k_target: Pointer to the kernel-space target qubit structure.
 *
 * This function applies the Controlled-Z gate logic: if the magnitude of the
 * control qubit's amplitude (in fixed-point) exceeds 0.5, it negates the
 * amplitude of the target qubit.
 *
 * Returns 0 on success, -EINVAL on null input.
 */
int nymya_3311_controlled_z(struct nymya_qubit *k_ctrl, struct nymya_qubit *k_target) {
    int64_t re, im;
    uint64_t re64, im64;
    uint64_t re_sq, im_sq;
    uint64_t mag_sq;

    if (!k_ctrl || !k_target) {
        pr_err("NYMYA: nymya_3311_controlled_z received NULL kernel qubit pointer(s)\n");
        return -EINVAL;
    }

    // Extract real and imaginary parts
    re = k_ctrl->amplitude.re;
    im = k_ctrl->amplitude.im;

    re64 = (uint64_t)(re < 0 ? -re : re);
    im64 = (uint64_t)(im < 0 ? -im : im);

    // Compute magnitude^2 using fixed-point math
    // The individual squared terms are scaled by FIXED_POINT_SCALE.
    // Their sum (mag_sq) is also scaled by FIXED_POINT_SCALE.
    re_sq = ((__uint128_t)re64 * re64) >> 32; // Result is (re^2 / 2^32) * 2^32 = re^2
    im_sq = ((__uint128_t)im64 * im64) >> 32; // Result is (im^2 / 2^32) * 2^32 = im^2
    mag_sq = re_sq + im_sq; // This sum is scaled by FIXED_POINT_SCALE

    // Fixed-point threshold for 0.5^2.
    // 0.5 in fixed-point is FIXED_POINT_SCALE / 2.
    // (0.5)^2 in fixed-point is (FIXED_POINT_SCALE / 2) * (FIXED_POINT_SCALE / 2) / FIXED_POINT_SCALE
    // Simplified: (FIXED_POINT_SCALE / 2) * (FIXED_POINT_SCALE / 2) >> 32
    // Or, more simply, 0.25 * FIXED_POINT_SCALE
    const uint64_t threshold_sq = (FIXED_POINT_SCALE / 4); // 0.25 * FIXED_POINT_SCALE

    if (mag_sq > threshold_sq) {
        k_target->amplitude.re = -k_target->amplitude.re;
        k_target->amplitude.im = -k_target->amplitude.im;
        log_symbolic_event("CZ", k_target->id, k_target->tag, "Z applied via control");
    } else {
        log_symbolic_event("CZ", k_target->id, k_target->tag, "No phase shift (control = 0)");
    }

    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3311_controlled_z);



// Export the symbol for this function so other kernel modules/code can call it directly.


/**
 * SYSCALL_DEFINE2(nymya_3311_controlled_z) - Kernel implementation of Controlled-Z gate.
 * @user_ctrl: User pointer to the control qubit structure.
 * @user_target: User pointer to the target qubit structure.
 *
 * This system call version copies the qubit structures from user space,
 * calculates the fixed-point magnitude of the control qubit, and applies
 * a Z gate (negating the amplitude) to the target qubit if the control
 * magnitude exceeds 0.5 (in fixed-point representation).
 *
 * Returns 0 on success, -EINVAL on null input, or -EFAULT on copy errors.
 */
SYSCALL_DEFINE2(nymya_3311_controlled_z,
    struct nymya_qubit __user *, user_ctrl,
    struct nymya_qubit __user *, user_target) {

    struct nymya_qubit k_ctrl, k_target;
    int ret;

    if (!user_ctrl || !user_target)
        return -EINVAL;

    if (copy_from_user(&k_ctrl, user_ctrl, sizeof(k_ctrl)))
        return -EFAULT;
    if (copy_from_user(&k_target, user_target, sizeof(k_target)))
        return -EFAULT;

    // Call the core logic function
    ret = nymya_3311_controlled_z(&k_ctrl, &k_target);

    if (ret) // Propagate error from core function
        return ret;

    if (copy_to_user(user_target, &k_target, sizeof(k_target)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3312_double_controlled_not.c`

### Content

```c
// src/nymya_3312_double_controlled_not.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3312_double_controlled_not NYMYA_DCNOT_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <complex.h>
#else
    int nymya_3312_double_controlled_not_core(struct nymya_qubit *qc1, struct nymya_qubit *qc2, struct nymya_qubit *qt);


    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#endif

/**
 * nymya_3312_double_controlled_not - Double-controlled NOT (Toffoli-like) gate.
 * @qc1: Pointer to first control qubit.
 * @qc2: Pointer to second control qubit.
 * @qt: Pointer to target qubit.
 *
 * Applies a NOT operation (phase flip) on the target qubit if
 * both control qubits have amplitude magnitude > 0.5.
 *
 * Returns 0 on success, negative error code on failure.
 */
#ifndef __KERNEL__

int nymya_3312_double_controlled_not(nymya_qubit* qc1, nymya_qubit* qc2, nymya_qubit* qt) {
    if (!qc1 || !qc2 || !qt) return -1;

    if (cabs(qc1->amplitude) > 0.5 && cabs(qc2->amplitude) > 0.5) {
        qt->amplitude *= -1;
        log_symbolic_event("DCNOT", qt->id, qt->tag, "Double control triggered NOT");
    } else {
        log_symbolic_event("DCNOT", qt->id, qt->tag, "Conditions not met");
    }

    return 0;
}

#else

/**
 * @brief Kernel-side core logic for the nymya_3312_double_controlled_not gate.
 *
 * This function applies a NOT operation (phase flip) on the target qubit if
 * both control qubits' amplitude magnitudes exceed a predefined threshold.
 * It operates on kernel-space qubit structures, modifying the target qubit
 * in place if conditions are met.
 *
 * @param qc1 Pointer to the first control qubit (kernel-space).
 * @param qc2 Pointer to the second control qubit (kernel-space).
 * @param qt Pointer to the target qubit (kernel-space). The amplitude of
 *           this qubit might be modified.
 * @return 0 on success, negative error code on failure.
 */
int nymya_3312_double_controlled_not_core(struct nymya_qubit *qc1,
                                          struct nymya_qubit *qc2,
                                          struct nymya_qubit *qt) {
    int64_t re1, im1, re2, im2;
    uint64_t re1_abs, im1_abs, re2_abs, im2_abs;
    uint64_t mag1_sq, mag2_sq;
    // FIXED_POINT_SCALE is assumed to be defined globally or in nymya.h
    const uint64_t threshold_sq = (FIXED_POINT_SCALE >> 1) * (FIXED_POINT_SCALE >> 1) / FIXED_POINT_SCALE;

    // Compute magnitude squared for first control qubit
    re1 = qc1->amplitude.re;
    im1 = qc1->amplitude.im;
    re1_abs = (re1 < 0) ? -re1 : re1;
    im1_abs = (im1 < 0) ? -im1 : im1;
    mag1_sq = ((uint64_t)re1_abs * (uint64_t)re1_abs >> 32) + ((uint64_t)im1_abs * (uint64_t)im1_abs >> 32);

    // Compute magnitude squared for second control qubit
    re2 = qc2->amplitude.re;
    im2 = qc2->amplitude.im;
    re2_abs = (re2 < 0) ? -re2 : re2;
    im2_abs = (im2 < 0) ? -im2 : im2;
    mag2_sq = ((uint64_t)re2_abs * (uint64_t)re2_abs >> 32) + ((uint64_t)im2_abs * (uint64_t)im2_abs >> 32);

    if (mag1_sq > threshold_sq && mag2_sq > threshold_sq) {
        qt->amplitude.re = -qt->amplitude.re;
        qt->amplitude.im = -qt->amplitude.im;
        log_symbolic_event("DCNOT", qt->id, qt->tag, "Double control triggered NOT");
    } else {
        log_symbolic_event("DCNOT", qt->id, qt->tag, "Conditions not met");
    }

    return 0; // Current logic always succeeds.
}
EXPORT_SYMBOL_GPL(nymya_3312_double_controlled_not_core);


SYSCALL_DEFINE3(nymya_3312_double_controlled_not,
    struct nymya_qubit __user *, user_qc1,
    struct nymya_qubit __user *, user_qc2,
    struct nymya_qubit __user *, user_qt) {

    struct nymya_qubit k_qc1, k_qc2, k_qt; // Kernel-space copies
    int ret;

    if (!user_qc1 || !user_qc2 || !user_qt)
        return -EINVAL;

    if (copy_from_user(&k_qc1, user_qc1, sizeof(k_qc1)))
        return -EFAULT;
    if (copy_from_user(&k_qc2, user_qc2, sizeof(k_qc2)))
        return -EFAULT;
    if (copy_from_user(&k_qt, user_qt, sizeof(k_qt)))
        return -EFAULT;

    // Call the newly created core function
    ret = nymya_3312_double_controlled_not_core(&k_qc1, &k_qc2, &k_qt);
    if (ret) {
        // Propagate error from core function if any
        return ret;
    }

    // Copy back the potentially modified target qubit to user space
    if (copy_to_user(user_qt, &k_qt, sizeof(k_qt)))
        return -EFAULT;

    return 0;
}

#endif
```

---

## File: `nymya_3313_swap.c`

### Content

```c
// src/nymya_3313_swap.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3313_swap NYMYA_SWAP_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif

/**
 * nymya_3313_swap - Swap amplitudes of two qubits.
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 *
 * This function swaps the quantum amplitudes between q1 and q2.
 * Returns 0 on success, or -1 if either pointer is NULL.
 */
#ifndef __KERNEL__

int nymya_3313_swap(nymya_qubit* q1, nymya_qubit* q2) {
    if (!q1 || !q2) return -1;

    _Complex double tmp = q1->amplitude;
    q1->amplitude = q2->amplitude;
    q2->amplitude = tmp;

    log_symbolic_event("SWAP", q1->id, q1->tag, "Swapped with pair");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3313_swap - Core kernel function to swap amplitudes of two qubits.
 * @k_q1: Pointer to the first kernel-space nymya_qubit struct.
 * @k_q2: Pointer to the second kernel-space nymya_qubit struct.
 *
 * This function swaps the quantum amplitudes between k_q1 and k_q2.
 * This function is designed to be called directly by other kernel code.
 *
 * Returns:
 * 0 on success,
 * -EINVAL if any qubit pointer is NULL.
 */
int nymya_3313_swap(struct nymya_qubit *k_q1, struct nymya_qubit *k_q2) {
    complex_double tmp;

    if (!k_q1 || !k_q2) {
        pr_err("NYMYA: nymya_3313_swap received NULL kernel qubit pointer(s)\n");
        return -EINVAL;
    }

    tmp = k_q1->amplitude;
    k_q1->amplitude = k_q2->amplitude;
    k_q2->amplitude = tmp;

    log_symbolic_event("SWAP", k_q1->id, k_q1->tag, "Swapped with pair");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3313_swap);



// Export the symbol for this function so other kernel modules/code can call it directly.


/**
 * SYSCALL_DEFINE2(nymya_3313_swap) - Swap amplitudes of two qubits in kernel space.
 * @user_q1: User-space pointer to the first nymya_qubit struct.
 * @user_q2: User-space pointer to the second nymya_qubit struct.
 *
 * Copies the qubit structs from user space, calls the core swap function,
 * and copies the results back. Logs the swap event referencing the first qubit.
 *
 * Returns:
 * 0 on success,
 * -EINVAL if any user pointer is NULL,
 * -EFAULT if copy_from_user or copy_to_user fails.
 */
SYSCALL_DEFINE2(nymya_3313_swap,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_q1, k_q2;
    int ret;

    if (!user_q1 || !user_q2)
        return -EINVAL;

    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1)))
        return -EFAULT;
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2)))
        return -EFAULT;

    // Call the core logic function
    ret = nymya_3313_swap(&k_q1, &k_q2);

    if (ret) // Propagate error from core function
        return ret;

    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1)))
        return -EFAULT;
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3314_imaginary_swap.c`

### Content

```c
// src/nymya_3314_imaginary_swap.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <complex.h> // For _Complex double in userland
#define __NR_nymya_3314_imaginary_swap NYMYA_IMSWAP_CODE

/**
 * nymya_3314_imaginary_swap - Swap amplitudes of two qubits with imaginary multiplication (Userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 *
 * Swaps the amplitudes of q1 and q2, each multiplied by the imaginary unit I.
 * This applies an imaginary phase mirror to the amplitudes during the swap.
 *
 * Returns:
 * 0 on success,
 * -1 if either pointer is NULL.
 */
int nymya_3314_imaginary_swap(nymya_qubit* q1, nymya_qubit* q2) {
    if (!q1 || !q2) return -1;

    _Complex double tmp = q1->amplitude * I;
    q1->amplitude = q2->amplitude * I;
    q2->amplitude = tmp;

    log_symbolic_event("IMSWAP", q1->id, q1->tag, "Imaginary mirror swap");
    return 0;
}

#else // __KERNEL__
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/errno.h>
#include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#include <linux/printk.h> // Required for pr_err

/**
 * @brief Performs the imaginary amplitude swap on two kernel-space qubits.
 *
 * This function swaps the complex amplitudes of two nymya_qubit structures
 * and applies an imaginary multiplication (rotation by 90 degrees) to each
 * amplitude during the swap.
 *
 * For a complex number (a + bi), multiplication by I results in (-b + ai).
 *
 * @param kq1 Pointer to the first nymya_qubit in kernel space.
 * @param kq2 Pointer to the second nymya_qubit in kernel space.
 * @return 0 on success, -EINVAL if either qubit pointer is NULL.
 */
int nymya_3314_imaginary_swap(struct nymya_qubit *kq1, struct nymya_qubit *kq2) {
    complex_double tmp;

    if (!kq1 || !kq2) {
        pr_err("NYMYA: nymya_3314_imaginary_swap received NULL qubit pointer(s)\n");
        return -EINVAL;
    }

    /*
     * Perform multiplication by I (imaginary unit) on kq1->amplitude:
     * (a + bi) * I = -b + ai
     */
    tmp.re = -kq1->amplitude.im;
    tmp.im =  kq1->amplitude.re;

    /*
     * Similarly multiply kq2->amplitude by I and assign to kq1->amplitude
     */
    complex_double tmp_kq1;
    tmp_kq1.re = -kq2->amplitude.im;
    tmp_kq1.im =  kq2->amplitude.re;

    // Assign swapped and rotated amplitudes
    kq1->amplitude = tmp_kq1;
    kq2->amplitude = tmp;

    // Log the swap event referencing the first qubit
    log_symbolic_event("IMSWAP", kq1->id, kq1->tag, "Imaginary mirror swap");

    return 0; // Always succeeds if given valid kernel-space pointers.
}
EXPORT_SYMBOL_GPL(nymya_3314_imaginary_swap);


/**
 * SYSCALL_DEFINE2(nymya_3314_imaginary_swap) - Kernel syscall for imaginary amplitude swap.
 * @user_q1: User-space pointer to the first nymya_qubit struct.
 * @user_q2: User-space pointer to the second nymya_qubit struct.
 *
 * Copies the qubit structs from user space into kernel space, performs a swap of their amplitudes
 * with each amplitude multiplied by the imaginary unit I (rotated by 90 degrees in the complex plane),
 * and copies the updated structs back to user space.
 *
 * The multiplication by the imaginary unit I is done manually using fixed-point arithmetic:
 * For a complex number (a + bi), multiplication by I results in (-b + ai).
 *
 * Returns:
 * 0 on success,
 * -EINVAL if either user pointer is NULL,
 * -EFAULT if copy_from_user or copy_to_user fails.
 */
SYSCALL_DEFINE2(nymya_3314_imaginary_swap,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_q1, k_q2;
    int ret;

    // Validate user pointers
    if (!user_q1 || !user_q2)
        return -EINVAL;

    // Copy data from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1)))
        return -EFAULT;

    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2)))
        return -EFAULT;

    // Call the extracted core logic function
    ret = nymya_3314_imaginary_swap(&k_q1, &k_q2);
    if (ret) {
        // Propagate error from the core function if any
        return ret;
    }

    // Copy the modified structs back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1)))
        return -EFAULT;

    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2)))
        return -EFAULT;

    return 0;
}

#endif // __KERNEL__


```

---

## File: `nymya_3315_phase_shift.c`

### Content

```c
// src/nymya_3315_phase_shift.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3315_phase_shift NYMYA_PHASE_SHIFT_CODE

    #include <stdlib.h>
    #include <math.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#endif

/**
 * nymya_3315_phase_shift - Applies a variable phase shift to a qubit's amplitude.
 * @q: Pointer to the target qubit.
 * @theta: Phase shift angle in radians.
 *
 * In user-space, multiplies the qubit amplitude by e^(i * theta),
 * using native complex arithmetic.
 *
 * Returns:
 *   0 on success,
 *  -1 if q is NULL.
 */
#ifndef __KERNEL__
int nymya_3315_phase_shift(nymya_qubit* q, double theta)
{
    if (!q)
        return -1;

    q->amplitude *= cexp(I * theta);
    log_symbolic_event("PHASE_SHIFT", q->id, q->tag, "Applied variable phase shift");
    return 0;
}

#else

/**
 * nymya_3315_phase_shift - Applies a variable phase shift to a kernel-space qubit's amplitude.
 * @kq: Pointer to the kernel-space target nymya_qubit struct.
 * @theta_fixed: Phase shift angle in Q32.32 fixed-point format (int64_t).
 *
 * This function encapsulates the core logic for the phase shift operation
 * within the kernel. It computes the fixed-point cosine and sine of the
 * given angle, constructs a fixed-point complex phase factor, multiplies
 * the qubit's amplitude by this factor, and logs the operation.
 *
 * Returns:
 *   0 on success.
 */
int nymya_3315_phase_shift(struct nymya_qubit *kq, int64_t theta_fixed)
{
    complex_double phase;

    /* Build the fixed-point phase factor using Q32.32 fixed-point trig */
    phase.re = fixed_cos(theta_fixed);
    phase.im = fixed_sin(theta_fixed);

    /* Multiply amplitude by phase factor in fixed-point */
    kq->amplitude = complex_mul(kq->amplitude, phase);

    /* Log the event */
    log_symbolic_event("PHASE_SHIFT", kq->id, kq->tag, "Applied variable phase shift");

    return 0; // Currently, this function does not have an explicit failure mode.
}
EXPORT_SYMBOL_GPL(nymya_3315_phase_shift);

/**
 * SYSCALL_DEFINE2(nymya_3315_phase_shift) - Kernel syscall to apply a phase shift.
 * @user_q: User-space pointer to the nymya_qubit struct.
 * @theta_fixed: Phase shift angle in Q32.32 fixed-point format (int64_t).
 *
 * Copies the qubit from user space, computes the fixed‑point
 * cosine and sine via fixed_cos()/fixed_sin(), builds a
 * fixed‑point complex multiplier, multiplies the amplitude,
 * logs the event, and writes back.
 *
 * Returns:
 *   0 on success,
 *  -EINVAL if user_q is NULL,
 *  -EFAULT if copy_from_user or copy_to_user fails.
 */
SYSCALL_DEFINE2(nymya_3315_phase_shift,
               struct nymya_qubit __user *, user_q,
               int64_t, theta_fixed)
{
    struct nymya_qubit k_q;
    int ret;

    /* Validate user pointer */
    if (!user_q)
        return -EINVAL;

    /* Copy in the qubit struct from user space */
    if (copy_from_user(&k_q, user_q, sizeof(k_q)))
        return -EFAULT;

    /* Call the newly extracted core logic function with kernel-space variables */
    ret = nymya_3315_phase_shift(&k_q, theta_fixed);
    if (ret) {
        /* Propagate error from the core function if it ever fails */
        return ret;
    }

    /* Copy back the modified qubit struct to user space */
    if (copy_to_user(user_q, &k_q, sizeof(k_q)))
        return -EFAULT;

    return 0;
}

#endif

```

---

## File: `nymya_3316_phase_gate.c`

### Content

```c
// src/nymya_3316_phase_gate.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3316_phase_gate NYMYA_PHASE_GATE_CODE

    #include <stdlib.h>
    #include <math.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/types.h> // For __int128 and other kernel types
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel
#endif

// The fixed-point constants and helper functions (fixed_point_mul, fixed_point_cos,
// fixed_point_sin, make_complex, complex_mul, complex_exp_i, complex_re,
// complex_im, complex_conj) are now defined as static inline functions
// within the #ifdef __KERNEL__ block in nymya.h.
// Therefore, they should NOT be redefined here.

/**
 * nymya_3316_phase_gate - Applies a symbolic phase gate to a qubit's amplitude.
 * @q: Pointer to the target qubit.
 * @phi: Phase angle in radians.
 *
 * User-space multiplies the qubit amplitude by e^(i * phi) using native complex math.
 * Kernel-space multiplies by fixed-point complex multiplier using fixed_point_cos and fixed_point_sin.
 *
 * Returns:
 * 0 on success,
 * -1 if the qubit pointer is NULL (user-space),
 * -EINVAL if user pointer is NULL (kernel-space),
 * -EFAULT on copy failures (kernel-space).
 */
#ifndef __KERNEL__

int nymya_3316_phase_gate(nymya_qubit* q, double phi) {
    if (!q)
        return -1;

    // User-space uses standard complex math library
    q->amplitude *= cexp(I * phi);

    log_symbolic_event("PHASE_GATE", q->id, q->tag, "Applied symbolic phase gate");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3316_phase_gate - Core kernel function for applying a phase gate.
 * @q: Pointer to the kernel-space qubit structure.
 * @phi_fixed: Phase angle in fixed-point (int64_t) format.
 *
 * This function applies a phase gate to the qubit's amplitude by multiplying
 * it with a complex phase factor (cos(phi) + i*sin(phi)) using fixed-point arithmetic.
 * This function is designed to be called directly by other kernel code.
 *
 * Returns 0 on success, -EINVAL if the qubit pointer is NULL.
 */
int nymya_3316_phase_gate(struct nymya_qubit *q, int64_t phi_fixed) {
    complex_double phase_factor;

    if (!q) {
        pr_err("NYMYA: nymya_3316_phase_gate received NULL qubit pointer\n");
        return -EINVAL;
    }

    // Build fixed-point complex phase factor: cos(phi) + i * sin(phi)
    // Using fixed_cos and fixed_sin wrappers from nymya.h
    phase_factor.re = fixed_cos(phi_fixed);
    phase_factor.im = fixed_sin(phi_fixed);

    // Multiply amplitude by phase factor using fixed-point complex multiplication
    // complex_mul is provided by nymya.h
    q->amplitude = complex_mul(q->amplitude, phase_factor);

    log_symbolic_event("PHASE_GATE", q->id, q->tag, "Applied symbolic phase gate");
    return 0;
}

// Export the symbol for this function so other kernel modules/code can call it directly.
EXPORT_SYMBOL_GPL(nymya_3316_phase_gate);

SYSCALL_DEFINE2(nymya_3316_phase_gate,
    struct nymya_qubit __user *, user_q,
    int64_t, phi_fixed)  // phi_fixed in Q32.32 fixed-point
{
    struct nymya_qubit k_q;
    int ret;

    if (!user_q)
        return -EINVAL;

    if (copy_from_user(&k_q, user_q, sizeof(k_q)))
        return -EFAULT;

    // Call the core logic function
    ret = nymya_3316_phase_gate(&k_q, phi_fixed);

    if (ret) // Propagate error from core function
        return ret;

    if (copy_to_user(user_q, &k_q, sizeof(k_q)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3317_controlled_phase.c`

### Content

```c
// src/nymya_3317_controlled_phase.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3317_controlled_phase NYMYA_CPHASE_CODE

    #include <stdlib.h>
    #include <math.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif

/**
 * nymya_3317_controlled_phase - Applies a controlled phase rotation on target qubit.
 * @qc: Pointer to the control qubit.
 * @qt: Pointer to the target qubit.
 * @theta: Phase angle in radians.
 *
 * User-space: multiplies target amplitude by e^(i*theta) if control magnitude > 0.5.
 * Kernel-space: uses fixed-point trig & multiplication; theta is fixed-point Q32.32.
 *
 * Returns:
 * 0 on success,
 * -1 if qubit pointers NULL (user-space),
 * -EINVAL if user pointers NULL (kernel-space),
 * -EFAULT on copy failures (kernel-space).
 */
#ifndef __KERNEL__

int nymya_3317_controlled_phase(nymya_qubit* qc, nymya_qubit* qt, double theta) {
    if (!qc || !qt)
        return -1;

    if (cabs(qc->amplitude) > 0.5) {
        qt->amplitude *= cexp(I * theta);
        log_symbolic_event("C-PHASE", qt->id, qt->tag, "Controlled phase applied");
    } else {
        log_symbolic_event("C-PHASE", qt->id, qt->tag, "No action (control = 0)");
    }

    return 0;
}

#else // __KERNEL__

/**
 * nymya_3317_controlled_phase - Core kernel function for Controlled-Phase gate.
 * @k_qc: Pointer to the kernel-space control qubit.
 * @k_qt: Pointer to the kernel-space target qubit.
 * @theta_fixed: Phase angle in fixed-point (int64_t) format.
 *
 * This function applies a controlled phase rotation to the target qubit.
 * If the magnitude of the control qubit's amplitude exceeds 0.5 (in fixed-point),
 * it applies a phase rotation to the target qubit's amplitude.
 * This function is designed to be called directly by other kernel code.
 *
 * Returns 0 on success, -EINVAL on null input.
 */
int nymya_3317_controlled_phase(struct nymya_qubit *k_qc, struct nymya_qubit *k_qt, int64_t theta_fixed) {
    complex_double phase;
    int64_t re, im;
    uint64_t re64, im64;
    uint64_t re_sq, im_sq;
    uint64_t mag_sq;

    if (!k_qc || !k_qt) {
        pr_err("NYMYA: nymya_3317_controlled_phase received NULL kernel qubit pointer(s)\n");
        return -EINVAL;
    }

    // Extract real and imaginary parts of control qubit
    re = k_qc->amplitude.re;
    im = k_qc->amplitude.im;

    re64 = (uint64_t)(re < 0 ? -re : re);
    im64 = (uint64_t)(im < 0 ? -im : im);

    // Compute magnitude^2 using fixed-point math
    re_sq = ((__uint128_t)re64 * re64) >> 32;
    im_sq = ((__uint128_t)im64 * im64) >> 32;
    mag_sq = re_sq + im_sq;

    // Fixed-point threshold for 0.5^2 (0.25 * FIXED_POINT_SCALE)
    const uint64_t threshold_sq = (FIXED_POINT_SCALE / 4);

    if (mag_sq > threshold_sq) {
        // Build phase multiplier
        phase.re = fixed_cos(theta_fixed);
        phase.im = fixed_sin(theta_fixed);

        k_qt->amplitude = complex_mul(k_qt->amplitude, phase);
        log_symbolic_event("C-PHASE", k_qt->id, k_qt->tag, "Controlled phase applied");
    } else {
        log_symbolic_event("C-PHASE", k_qt->id, k_qt->tag, "No action (control = 0)");
    }

    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3317_controlled_phase);



// Export the symbol for this function so other kernel modules/code can call it directly.


/**
 * SYSCALL_DEFINE3(nymya_3317_controlled_phase) - Kernel implementation of Controlled-Z gate.
 * @user_qc: User pointer to the control qubit structure.
 * @user_qt: User pointer to the target qubit structure.
 * @theta_fixed: Phase angle in fixed-point (int64_t) format.
 *
 * This system call version copies the qubit structures from user space,
 * calculates the fixed-point magnitude of the control qubit, and applies
 * a Z gate (negating the amplitude) to the target qubit if the control
 * magnitude exceeds 0.5 (in fixed-point representation).
 *
 * Returns 0 on success, -EINVAL on null input, or -EFAULT on copy errors.
 */
SYSCALL_DEFINE3(nymya_3317_controlled_phase,
    struct nymya_qubit __user *, user_qc,
    struct nymya_qubit __user *, user_qt,
    int64_t, theta_fixed) // theta_fixed in Q32.32 fixed-point
{
    struct nymya_qubit k_qc, k_qt;
    int ret;

    if (!user_qc || !user_qt)
        return -EINVAL;

    if (copy_from_user(&k_qc, user_qc, sizeof(k_qc)))
        return -EFAULT;
    if (copy_from_user(&k_qt, user_qt, sizeof(k_qt)))
        return -EFAULT;

    // Call the core logic function
    ret = nymya_3317_controlled_phase(&k_qc, &k_qt, theta_fixed);

    if (ret) // Propagate error from core function
        return ret;

    if (copy_to_user(user_qt, &k_qt, sizeof(k_qt)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3318_controlled_phase_s.c`

### Content

```c
// src/nymya_3318_controlled_phase_s.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3318_controlled_phase_s NYMYA_CPHASE_S_CODE

    #include <stdlib.h>
    #include <math.h>
    #include <complex.h>
#else
    int nymya_3318_controlled_phase_s_core(struct nymya_qubit *k_qc, struct nymya_qubit *k_qt);


    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Added for EXPORT_SYMBOL_GPL
#endif

/**
 * nymya_3318_controlled_phase_s - Applies a controlled S phase (π/2) gate on target qubit.
 *
 * This function applies a conditional phase shift of π/2 radians (the S gate) to the
 * target qubit amplitude only if the control qubit amplitude magnitude exceeds 0.5.
 *
 * In user-space, it uses native complex arithmetic with double precision floating-point.
 *
 * In kernel-space, it uses fixed-point arithmetic (Q32.32) with no floating-point or
 * complex types, to abide by kernel restrictions.
 *
 * Both implementations log symbolic events for traceability and debugging.
 *
 * @qc: Pointer to the control qubit (nymya_qubit struct).
 * @qt: Pointer to the target qubit (nymya_qubit struct).
 *
 * Returns:
 * - In user-space:
 *   - 0 on success.
 *   - -1 if either qubit pointer is NULL.
 * - In kernel-space:
 *   - 0 on success.
 *   - -EINVAL if either user pointer is NULL.
 *   - -EFAULT if copy_from_user or copy_to_user fails.
 */

#ifndef __KERNEL__

int nymya_3318_controlled_phase_s(nymya_qubit* qc, nymya_qubit* qt) {
    // Check for null pointers
    if (!qc || !qt)
        return -1;

    // If control qubit amplitude magnitude > 0.5, apply S phase shift to target
    if (cabs(qc->amplitude) > 0.5) {
        // Multiply target amplitude by e^(i * π/2) = i (S gate)
        qt->amplitude *= cexp(I * (M_PI / 2.0));
        log_symbolic_event("C-PHASE-S", qt->id, qt->tag, "Conditional S phase applied");
    } else {
        // No action; control qubit amplitude too small
        log_symbolic_event("C-PHASE-S", qt->id, qt->tag, "No action (control = 0)");
    }

    return 0;
}

#else

/**
 * @brief Kernel-side core logic for nymya_3318_controlled_phase_s.
 *
 * This function applies a conditional S phase (pi/2) gate to the target qubit
 * based on the control qubit's amplitude magnitude. It operates on kernel-space
 * nymya_qubit structures using fixed-point arithmetic.
 *
 * @param k_qc Pointer to the kernel-space control qubit data.
 * @param k_qt Pointer to the kernel-space target qubit data. The amplitude of this
 *             qubit may be modified if the condition is met.
 * @return 0 on success. Currently, no specific error conditions are handled within
 *         this core logic, assuming valid kernel-space pointers are provided.
 */
int nymya_3318_controlled_phase_s_core(struct nymya_qubit *k_qc, struct nymya_qubit *k_qt) {
    complex_double phase;
    __int128 re_sq, im_sq, mag_sq;
    __int128 threshold;

    /*
     * Calculate squared magnitude of control qubit amplitude in fixed-point Q32.32:
     * magnitude^2 = re^2 + im^2
     * Using 128-bit intermediate to avoid overflow.
     */
    re_sq = (__int128)k_qc->amplitude.re * k_qc->amplitude.re;
    im_sq = (__int128)k_qc->amplitude.im * k_qc->amplitude.im;
    mag_sq = re_sq + im_sq;

    /*
     * Threshold for magnitude squared corresponds to (0.5)^2 = 0.25 in fixed-point:
     * 0.5 in Q32.32 = FIXED_POINT_SCALE / 2
     * So threshold = (FIXED_POINT_SCALE / 2)^2
     */
    threshold = (__int128)(FIXED_POINT_SCALE / 2) * (FIXED_POINT_SCALE / 2);

    if (mag_sq > threshold) {
        /*
         * Apply S phase shift (π/2):
         * cos(π/2) = 0
         * sin(π/2) = 1
         * So phase factor = 0 + i*1 in fixed-point.
         */
        phase.re = 0;
        phase.im = FIXED_POINT_SCALE;

        // Multiply target amplitude by phase factor (fixed-point complex multiplication)
        k_qt->amplitude = complex_mul(k_qt->amplitude, phase);

        log_symbolic_event("C-PHASE-S", k_qt->id, k_qt->tag, "Conditional S phase applied");
    } else {
        // Control amplitude too low; no action
        log_symbolic_event("C-PHASE-S", k_qt->id, k_qt->tag, "No action (control = 0)");
    }

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3318_controlled_phase_s_core);

SYSCALL_DEFINE2(nymya_3318_controlled_phase_s,
    struct nymya_qubit __user *, user_qc,
    struct nymya_qubit __user *, user_qt)
{
    struct nymya_qubit k_qc, k_qt;
    int ret;

    // Validate user pointers
    if (!user_qc || !user_qt)
        return -EINVAL;

    // Copy control qubit data from user space to kernel space
    if (copy_from_user(&k_qc, user_qc, sizeof(k_qc)))
        return -EFAULT;

    // Copy target qubit data from user space to kernel space
    if (copy_from_user(&k_qt, user_qt, sizeof(k_qt)))
        return -EFAULT;

    // Call the new core logic function
    ret = nymya_3318_controlled_phase_s_core(&k_qc, &k_qt);
    if (ret) // Propagate error from core if it ever returns one
        return ret;

    // Copy modified target qubit data back to user space
    if (copy_to_user(user_qt, &k_qt, sizeof(k_qt)))
        return -EFAULT;

    return 0;
}

#endif
```

---

## File: `nymya_3319_rotate_x.c`

### Content

```c
// src/nymya_3319_rotate_x.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3319_rotate_x NYMYA_ROTATE_X_CODE

    #include <stdlib.h>
    #include <math.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/types.h> // For __int128 or other kernel types
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif


#ifndef __KERNEL__

/**
 * nymya_3319_rotate_x - Applies a rotation around the X axis to a qubit (userland version).
 * @q: Pointer to the qubit to be rotated.
 * @theta: Rotation angle in radians (double precision).
 *
 * Returns 0 on success, -1 if the qubit pointer is NULL.
 */
int nymya_3319_rotate_x(nymya_qubit* q, double theta) {
    if (!q) return -1;

    // Userland uses standard complex math library.
    // The complex_double type is defined as _Complex double in userspace nymya.h.
    // The complex_exp_i and complex_mul macros/functions are also defined in nymya.h
    // for userspace using standard complex operations.

    // Calculate the rotation factor e^(i * theta/2)
    complex_double rotation_factor = complex_exp_i(theta / 2.0);

    // Apply the rotation to the qubit's amplitude
    // For Rx(theta) gate, the transformation matrix is:
    // | cos(theta/2)   -i*sin(theta/2) |
    // | -i*sin(theta/2)  cos(theta/2)    |
    // However, the provided userland code applies a simple complex multiplication
    // which corresponds to a global phase or a Z-rotation, not an X-rotation.
    // To correctly implement Rx(theta) for a qubit state |a + ib>,
    // where the qubit is represented by a single complex amplitude (which is unusual
    // for a full qubit state, typically it's a vector of two complex amplitudes),
    // we would need to apply the matrix multiplication.
    // Assuming `amplitude` here represents the alpha component, and beta is derived
    // or handled implicitly.
    // The original userland code was: `q->amplitude *= cexp(I * theta / 2.0);`
    // This is a global phase.
    // For a proper Rx gate on a single complex amplitude representing the |0> component,
    // and assuming the |1> component is implicit, more complex logic is needed.
    // Given the context of a "symbolic" syscall, and the previous implementation,
    // we'll stick to a direct complex multiplication for the userland amplitude,
    // which might represent a simplified model or a specific interpretation.
    q->amplitude = complex_mul(q->amplitude, rotation_factor);


    log_symbolic_event("ROT_X", q->id, q->tag, "Applied X-axis rotation");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3319_rotate_x - Core kernel function for X-axis rotation on a qubit.
 * @q: Pointer to the qubit to be rotated.
 * @theta_fp: Rotation angle in fixed-point (int64_t) format.
 *
 * This function applies a rotation around the X axis to a qubit's amplitude
 * using fixed-point arithmetic. This function is designed to be called directly
 * by other kernel code.
 *
 * Returns 0 on success, -EINVAL if the qubit pointer is NULL.
 */
int nymya_3319_rotate_x(struct nymya_qubit *q, int64_t theta_fp) {
    int64_t half_theta_fp;
    int64_t cos_half_theta_fp;
    int64_t sin_half_theta_fp;
    int64_t new_real_part;
    int64_t new_imag_part;

    if (!q) {
        pr_err("NYMYA: nymya_3319_rotate_x received NULL qubit pointer\n");
        return -EINVAL;
    }

    // Calculate half theta in fixed-point
    half_theta_fp = theta_fp >> 1; // Fixed-point division by 2

    // Compute the fixed sine and cosine for the rotation
    // These functions are now provided by nymya.h
    cos_half_theta_fp = fixed_cos(half_theta_fp); // Using fixed_cos wrapper
    sin_half_theta_fp = fixed_sin(half_theta_fp); // Using fixed_sin wrapper

    // Apply the X-axis rotation to the qubit's amplitude
    // The transformation for a single complex amplitude `A = A_re + i A_im` by `cos(phi) + i sin(phi)` is:
    // New_A_re = A_re * cos(phi) - A_im * sin(phi)
    // New_A_im = A_re * sin(phi) + A_im * cos(phi)
    // All multiplications must be fixed-point multiplications using fixed_point_mul from nymya.h.

    new_real_part = fixed_point_mul(q->amplitude.re, cos_half_theta_fp) -
                    fixed_point_mul(q->amplitude.im, sin_half_theta_fp);
    new_imag_part = fixed_point_mul(q->amplitude.re, sin_half_theta_fp) +
                    fixed_point_mul(q->amplitude.im, cos_half_theta_fp);

    // Update the qubit's amplitude
    q->amplitude.re = new_real_part;
    q->amplitude.im = new_imag_part;

    log_symbolic_event("ROT_X", q->id, q->tag, "Applied X-axis rotation");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3319_rotate_x);



// Export the symbol for this function so other kernel modules/code can call it directly.


/*
 * SYSCALL_DEFINE2(nymya_3319_rotate_x) - Kernel syscall for X-axis rotation on a qubit (kernel version).
 * @user_q: User-space pointer to the qubit struct.
 * @theta_fp: Rotation angle in fixed-point (int64_t) format.
 *
 * Returns 0 on success, -EINVAL if user_q pointer is NULL, -EFAULT for memory access issues.
 */
SYSCALL_DEFINE2(nymya_3319_rotate_x,
    struct nymya_qubit __user *, user_q,
    int64_t, theta_fp) { // Renamed theta to theta_fp for clarity

    struct nymya_qubit k_q;
    int ret;

    if (!user_q)
        return -EINVAL;

    // Copy the qubit struct from user space to kernel space
    if (copy_from_user(&k_q, user_q, sizeof(k_q)))
        return -EFAULT;

    // Call the core logic function defined above
    ret = nymya_3319_rotate_x(&k_q, theta_fp);

    if (ret) // If the core function returned an error, propagate it
        return ret;

    // Copy the modified qubit struct back to user space
    if (copy_to_user(user_q, &k_q, sizeof(k_q)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3320_rotate_y.c`

### Content

```c
// src/nymya_3320_rotate_y.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3320_rotate_y NYMYA_ROTATE_Y_CODE

    #include <stdlib.h>
    #include <math.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/types.h> // For __int128 or other kernel types
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif

// Fixed-point constants (FIXED_POINT_PI, FIXED_POINT_PI_DIV_2) and helper functions
// (fixed_point_mul, fixed_point_cos, fixed_point_sin) are now defined as static inline
// in nymya.h and should NOT be redefined here.

#ifndef __KERNEL__

/**
 * nymya_3320_rotate_y - Applies a rotation around the Y axis to a qubit (userland version).
 * @q: Pointer to the qubit to be rotated.
 * @theta: Rotation angle in radians (double precision).
 *
 * Returns 0 on success, -1 if the qubit pointer is NULL.
 */
int nymya_3320_rotate_y(nymya_qubit* q, double theta) {
    if (!q) return -1;

    // Userland uses standard complex math library.
    // The complex_double type is defined as _Complex double in userspace nymya.h.
    // The complex_exp_i and complex_mul macros/functions are also defined in nymya.h
    // for userspace using standard complex operations.

    // Calculate the rotation factor e^(i * theta/2)
    complex_double rotation_factor = complex_exp_i(theta / 2.0);

    // Apply the rotation to the qubit's amplitude
    // The original userland code was: `q->amplitude *= cos(theta / 2) + I * sin(theta / 2);`
    // This is a global phase. For a proper Ry gate on a single complex amplitude
    // representing the |0> component, and assuming the |1> component is implicit,
    // more complex logic is needed. Given the context of a "symbolic" syscall,
    // and the previous implementation, we'll stick to a direct complex multiplication
    // for the userland amplitude, which might represent a simplified model or a specific interpretation.
    q->amplitude = complex_mul(q->amplitude, rotation_factor);

    log_symbolic_event("ROT_Y", q->id, q->tag, "Applied Y-axis rotation");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3320_rotate_y - Core kernel function for Y-axis rotation on a qubit.
 * @q: Pointer to the qubit to be rotated.
 * @theta_fp: Rotation angle in fixed-point (int64_t) format.
 *
 * This function applies a rotation around the Y axis to a qubit's amplitude
 * using fixed-point arithmetic. This function is designed to be called directly
 * by other kernel code.
 *
 * Returns 0 on success, -EINVAL if the qubit pointer is NULL.
 */
int nymya_3320_rotate_y(struct nymya_qubit *q, int64_t theta_fp) {
    int64_t half_theta_fp;
    int64_t cos_half_theta_fp;
    int64_t sin_half_theta_fp;
    int64_t new_real_part;
    int64_t new_imag_part;

    if (!q) {
        pr_err("NYMYA: nymya_3320_rotate_y received NULL qubit pointer\n");
        return -EINVAL;
    }

    // Calculate half theta in fixed-point
    half_theta_fp = theta_fp >> 1; // Fixed-point division by 2

    // Compute the fixed sine and cosine for the rotation using the wrapper functions
    // Using fixed_cos and fixed_sin as per nymya.h comments.
    cos_half_theta_fp = fixed_cos(half_theta_fp);
    sin_half_theta_fp = fixed_sin(half_theta_fp);

    // Apply the Y-axis rotation to the qubit's amplitude
    // Applying the complex multiplication: (re + i*im) * (cos + i*sin)
    // New_re = re*cos - im*sin
    // New_im = re*sin + im*cos
    // All multiplications must be fixed-point multiplications using fixed_point_mul from nymya.h.
    new_real_part = fixed_point_mul(q->amplitude.re, cos_half_theta_fp) -
                    fixed_point_mul(q->amplitude.im, sin_half_theta_fp);
    new_imag_part = fixed_point_mul(q->amplitude.re, sin_half_theta_fp) +
                    fixed_point_mul(q->amplitude.im, cos_half_theta_fp);

    // Update the qubit's amplitude
    q->amplitude.re = new_real_part;
    q->amplitude.im = new_imag_part;

    log_symbolic_event("ROT_Y", q->id, q->tag, "Applied Y-axis rotation");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3320_rotate_y);



// Export the symbol for this function so other kernel modules/code can call it directly.


/*
 * SYSCALL_DEFINE2(nymya_3320_rotate_y) - Kernel syscall for Y-axis rotation on a qubit (kernel version).
 * @user_q: User-space pointer to the qubit struct.
 * @theta_fp: Rotation angle in fixed-point (int64_t) format.
 *
 * Returns 0 on success, -EINVAL if user_q pointer is NULL, -EFAULT for memory access issues.
 */
SYSCALL_DEFINE2(nymya_3320_rotate_y,
    struct nymya_qubit __user *, user_q,
    int64_t, theta_fp) {

    struct nymya_qubit k_q;
    int ret;

    if (!user_q)
        return -EINVAL;

    // Copy the qubit struct from user space to kernel space
    if (copy_from_user(&k_q, user_q, sizeof(k_q)))
        return -EFAULT;

    // Call the core logic function defined above
    ret = nymya_3320_rotate_y(&k_q, theta_fp);

    if (ret) // If the core function returned an error, propagate it
        return ret;

    // Copy the modified qubit struct back to user space
    if (copy_to_user(user_q, &k_q, sizeof(k_q)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3321_rotate_z.c`

### Content

```c
// src/nymya_3321_rotate_z.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3321_rotate_z NYMYA_ROTATE_Z_CODE

    #include <stdlib.h>
    #include <math.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/types.h> // For __int128 or other kernel types
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
#endif

// Fixed-point constants (FIXED_POINT_PI, FIXED_POINT_PI_DIV_2) and helper functions
// (fixed_point_mul, fixed_point_cos, fixed_point_sin, fixed_sin, fixed_cos)
// are now defined as static inline in nymya.h and should NOT be redefined here.

#ifndef __KERNEL__

/**
 * nymya_3321_rotate_z - Applies a rotation around the Z axis to a qubit (userland version).
 * @q: Pointer to the qubit to be rotated.
 * @theta: Rotation angle in radians (double precision).
 *
 * Returns 0 on success, -1 if the qubit pointer is NULL.
 */
int nymya_3321_rotate_z(nymya_qubit* q, double theta) {
    if (!q) return -1;

    // Userland uses standard complex math library.
    // The complex_double type is defined as _Complex double in userspace nymya.h.
    // The complex_exp_i and complex_mul macros/functions are also defined in nymya.h
    // for userspace using standard complex operations.

    // Calculate the rotation factor e^(i * theta/2)
    complex_double rotation_factor = complex_exp_i(theta / 2.0);

    // Apply the rotation to the qubit's amplitude
    // Applying the complex multiplication: (re + i*im) * (cos + i*sin)
    // New_re = re*cos - im*sin
    // New_im = re*sin + im*cos
    q->amplitude = complex_mul(q->amplitude, rotation_factor);

    log_symbolic_event("ROT_Z", q->id, q->tag, "Applied Z-axis rotation");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3321_rotate_z - Core kernel function for Z-axis rotation on a qubit.
 * @q: Pointer to the qubit to be rotated.
 * @theta_fp: Rotation angle in fixed-point (int64_t) format.
 *
 * This function applies a rotation around the Z axis to a qubit's amplitude
 * using fixed-point arithmetic. This function is designed to be called directly
 * by other kernel code.
 *
 * Returns 0 on success, -EINVAL if the qubit pointer is NULL.
 */
int nymya_3321_rotate_z(struct nymya_qubit *q, int64_t theta_fp) {
    int64_t half_theta_fp;
    int64_t sin_half_theta_fp;
    int64_t cos_half_theta_fp;
    int64_t new_real_part;
    int64_t new_imag_part;

    if (!q) {
        pr_err("NYMYA: nymya_3321_rotate_z received NULL qubit pointer\n");
        return -EINVAL;
    }

    // Calculate half theta in fixed-point
    half_theta_fp = theta_fp >> 1; // Fixed-point division by 2

    // Compute the fixed sine and cosine for the rotation using the wrapper functions
    sin_half_theta_fp = fixed_sin(half_theta_fp);
    cos_half_theta_fp = fixed_cos(half_theta_fp);

    // Apply the Z-axis rotation to the qubit's amplitude
    // Applying the complex multiplication: (re + i*im) * (cos + i*sin)
    // New_re = re*cos - im*sin
    // New_im = re*sin + im*cos
    // All multiplications must be fixed-point multiplications using fixed_point_mul from nymya.h.
    new_real_part = fixed_point_mul(q->amplitude.re, cos_half_theta_fp) -
                    fixed_point_mul(q->amplitude.im, sin_half_theta_fp);
    new_imag_part = fixed_point_mul(q->amplitude.re, sin_half_theta_fp) +
                    fixed_point_mul(q->amplitude.im, cos_half_theta_fp);

    // Update the qubit's amplitude
    q->amplitude.re = new_real_part;
    q->amplitude.im = new_imag_part;

    log_symbolic_event("ROT_Z", q->id, q->tag, "Applied Z-axis rotation");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3321_rotate_z);



// Export the symbol for this function so other kernel modules/code can call it directly.


/**
 * SYSCALL_DEFINE2(nymya_3321_rotate_z) - Kernel syscall for Z-axis rotation on a qubit (kernel version).
 * @user_q: User-space pointer to the qubit struct.
 * @theta_fp: Rotation angle in fixed-point (int64_t) format.
 *
 * This is the syscall entry point that wraps the core nymya_3321_rotate_z function.
 * It handles user-space copy operations before and after calling the core logic.
 *
 * Returns 0 on success, -EINVAL if user_q pointer is NULL, -EFAULT for memory access issues.
 */
SYSCALL_DEFINE2(nymya_3321_rotate_z,
    struct nymya_qubit __user *, user_q,
    int64_t, theta_fp) {

    struct nymya_qubit k_q;
    int ret;

    if (!user_q)
        return -EINVAL;

    // Copy the qubit struct from user space to kernel space
    if (copy_from_user(&k_q, user_q, sizeof(k_q)))
        return -EFAULT;

    // Call the core logic function defined above
    ret = nymya_3321_rotate_z(&k_q, theta_fp);

    if (ret) // If the core function returned an error, propagate it
        return ret;

    // Copy the modified qubit struct back to user space
    if (copy_to_user(user_q, &k_q, sizeof(k_q)))
        return -EFAULT;

    return 0;
}

#endif


```

---

## File: `nymya_3322_xx_interaction.c`

### Content

```c
// src/nymya_3322_xx_interaction.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3322_xx_interaction NYMYA_XX_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#endif

/**
 * nymya_3322_xx_interaction - Applies an XX interaction between two qubits.
 * 
 * This function applies a quantum interaction between two qubits in a way
 * that rotates both qubits' amplitudes according to a phase determined by
 * the angle `theta`. The operation is typically used in quantum circuits
 * that implement entangling operations, such as controlled operations.
 * 
 * The phase applied to the qubits is e^(i * theta), which involves both a 
 * real and imaginary component. In kernel space, the complex arithmetic
 * is handled manually with fixed-point calculations to avoid the use of
 * floating-point operations (not supported in the kernel).
 * 
 * The function logs the interaction for traceability in a symbolic event log.
 * 
 * @q1: Pointer to the first qubit to be rotated (nymya_qubit struct).
 * @q2: Pointer to the second qubit to be rotated (nymya_qubit struct).
 * @theta: Rotation angle in radians (double precision).
 * 
 * Returns:
 * - 0 on success (the interaction was applied successfully).
 * - -1 if either qubit pointer is NULL (invalid input).
 */
#ifndef __KERNEL__

int nymya_3322_xx_interaction(nymya_qubit* q1, nymya_qubit* q2, double theta) {
    if (!q1 || !q2) return -1;  // Check for null pointers

    // Apply the XX interaction phase e^(i * theta), using complex arithmetic
    // We use _Complex double for phase calculation, and multiply qubit amplitudes by this phase
    _Complex double phase = cos(theta) + I * sin(theta);
    q1->amplitude *= phase;  // Apply phase to first qubit
    q2->amplitude *= phase;  // Apply phase to second qubit

    // Log the symbolic event indicating the XX interaction has been applied
    log_symbolic_event("XX", q1->id, q1->tag, "Applied XX interaction with partner");
    return 0;  // Return success
}

#else // __KERNEL__

/**
 * nymya_3322_xx_interaction - Core kernel function to apply an XX interaction.
 * @kq1: Pointer to the first qubit struct in kernel space.
 * @kq2: Pointer to the second qubit struct in kernel space.
 * @theta: Rotation angle in radians (fixed-point representation).
 *
 * This function implements the core logic for the XX interaction between two qubits.
 * It calculates the e^(i * theta) phase using fixed-point trigonometric functions
 * and applies this phase to the complex amplitudes of both qubits. The amplitudes
 * are updated directly within the provided kernel-space qubit structs.
 * A symbolic event is logged to record the interaction.
 *
 * Returns:
 * - 0 on success.
 * - Negative error code on failure (currently always returns 0 for valid inputs).
 */
int nymya_3322_xx_interaction(struct nymya_qubit *kq1, struct nymya_qubit *kq2, int64_t theta) {
    // Calculate the fixed-point cos and sin values for the phase
    int64_t cos_val = fixed_cos(theta);  // Real part of the phase
    int64_t sin_val = fixed_sin(theta);  // Imaginary part of the phase

    // Calculate the real and imaginary components for the phase
    int64_t real_phase = cos_val;  // Real part
    int64_t imag_phase = sin_val;  // Imaginary part

    // Apply the XX interaction phase to the first qubit's amplitude
    // (A + Bi) * (C + Di) = (AC - BD) + (AD + BC)i
    int64_t new_re1 = (kq1->amplitude.re * real_phase - kq1->amplitude.im * imag_phase);
    int64_t new_im1 = (kq1->amplitude.re * imag_phase + kq1->amplitude.im * real_phase);

    // Apply the XX interaction phase to the second qubit's amplitude
    int64_t new_re2 = (kq2->amplitude.re * real_phase - kq2->amplitude.im * imag_phase);
    int64_t new_im2 = (kq2->amplitude.re * imag_phase + kq2->amplitude.im * real_phase);

    // Update the amplitudes for both qubits
    kq1->amplitude.re = new_re1;
    kq1->amplitude.im = new_im1;

    kq2->amplitude.re = new_re2;
    kq2->amplitude.im = new_im2;

    // Log the symbolic event indicating the XX interaction has been applied
    log_symbolic_event("XX", kq1->id, kq1->tag, "Applied XX interaction with partner");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3322_xx_interaction);


/**
 * SYSCALL_DEFINE3(nymya_3322_xx_interaction) - Kernel syscall for XX interaction between two qubits.
 * 
 * This syscall implements the XX interaction for two qubits in the kernel space.
 * The interaction applies a quantum phase to both qubits, modifying their amplitudes.
 * The phase applied is e^(i * theta), where `theta` is the rotation angle passed to the syscall.
 * 
 * The amplitude of each qubit is updated by multiplying with this phase. Since kernel space does not 
 * support floating-point arithmetic or complex numbers, we manually handle the real and imaginary parts.
 * The amplitude is updated using fixed-point calculations.
 * 
 * The modified qubits are then copied back to user space after the operation.
 * 
 * @user_q1: User-space pointer to the first qubit struct.
 * @user_q2: User-space pointer to the second qubit struct.
 * @theta: Rotation angle in radians (fixed-point representation).
 * 
 * Returns:
 * - 0 on success.
 * - -EINVAL if either user_q1 or user_q2 is NULL (invalid input).
 * - -EFAULT if copying data to/from user space fails (memory access issues).
 */
SYSCALL_DEFINE3(nymya_3322_xx_interaction,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2,
    int64_t, theta) {

    struct nymya_qubit k_q1, k_q2;  // Kernel space qubits
    int ret;

    // Validate the user-space pointers
    if (!user_q1 || !user_q2)
        return -EINVAL;  // Return error if any of the pointers are NULL

    // Copy the qubit structs from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1)))
        return -EFAULT;  // Return error if memory copy fails

    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2)))
        return -EFAULT;  // Return error if memory copy fails

    // Call the newly created core function with kernel-space variables
    ret = nymya_3322_xx_interaction(&k_q1, &k_q2, theta);
    if (ret)
        return ret; // Propagate error from core function, if any

    // Copy the modified qubits back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1)))
        return -EFAULT;  // Return error if memory copy fails
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2)))
        return -EFAULT;  // Return error if memory copy fails

    return 0;  // Return success
}

#endif

```

---

## File: `nymya_3323_yy_interaction.c`

### Content

```c
#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3323_yy_interaction NYMYA_YY_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL

/**
 * nymya_3323_yy_interaction - Applies a YY interaction between two kernel-space qubits.
 *
 * This function encapsulates the core logic for applying a YY interaction.
 * It modifies the amplitudes of two provided kernel-space qubit structures
 * by applying a phase rotation. The phase for the first qubit is e^(i * theta)
 * and for the second qubit is its complex conjugate e^(-i * theta) to maintain symmetry.
 *
 * In kernel space, floating-point and complex number support is limited, so fixed-point math
 * is used for trigonometric calculations and complex number multiplication.
 * The amplitude of the qubits is updated manually with the real and imaginary parts
 * calculated separately using fixed-point arithmetic.
 *
 * @kq1: Pointer to the first kernel-space qubit structure (nymya_qubit).
 * @kq2: Pointer to the second kernel-space qubit structure (nymya_qubit).
 * @theta: Rotation angle in radians, represented as a fixed-point integer.
 *
 * Returns:
 * - 0 on success.
 * - This function assumes valid, non-NULL pointers are passed and does not perform
 *   validation of input pointers, as that is typically handled by the calling syscall wrapper.
 */
int nymya_3323_yy_interaction(struct nymya_qubit *kq1, struct nymya_qubit *kq2, int64_t theta) {
    // Use fixed-point math to compute the trigonometric values
    int64_t cos_val = fixed_cos(theta); // Real part of the phase
    int64_t sin_val = fixed_sin(theta); // Imaginary part of the phase

    // Calculate the real and imaginary components for the phase (e^(i*theta))
    int64_t real_phase = cos_val;
    int64_t imag_phase = sin_val;

    // Apply the YY interaction phase to the first qubit's amplitude
    // (A + Bi) * (C + Di) = (AC - BD) + i(AD + BC)
    int64_t new_re1 = kq1->amplitude.re * real_phase - kq1->amplitude.im * imag_phase;
    int64_t new_im1 = kq1->amplitude.re * imag_phase + kq1->amplitude.im * real_phase;

    // Apply the inverse phase to the second qubit's amplitude
    // This is equivalent to multiplying by conj(e^(i*theta)), i.e., (C - Di)
    // (A + Bi) * (C - Di) = (AC + BD) + i(BC - AD)
    int64_t new_re2 = kq2->amplitude.re * real_phase + kq2->amplitude.im * imag_phase;
    int64_t new_im2 = kq2->amplitude.im * real_phase - kq2->amplitude.re * imag_phase;

    // Update the amplitudes for both qubits
    kq1->amplitude.re = new_re1;
    kq1->amplitude.im = new_im1;

    kq2->amplitude.re = new_re2;
    kq2->amplitude.im = new_im2;

    // Log the symbolic event indicating the YY interaction has been applied
    log_symbolic_event("YY", kq2->id, kq2->tag, "Applied YY interaction");

    return 0; // Return success
}
EXPORT_SYMBOL_GPL(nymya_3323_yy_interaction);

#endif

/**
 * nymya_3323_yy_interaction - Applies a YY interaction between two qubits.
 * 
 * The YY interaction applies a phase rotation to two qubits in a quantum system.
 * The phase rotation is represented by a complex exponential e^(i * theta) for the first qubit
 * and its complex conjugate e^(-i * theta) for the second qubit to maintain symmetry.
 * The interaction is commonly used in quantum circuits for entanglement operations, such as in 
 * quantum gates that operate on two qubits simultaneously.
 * 
 * The function logs the interaction for traceability, and updates the amplitude of the qubits 
 * according to the applied phase.
 * 
 * @q1: Pointer to the first qubit to be rotated (nymya_qubit struct).
 * @q2: Pointer to the second qubit to be rotated (nymya_qubit struct).
 * @theta: Rotation angle in radians (double precision).
 * 
 * Returns:
 * - 0 on success (the interaction was applied successfully).
 * - -1 if either qubit pointer is NULL (invalid input).
 */
#ifndef __KERNEL__

int nymya_3323_yy_interaction(nymya_qubit* q1, nymya_qubit* q2, double theta) {
    if (!q1 || !q2) return -1;  // Check for null pointers

    // Apply the YY interaction phase e^(i * theta) for the first qubit
    _Complex double rot = cos(theta) + I * sin(theta);
    q1->amplitude *= rot;  // Apply phase to first qubit
    
    // Apply the inverse phase e^(-i * theta) for the second qubit
    q2->amplitude *= conj(rot);  // Conjugate to apply the inverse phase

    // Log the symbolic event indicating the YY interaction has been applied
    log_symbolic_event("YY", q2->id, q2->tag, "Applied YY interaction");
    return 0;  // Return success
}

#else

/**
 * SYSCALL_DEFINE3(nymya_3323_yy_interaction) - Kernel syscall for YY interaction between two qubits.
 * 
 * This syscall implements the YY interaction for two qubits in the kernel space.
 * It acts as a wrapper that copies data between user space and kernel space,
 * and then calls the core kernel function to perform the actual YY interaction logic.
 * 
 * @user_q1: User-space pointer to the first qubit struct.
 * @user_q2: User-space pointer to the second qubit struct.
 * @theta: Rotation angle in radians (fixed-point representation).
 * 
 * Returns:
 * - 0 on success.
 * - -EINVAL if either user_q1 or user_q2 is NULL (invalid input).
 * - -EFAULT if copying data to/from user space fails (memory access issues).
 */
SYSCALL_DEFINE3(nymya_3323_yy_interaction,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2,
    int64_t, theta) {

    struct nymya_qubit k_q1, k_q2;  // Kernel space qubits
    int ret;

    // Validate the user-space pointers
    if (!user_q1 || !user_q2)
        return -EINVAL;  // Return error if any of the pointers are NULL

    // Copy the qubit structs from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1)))
        return -EFAULT;  // Return error if memory copy fails

    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2)))
        return -EFAULT;  // Return error if memory copy fails

    // Call the core interaction logic
    ret = nymya_3323_yy_interaction(&k_q1, &k_q2, theta);
    if (ret) {
        // Propagate error if the core function indicates a failure,
        // though currently it is designed to always return 0.
        return ret;
    }

    // Copy the modified qubits back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1)))
        return -EFAULT;  // Return error if memory copy fails
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2)))
        return -EFAULT;  // Return error if memory copy fails

    return 0;  // Return success
}

#endif

```

---

## File: `nymya_3324_zz_interaction.c`

### Content

```c
// src/nymya_3324_zz_interaction.c

#include "nymya.h" // Provides fixed_cos, fixed_sin, and FIXED_POINT_SCALE for kernel

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3324_zz_interaction NYMYA_ZZ_CODE
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/**
 * nymya_3324_zz_interaction - Applies a ZZ interaction between two qubits (userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 * @theta: Rotation angle in radians (double).
 *
 * This applies the phase e^(i*theta) to both qubit amplitudes.
 */
int nymya_3324_zz_interaction(nymya_qubit* q1, nymya_qubit* q2, double theta) {
    if (!q1 || !q2) return -1;
    _Complex double zphase = cexp(I * theta);
    q1->amplitude *= zphase;
    q2->amplitude *= zphase;
    log_symbolic_event("ZZ", q2->id, q2->tag, "Applied ZZ phase coupling");
    return 0;
}

#else // __KERNEL__
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/errno.h>
#include <linux/module.h>
#include <linux/printk.h>

/**
 * nymya_3324_zz_interaction - Core ZZ interaction (kernel).
 * @kq1: First kernel-space qubit.
 * @kq2: Second kernel-space qubit.
 * @theta: Angle in fixed-point.
 */
int nymya_3324_zz_interaction(struct nymya_qubit *kq1,
                              struct nymya_qubit *kq2,
                              int64_t theta) {
    int64_t cos_val = fixed_cos(theta);
    int64_t sin_val = fixed_sin(theta);

    // Compute and apply phase for first qubit
    int64_t real1 = (kq1->amplitude.re * cos_val - kq1->amplitude.im * sin_val) / FIXED_POINT_SCALE;
    int64_t imag1 = (kq1->amplitude.re * sin_val + kq1->amplitude.im * cos_val) / FIXED_POINT_SCALE;
    kq1->amplitude.re = real1;
    kq1->amplitude.im = imag1;

    // Compute and apply phase for second qubit
    int64_t real2 = (kq2->amplitude.re * cos_val - kq2->amplitude.im * sin_val) / FIXED_POINT_SCALE;
    int64_t imag2 = (kq2->amplitude.re * sin_val + kq2->amplitude.im * cos_val) / FIXED_POINT_SCALE;
    kq2->amplitude.re = real2;
    kq2->amplitude.im = imag2;

    log_symbolic_event("ZZ", kq2->id, kq2->tag, "Applied ZZ phase coupling");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3324_zz_interaction);

/**
 * SYSCALL_DEFINE3(nymya_3324_zz_interaction) - Kernel syscall for ZZ interaction.
 */
SYSCALL_DEFINE3(nymya_3324_zz_interaction,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2,
    int64_t, theta) {

    struct nymya_qubit k1, k2;
    if (!user_q1 || !user_q2) return -EINVAL;
    if (copy_from_user(&k1, user_q1, sizeof(k1))) return -EFAULT;
    if (copy_from_user(&k2, user_q2, sizeof(k2))) return -EFAULT;

    int ret = nymya_3324_zz_interaction(&k1, &k2, theta);
    if (ret) return ret;

    if (copy_to_user(user_q1, &k1, sizeof(k1))) return -EFAULT;
    if (copy_to_user(user_q2, &k2, sizeof(k2))) return -EFAULT;
    return 0;
}
#endif // __KERNEL__


```

---

## File: `nymya_3325_xyz_entangle.c`

### Content

```c
#include "nymya.h" // Include the header file for definitions

// Note: The actual implementations for fixed_cos, fixed_sin, and log_symbolic_event
// are assumed to be provided elsewhere, as they are declared in nymya.h but not defined here.

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>

#define __NR_nymya_3325_xyz_entangle NYMYA_XYZ_CODE

/**
 * nymya_3325_xyz_entangle - Applies an XX+YY+ZZ entanglement operation to two qubits (userland version).
 *
 * This function performs a full XX+YY+ZZ type entanglement operation between two qubits
 * in user space. It applies a rotation to the amplitudes of both qubits using a complex
 * number derived from the given angle 'theta'. The first qubit's amplitude is multiplied
 * by the rotation complex number, and the second qubit's amplitude is multiplied by the
 * conjugate of the rotation complex number.
 *
 * The function logs the event symbolically for traceability.
 *
 * @q1: Pointer to the first qubit (nymya_qubit struct).
 * @q2: Pointer to the second qubit (nymya_qubit struct).
 * @theta: Entanglement angle in radians.
 *
 * Returns:
 * - 0 on success.
 * - -1 if either qubit pointer is NULL (invalid input).
 */
int nymya_3325_xyz_entangle(nymya_qubit* q1, nymya_qubit* q2, double theta) {
    // Basic null pointer check
    if (!q1 || !q2) return -1;

    // In userspace, we use native double precision complex numbers and math functions.
    // The fixed_cos and fixed_sin are kernel-specific.
    // We'll use standard C complex math for userspace.
    // Note: The nymya.h defines make_complex, complex_mul, complex_conj for userspace
    // using _Complex double and standard math functions.

    // Construct the rotation complex number e^(i*theta)
    complex_double rot = complex_exp_i(theta); // Uses cexp(I * theta) in userspace

    // Apply the rotation to the qubit amplitudes
    q1->amplitude = complex_mul(q1->amplitude, rot);
    q2->amplitude = complex_mul(q2->amplitude, complex_conj(rot));

    // Log the symbolic event (assumed to be implemented for userspace as well)
    log_symbolic_event("XYZ", q1->id, q1->tag, "Full XX+YY+ZZ entanglement");
    return 0;
}

#else // __KERNEL__
    #include <linux/module.h>


// Kernel-specific includes, only compiled when __KERNEL__ is defined
#include <linux/uaccess.h> // Required for copy_from_user, copy_to_user
#include <linux/syscalls.h> // Required for SYSCALL_DEFINE macros
#include <linux/printk.h>   // Required for pr_err

/**
 * @brief Kernel-side core logic for XX+YY+ZZ entanglement.
 *
 * This function applies a full XX+YY+ZZ type entanglement operation between two
 * qubits in kernel space. It performs fixed-point trigonometric calculations
 * to construct a rotation complex number, applies this rotation to the
 * amplitudes of both qubits (multiplying the first by the rotation and the
 * second by its conjugate), and logs the event.
 *
 * @param k_q1 Pointer to the first qubit (kernel-space nymya_qubit struct).
 * @param k_q2 Pointer to the second qubit (kernel-space nymya_qubit struct).
 * @param fixed_theta Entanglement angle in Q32.32 fixed-point format.
 * @return 0 on success.
 */
int nymya_3325_xyz_entangle(struct nymya_qubit *k_q1, struct nymya_qubit *k_q2, int64_t fixed_theta) {
    // 1. Perform fixed-point trigonometric calculations and complex number construction
    // fixed_theta is already in fixed-point format, so no conversion from double is needed here.
    int64_t fixed_cos_val = fixed_cos(fixed_theta);
    int64_t fixed_sin_val = fixed_sin(fixed_theta);

    // Construct the rotation complex number (fixed-point representation)
    // using the make_complex function defined in nymya.h.
    // This now directly takes fixed-point int64_t values, removing floating-point usage.
    complex_double rot = make_complex(fixed_cos_val, fixed_sin_val);

    // 2. Apply the rotation to the qubit amplitudes
    k_q1->amplitude = complex_mul(k_q1->amplitude, rot);
    k_q2->amplitude = complex_mul(k_q2->amplitude, complex_conj(rot));

    // 3. Log the symbolic event for the entanglement
    // Assumes log_symbolic_event is available in kernel context
    log_symbolic_event("XYZ", k_q1->id, k_q1->tag, "Full XX+YY+ZZ entanglement");

    return 0; // Return 0 on success, as core logic is assumed to always succeed given valid inputs
}
EXPORT_SYMBOL_GPL(nymya_3325_xyz_entangle);



/**
 * nymya_3325_xyz_entangle - Applies an XX+YY+ZZ entanglement operation to two qubits (kernel version).
 *
 * This system call performs a full XX+YY+ZZ type entanglement operation between two qubits.
 * It copies the qubit structures from user space to kernel space, performs fixed-point
 * trigonometric calculations to construct a rotation complex number, applies this rotation
 * to the amplitudes of both qubits (multiplying the first by the rotation and the second
 * by its conjugate), and then copies the modified qubits back to user space.
 *
 * Error handling includes checks for null user pointers and failures during data copy
 * between user and kernel space. The operation is logged symbolically for debugging
 * and traceability.
 *
 * @user_q1: Pointer to the first qubit in user space (nymya_qubit struct).
 * @user_q2: Pointer to the second qubit in user space (nymya_qubit struct).
 * @fixed_theta: Entanglement angle in Q32.32 fixed-point format.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if either user_q1 or user_q2 is NULL.
 * - -EFAULT if copying data between user and kernel space fails.
 */
SYSCALL_DEFINE3(
    nymya_3325_xyz_entangle,
    struct nymya_qubit __user *, user_q1, // Pointer to user-space qubit 1
    struct nymya_qubit __user *, user_q2, // Pointer to user-space qubit 2
    int64_t, fixed_theta                  // Angle for entanglement, now fixed-point
) {
    struct nymya_qubit k_q1, k_q2; // Kernel-space copies of qubits
    int ret = 0; // Return value for syscall

    // 1. Check for null pointers from user-space
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3325_xyz_entangle: Null user qubit pointer(s)\n");
        return -EINVAL; // Invalid argument
    }

    // 2. Copy the qubit structures from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3325_xyz_entangle: Failed to copy k_q1 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3325_xyz_entangle: Failed to copy k_q2 from user\n");
        return -EFAULT; // Bad address
    }

    // 3. Call the extracted core logic function
    // The core function modifies k_q1 and k_q2 in place.
    // Currently, it always returns 0, but could be extended to return errors.
    nymya_3325_xyz_entangle(&k_q1, &k_q2, fixed_theta);

    // 4. Copy the modified qubits back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3325_xyz_entangle: Failed to copy k_q1 to user\n");
        ret = -EFAULT; // Bad address
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3325_xyz_entangle: Failed to copy k_q2 to user\n");
        ret = -EFAULT; // Bad address
    }

    return ret; // Return 0 on success, or error code if any copy_to_user failed
}

#endif

```

---

## File: `nymya_3326_sqrt_swap.c`

### Content

```c
// src/nymya_3326_sqrt_swap.c

#include "nymya.h" // Includes complex_double and fixed-point scale

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3326_sqrt_swap NYMYA_SQRT_SWAP_CODE

    #include <stdlib.h>
    #include <math.h>
    #include <complex.h> // For _Complex double and I in userland
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/slab.h> // Required for kmalloc_array if used in other syscalls
    #include <linux/types.h> // For __int128 or other kernel types
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel
#endif

#ifndef __KERNEL__

/**
 * nymya_3326_sqrt_swap - Applies the square root of SWAP gate to two qubits (userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 *
 * This function applies the √SWAP gate, which entangles two qubits.
 * It uses standard C complex numbers for calculation.
 *
 * Returns:
 * - 0 on success.
 * - -1 if either qubit pointer is NULL.
 */
int nymya_3326_sqrt_swap(nymya_qubit* q1, nymya_qubit* q2) {
    if (!q1 || !q2) return -1;

    // In userland, assume nymya_qubit->amplitude is directly _Complex double.
    // No conversion from fixed-point struct is needed here.
    _Complex double a = q1->amplitude;
    _Complex double b = q2->amplitude;

    // Apply the √SWAP gate transformation
    _Complex double new_a = 0.5 * (a + b + I * (a - b));
    _Complex double new_b = 0.5 * (a + b - I * (a - b));

    // Assign the new complex amplitudes directly back to the qubits.
    q1->amplitude = new_a;
    q2->amplitude = new_b;

    log_symbolic_event("SQRT_SWAP", q1->id, q1->tag, "√SWAP applied");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3326_sqrt_swap - Applies the square root of SWAP gate to two qubits (kernel-side).
 * @kq1: Pointer to the first qubit in kernel space.
 * @kq2: Pointer to the second qubit in kernel space.
 *
 * This function applies the √SWAP gate using fixed-point complex arithmetic.
 * It operates directly on kernel-space qubit structures.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any kernel qubit pointer is NULL.
 */
int nymya_3326_sqrt_swap(struct nymya_qubit *kq1, struct nymya_qubit *kq2) {
    if (!kq1 || !kq2) {
        pr_err("nymya_3326_sqrt_swap (core): Invalid kernel qubit pointers\n");
        return -EINVAL; // Should not happen if called correctly from SYSCALL, but good for robustness
    }

    // Perform √SWAP gate transformation using fixed-point arithmetic
    // Let a = kq1->amplitude and b = kq2->amplitude
    // New amplitudes:
    // q1_new = 0.5 * (a + b + i * (a - b))
    // q2_new = 0.5 * (a + b - i * (a - b))

    // Calculate (a + b)
    complex_double sum_amplitude;
    sum_amplitude.re = kq1->amplitude.re + kq2->amplitude.re;
    sum_amplitude.im = kq1->amplitude.im + kq2->amplitude.im;

    // Calculate (a - b)
    complex_double diff_amplitude;
    diff_amplitude.re = kq1->amplitude.re - kq2->amplitude.re;
    diff_amplitude.im = kq1->amplitude.im - kq2->amplitude.im;

    // Calculate i * (a - b)
    // If X = X_re + iX_im, then iX = -X_im + iX_re
    complex_double i_times_diff;
    i_times_diff.re = -diff_amplitude.im;
    i_times_diff.im = diff_amplitude.re;

    // Calculate (a + b + i * (a - b)) and divide by 2
    kq1->amplitude.re = (sum_amplitude.re + i_times_diff.re) >> 1;
    kq1->amplitude.im = (sum_amplitude.im + i_times_diff.im) >> 1;

    // Calculate (a + b - i * (a - b)) and divide by 2
    kq2->amplitude.re = (sum_amplitude.re - i_times_diff.re) >> 1;
    kq2->amplitude.im = (sum_amplitude.im - i_times_diff.im) >> 1;

    // Log the symbolic event
    log_symbolic_event("SQRT_SWAP", kq1->id, kq1->tag, "√SWAP applied");

    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3326_sqrt_swap);



/**
 * __do_sys_nymya_3326_sqrt_swap - Kernel system call implementation for √SWAP gate.
 * @user_q1: Pointer to the first qubit structure in user space.
 * @user_q2: Pointer to the second qubit structure in user space.
 *
 * This function copies qubit data from user space, applies the √SWAP gate
 * using fixed-point complex arithmetic, and then copies the modified data back.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 */
SYSCALL_DEFINE2(nymya_3326_sqrt_swap,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_q1, k_q2; // Kernel-space copies of qubits
    int ret = 0;

    // 1. Validate user pointers
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3326_sqrt_swap: Invalid user qubit pointers\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3326_sqrt_swap: Failed to copy k_q1 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3326_sqrt_swap: Failed to copy k_q2 from user space\n");
        return -EFAULT;
    }

    // Call the core logic function
    ret = nymya_3326_sqrt_swap(&k_q1, &k_q2);
    if (ret) {
        pr_err("nymya_3326_sqrt_swap: Core logic failed with error %d\n", ret);
        return ret; // Propagate error from core function
    }

    // 3. Copy modified qubit data back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3326_sqrt_swap: Failed to copy k_q1 to user space\n");
        return -EFAULT;
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3326_sqrt_swap: Failed to copy k_q2 to user space\n");
        return -EFAULT;
    }

    return 0; // Success
}

#endif

```

---

## File: `nymya_3327_sqrt_iswap.c`

### Content

```c
// src/nymya_3327_sqrt_iswap.c

#include "nymya.h" // Includes complex_double and fixed-point scale, and now FIXED_POINT_SQRT2_INV_FP

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3327_sqrt_iswap NYMYA_SQRT_ISWAP_CODE

    #include <stdlib.h>
    #include <math.h>
    #include <complex.h> // For _Complex double and I in userland
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/slab.h> // Required for kmalloc_array if used in other syscalls
    #include <linux/types.h> // For __int128 or other kernel types
    #include <linux/module.h> // ADDED: Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel
#endif

#ifndef __KERNEL__

/**
 * nymya_3327_sqrt_iswap - Applies the square root of iSWAP gate to two qubits (userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 *
 * This function applies the √iSWAP gate, which entangles two qubits.
 * It uses standard C complex numbers for calculation.
 *
 * Returns:
 * - 0 on success.
 * - -1 if either qubit pointer is NULL.
 */
int nymya_3327_sqrt_iswap(nymya_qubit* q1, nymya_qubit* q2) {
    if (!q1 || !q2) return -1;

    // In userland, assume nymya_qubit->amplitude is directly _Complex double.
    // No conversion from fixed-point struct is needed here.
    _Complex double a = q1->amplitude;
    _Complex double b = q2->amplitude;

    // Apply the √iSWAP gate transformation
    _Complex double new_a = (a + I * b) / sqrt(2.0);
    _Complex double new_b = (b + I * a) / sqrt(2.0);

    // Assign the new complex amplitudes directly back to the qubits.
    q1->amplitude = new_a;
    q2->amplitude = new_b;

    log_symbolic_event("√iSWAP", q2->id, q2->tag, "√iSWAP applied");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3327_sqrt_iswap - Core kernel function for Square Root iSWAP gate.
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 *
 * This function applies the √iSWAP gate transformation to two qubits
 * using fixed-point complex arithmetic. This function is designed to be called
 * directly by other kernel code.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any qubit pointer is NULL.
 */
int nymya_3327_sqrt_iswap(struct nymya_qubit *q1, struct nymya_qubit *q2) {
    complex_double term1;
    complex_double term2;
    complex_double scalar_factor = make_complex(FIXED_POINT_SQRT2_INV_FP, 0);

    // 1. Validate kernel qubit pointers
    if (!q1 || !q2) {
        pr_err("nymya_3327_sqrt_iswap: Invalid kernel qubit pointers\n");
        return -EINVAL;
    }

    // Perform √iSWAP gate transformation using fixed-point arithmetic
    // New amplitudes:
    // q1_new = (a + i * b) / sqrt(2.0)
    // q2_new = (b + i * a) / sqrt(2.0)

    // Calculate (a + i * b)
    // If X = X_re + iX_im, then iX = -X_im + iX_re
    // So, i * b = -b.im + i * b.re
    // (a + i * b).re = a.re - b.im
    // (a + i * b).im = a.im + b.re
    term1.re = q1->amplitude.re - q2->amplitude.im;
    term1.im = q1->amplitude.im + q2->amplitude.re;

    // Calculate (b + i * a)
    // So, i * a = -a.im + i * a.re
    // (b + i * a).re = b.re - a.im
    // (b + i * a).im = b.im + a.re
    term2.re = q2->amplitude.re - q1->amplitude.im;
    term2.im = q2->amplitude.im + q1->amplitude.re;

    // Divide by sqrt(2.0) by multiplying with 1/sqrt(2) in fixed-point
    // Use complex_mul for scalar multiplication of complex numbers
    q1->amplitude = complex_mul(term1, scalar_factor);
    q2->amplitude = complex_mul(term2, scalar_factor);

    // Log the symbolic event
    log_symbolic_event("√iSWAP", q2->id, q2->tag, "√iSWAP applied");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3327_sqrt_iswap);



// Export the symbol for this function so other kernel modules/code can call it directly.


/**
 * SYSCALL_DEFINE2(nymya_3327_sqrt_iswap) - Kernel system call implementation for √iSWAP gate.
 * @user_q1: Pointer to the first qubit structure in user space.
 * @user_q2: Pointer to the second qubit structure in user space.
 *
 * This is the syscall entry point that wraps the core nymya_3327_sqrt_iswap function.
 * It handles user-space copy operations before and after calling the core logic.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 */
SYSCALL_DEFINE2(nymya_3327_sqrt_iswap,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_q1, k_q2; // Kernel-space copies of qubits
    int ret;

    // 1. Validate user pointers
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3327_sqrt_iswap: Invalid user qubit pointers\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3327_sqrt_iswap: Failed to copy k_q1 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3327_sqrt_iswap: Failed to copy k_q2 from user space\n");
        return -EFAULT;
    }

    // Call the core logic function defined above
    ret = nymya_3327_sqrt_iswap(&k_q1, &k_q2);

    if (ret) // If the core function returned an error, propagate it
        return ret;

    // 3. Copy modified qubit data back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3327_sqrt_iswap: Failed to copy k_q1 to user space\n");
        return -EFAULT;
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3327_sqrt_iswap: Failed to copy k_q2 to user space\n");
        return -EFAULT;
    }

    return 0; // Success
}

#endif


```

---

## File: `nymya_3328_swap_pow.c`

### Content

```c
// src/nymya_3328_swap_pow.c

#include "nymya.h" // Includes complex_double, FIXED_POINT_SCALE

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3328_swap_pow NYMYA_SWAP_POW_CODE

    #include <stdlib.h>
    #include <math.h>
    #include <complex.h> // For _Complex double and I in userland
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/slab.h> // Required for kmalloc_array if used in other syscalls
    #include <linux/types.h> // For __int128 or other kernel types
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel
#endif

// Define PI and PI/2 in fixed-point for kernel calculations if not already in nymya.h
// These are now defined in nymya.h and should not be redefined here.
// #ifndef FIXED_POINT_PI
// #define FIXED_POINT_PI (int64_t)(3.141592653589793 * FIXED_POINT_SCALE)
// #endif

// #ifndef FIXED_POINT_PI_DIV_2
// #define FIXED_POINT_PI_DIV_2 (int64_t)(1.5707963267948966 * FIXED_POINT_SCALE) // M_PI / 2.0
// #endif

#ifndef __KERNEL__

/**
 * nymya_3328_swap_pow - Applies an interpolated SWAP^alpha gate to two qubits (userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 * @alpha: The interpolation parameter (0 for identity, 1 for SWAP).
 *
 * This function applies a generalized SWAP gate with an interpolation parameter alpha.
 * It uses standard C complex numbers and floating-point math for calculation.
 *
 * Returns:
 * - 0 on success.
 * - -1 if either qubit pointer is NULL.
 */
int nymya_3328_swap_pow(nymya_qubit* q1, nymya_qubit* q2, double alpha) {
    if (!q1 || !q2) return -1;

    // In userland, assume nymya_qubit->amplitude is directly _Complex double.
    // No conversion from fixed-point struct is needed here.
    _Complex double a = q1->amplitude;
    _Complex double b = q2->amplitude;

    // Calculate cosine and sine components for the interpolation
    double angle = alpha * M_PI / 2.0;
    double c = cos(angle);
    double s = sin(angle);

    // Apply the interpolated SWAP gate transformation
    _Complex double new_a = c * a + s * b;
    _Complex double new_b = c * b + s * a;

    // Assign the new complex amplitudes directly back to the qubits.
    q1->amplitude = new_a;
    q2->amplitude = new_b;

    log_symbolic_event("SWAP^α", q1->id, q1->tag, "Interpolated SWAP applied");
    return 0;
}

#else // __KERNEL__

/**
 * @brief Applies an interpolated SWAP^alpha gate to two qubits in kernel space.
 *
 * This function performs the core logic of the SWAP^alpha gate on two qubits
 * using fixed-point complex arithmetic. It modifies the amplitudes of the
 * provided kernel-space qubit structures directly.
 *
 * @param kq1 Pointer to the first qubit structure in kernel space.
 * @param kq2 Pointer to the second qubit structure in kernel space.
 * @param alpha_fp The interpolation parameter 'alpha' in fixed-point format.
 *                 (0 for identity, FIXED_POINT_SCALE for SWAP).
 * @return 0 on success.
 */
int nymya_3328_swap_pow(struct nymya_qubit *kq1, struct nymya_qubit *kq2, int64_t alpha_fp) {
    // Calculate fixed-point angle: alpha * (PI / 2)
    int64_t angle_fp = fixed_point_mul(alpha_fp, FIXED_POINT_PI_DIV_2);

    // Calculate fixed-point cosine and sine values using wrappers from nymya.h
    int64_t c_fp = fixed_cos(angle_fp);
    int64_t s_fp = fixed_sin(angle_fp);

    // Get current amplitudes in fixed-point complex_double format
    complex_double a = kq1->amplitude;
    complex_double b = kq2->amplitude;

    // Apply the interpolated SWAP gate transformation using fixed-point complex arithmetic
    // new_a = c * a + s * b
    // new_a.re = (c.re * a.re - c.im * a.im) + (s.re * b.re - s.im * b.im)
    // new_a.im = (c.re * a.im + c.im * a.re) + (s.re * b.im + s.im * b.re)
    // Since c and s are real, c.im = 0 and s.im = 0
    // new_a.re = c_fp * a.re + s_fp * b.re (scaled)
    // new_a.im = c_fp * a.im + s_fp * b.im (scaled)
    kq1->amplitude.re = fixed_point_mul(c_fp, a.re) + fixed_point_mul(s_fp, b.re);
    kq1->amplitude.im = fixed_point_mul(c_fp, a.im) + fixed_point_mul(s_fp, b.im);

    // new_b = c * b + s * a
    kq2->amplitude.re = fixed_point_mul(c_fp, b.re) + fixed_point_mul(s_fp, a.re);
    kq2->amplitude.im = fixed_point_mul(c_fp, b.im) + fixed_point_mul(s_fp, a.im);

    // Log the symbolic event
    log_symbolic_event("SWAP^α", kq1->id, kq1->tag, "Interpolated SWAP applied");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3328_swap_pow);



/**
 * __do_sys_nymya_3328_swap_pow - Kernel system call implementation for SWAP^alpha gate.
 * @user_q1: Pointer to the first qubit structure in user space.
 * @user_q2: Pointer to the second qubit structure in user space.
 * @alpha_fp: The interpolation parameter 'alpha' in fixed-point format.
 *
 * This function copies qubit data from user space, applies the SWAP^alpha gate
 * using fixed-point complex arithmetic, and then copies the modified data back.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 */
SYSCALL_DEFINE3(nymya_3328_swap_pow,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2,
    int64_t, alpha_fp) { // alpha is now fixed-point

    struct nymya_qubit k_q1, k_q2; // Kernel-space copies of qubits

    // 1. Validate user pointers
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3328_swap_pow: Invalid user qubit pointers\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3328_swap_pow: Failed to copy k_q1 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3328_swap_pow: Failed to copy k_q2 from user space\n");
        return -EFAULT;
    }

    // Call the core logic function
    nymya_3328_swap_pow(&k_q1, &k_q2, alpha_fp);

    // 3. Copy modified qubit data back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3328_swap_pow: Failed to copy k_q1 to user space\n");
        return -EFAULT;
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3328_swap_pow: Failed to copy k_q2 to user space\n");
        return -EFAULT;
    }

    return 0; // Success
}

#endif

```

---

## File: `nymya_3329_fredkin.c`

### Content

```c
// src/nymya_3329_fredkin.c

#include "nymya.h" // Includes complex_double and FIXED_POINT_SCALE

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3329_fredkin NYMYA_FREDKIN_CODE

    #include <stdlib.h>
    #include <math.h>
    #include <complex.h> // For _Complex double and cabs in userland
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/slab.h> // Required for kmalloc_array if used in other syscalls
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel
#endif

#ifndef __KERNEL__

/**
 * nymya_3329_fredkin - Applies a Fredkin (Controlled-SWAP) gate to three qubits (userland).
 * @q_ctrl: Pointer to the control qubit.
 * @q1: Pointer to the first target qubit.
 * @q2: Pointer to the second target qubit.
 *
 * This function implements a Fredkin gate. If the control qubit's amplitude
 * magnitude squared is above a threshold (representing a '1' state), it swaps
 * the amplitudes of the two target qubits. Otherwise, no action is taken.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL.
 */
int nymya_3329_fredkin(nymya_qubit* q_ctrl, nymya_qubit* q1, nymya_qubit* q2) {
    if (!q_ctrl || !q1 || !q2) return -1;

    // In userland, q_ctrl->amplitude is _Complex double.
    // Calculate the magnitude squared directly using cabs().
    double ctrl_mag_sq = cabs(q_ctrl->amplitude) * cabs(q_ctrl->amplitude);

    // Define the threshold for control qubit being '1' (0.5^2 = 0.25)
    const double threshold_sq = 0.25;

    // If the control qubit's amplitude magnitude squared is above the threshold, perform SWAP
    if (ctrl_mag_sq > threshold_sq) {
        _Complex double temp = q1->amplitude; // Use _Complex double for temp
        q1->amplitude = q2->amplitude;
        q2->amplitude = temp;

        log_symbolic_event("FREDKIN", q1->id, q1->tag, "Control triggered SWAP");
    } else {
        log_symbolic_event("FREDKIN", q1->id, q1->tag, "Control = 0, no action");
    }

    return 0;
}

#else // __KERNEL__

/**
 * nymya_3329_fredkin - Applies a Fredkin (Controlled-SWAP) gate to three qubits (kernel-side core logic).
 * @k_q_ctrl: Pointer to the control qubit in kernel space. Read-only.
 * @k_q1: Pointer to the first target qubit in kernel space. Modified if control triggered.
 * @k_q2: Pointer to the second target qubit in kernel space. Modified if control triggered.
 *
 * This function implements the core Fredkin gate logic in kernel space using fixed-point
 * complex arithmetic. If the control qubit's amplitude magnitude squared is above a
 * threshold (representing a '1' state), it swaps the amplitudes of the two target qubits.
 * Otherwise, no action is taken.
 *
 * Returns:
 * - 0 on success.
 * - (No explicit error paths currently, as input pointers are assumed valid kernel addresses).
 */
int nymya_3329_fredkin(struct nymya_qubit *k_q_ctrl,
                       struct nymya_qubit *k_q1,
                       struct nymya_qubit *k_q2) {
    // Calculate the squared magnitude of the control qubit's amplitude in fixed-point
    int64_t ctrl_mag_sq_fp = k_q_ctrl->amplitude.re * k_q_ctrl->amplitude.re +
                             k_q_ctrl->amplitude.im * k_q_ctrl->amplitude.im;

    // Define the threshold for control qubit being '1' (0.5^2 = 0.25 in floating point)
    // Convert 0.25 to fixed-point squared value
    const int64_t threshold_sq_fp = (int64_t)(0.25 * FIXED_POINT_SCALE * FIXED_POINT_SCALE);

    // If the control qubit's amplitude magnitude squared is above the threshold, perform SWAP
    if (ctrl_mag_sq_fp > threshold_sq_fp) {
        complex_double temp = k_q1->amplitude; // Use complex_double for temp
        k_q1->amplitude = k_q2->amplitude;
        k_q2->amplitude = temp;

        log_symbolic_event("FREDKIN", k_q1->id, k_q1->tag, "Control triggered SWAP");
    } else {
        log_symbolic_event("FREDKIN", k_q1->id, k_q1->tag, "Control = 0, no action");
    }

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3329_fredkin);



/**
 * __do_sys_nymya_3329_fredkin - Kernel system call implementation for Fredkin gate.
 * @user_q_ctrl: Pointer to the control qubit structure in user space.
 * @user_q1: Pointer to the first target qubit structure in user space.
 * @user_q2: Pointer to the second target qubit structure in user space.
 *
 * This function copies qubit data from user space, applies the Fredkin gate
 * using fixed-point complex arithmetic (via the internal core function),
 * and then copies the modified data back.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from the core logic if it fails (not currently expected for this gate).
 */
SYSCALL_DEFINE3(nymya_3329_fredkin,
    struct nymya_qubit __user *, user_q_ctrl,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_q_ctrl, k_q1, k_q2; // Kernel-space copies of qubits
    int ret;

    // 1. Validate user pointers
    if (!user_q_ctrl || !user_q1 || !user_q2) {
        pr_err("nymya_3329_fredkin: Invalid user qubit pointers\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_q_ctrl, user_q_ctrl, sizeof(k_q_ctrl))) {
        pr_err("nymya_3329_fredkin: Failed to copy k_q_ctrl from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3329_fredkin: Failed to copy k_q1 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3329_fredkin: Failed to copy k_q2 from user space\n");
        return -EFAULT;
    }

    // Call the core Fredkin gate logic function
    ret = nymya_3329_fredkin(&k_q_ctrl, &k_q1, &k_q2);
    if (ret) {
        pr_err("nymya_3329_fredkin: Core logic failed with error %d\n", ret);
        return ret;
    }

    // 3. Copy modified qubit data back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3329_fredkin: Failed to copy k_q1 to user space\n");
        return -EFAULT;
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3329_fredkin: Failed to copy k_q2 to user space\n");
        return -EFAULT;
    }
    // No need to copy k_q_ctrl back if it's only read and not modified.

    return 0; // Success
}

#endif

```

---

## File: `nymya_3330_rotate.c`

### Content

```c
// src/nymya_3330_rotate.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#define __NR_nymya_3330_rotate NYMYA_ROTATE_CODE

    #include <stdio.h>
    #include <stdlib.h>
    #include <math.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/slab.h> // Required for kmalloc_array if used in other syscalls
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
    // No math.h in kernel; fixed-point math assumed for angle
#endif

#ifndef __KERNEL__

/**
 * nymya_3330_rotate - Applies a rotation gate to a single qubit around a specified axis (userland).
 * @q: Pointer to the qubit to rotate.
 * @axis: The axis of rotation ('X', 'Y', or 'Z', case-insensitive).
 * @theta: The angle of rotation in radians.
 *
 * This function acts as a wrapper, calling the appropriate single-qubit rotation
 * gate (Rx, Ry, or Rz) based on the specified axis.
 *
 * Returns:
 * - 0 on success.
 * - -1 if the qubit pointer is NULL or an unknown axis is specified.
 */
int nymya_3330_rotate(nymya_qubit* q, char axis, double theta) {
    if (!q) return -1;

    switch (axis) {
        case 'X':
        case 'x':
            nymya_3319_rotate_x(q, theta);
            break;
        case 'Y':
        case 'y':
            nymya_3320_rotate_y(q, theta);
            break;
        case 'Z':
        case 'z':
            nymya_3321_rotate_z(q, theta);
            break;
        default:
            log_symbolic_event("ROTATE", q->id, q->tag, "Unknown axis");
            return -1;
    }

    log_symbolic_event("ROTATE", q->id, q->tag, "Axis rotation applied");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3330_rotate - Core kernel logic for applying a rotation gate to a single qubit.
 * @kq: Pointer to the kernel-space qubit structure to be rotated.
 * @axis: The axis of rotation ('X', 'Y', or 'Z', case-insensitive).
 * @theta_fp: The angle of rotation in fixed-point format.
 *
 * This function dispatches to the appropriate fixed-point rotation function
 * based on the specified axis. It operates directly on a kernel-space qubit
 * structure.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if an unknown axis is specified.
 * - An error code from the underlying rotation function (e.g., nymya_3319_rotate_x)
 *   if the rotation itself encounters an issue.
 */
int nymya_3330_rotate(struct nymya_qubit *kq, char axis, int64_t theta_fp) {
    int ret = 0;

    // Dispatch to the appropriate fixed-point rotation function
    switch (axis) {
        case 'X':
        case 'x':
            // Call the kernel version of rotate_x with fixed-point theta
            ret = nymya_3319_rotate_x(kq, theta_fp);
            break;
        case 'Y':
        case 'y':
            // Call the kernel version of rotate_y with fixed-point theta
            ret = nymya_3320_rotate_y(kq, theta_fp);
            break;
        case 'Z':
        case 'z':
            // Call the kernel version of rotate_z with fixed-point theta
            ret = nymya_3321_rotate_z(kq, theta_fp);
            break;
        default:
            // Log error for unknown axis and return invalid argument error
            log_symbolic_event("ROTATE", kq->id, kq->tag, "Unknown axis");
            pr_err("nymya_3330_rotate_core: Unknown axis specified: %c\n", axis);
            return -EINVAL;
    }

    // Log success or error from underlying rotation function
    if (ret == 0) {
        log_symbolic_event("ROTATE", kq->id, kq->tag, "Axis rotation applied");
    } else {
        // If an error occurred in the underlying rotation function, log it
        pr_err("nymya_3330_rotate_core: Underlying rotation function failed with error %d\n", ret);
    }

    return ret;
}
EXPORT_SYMBOL_GPL(nymya_3330_rotate);


/**
 * __do_sys_nymya_3330_rotate - Kernel system call implementation for single-qubit rotation.
 * @user_q: Pointer to the qubit structure in user space.
 * @axis: The axis of rotation ('X', 'Y', or 'Z', case-insensitive).
 * @theta_fp: The angle of rotation in fixed-point format.
 *
 * This function copies qubit data from user space, dispatches to the appropriate
 * fixed-point rotation function based on the axis, and then copies the modified
 * data back to user space.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if the user qubit pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from the core rotation function (e.g., -EINVAL for unknown axis).
 */
SYSCALL_DEFINE3(nymya_3330_rotate,
    struct nymya_qubit __user *, user_q,
    char, axis,
    int64_t, theta_fp) { // Changed theta to fixed-point (int64_t)

    struct nymya_qubit k_q; // Kernel-space copy of the qubit
    int ret = 0; // Return value for the core rotation function

    // 1. Validate user pointer
    if (!user_q) {
        pr_err("nymya_3330_rotate: Invalid user qubit pointer\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_q, user_q, sizeof(k_q))) {
        pr_err("nymya_3330_rotate: Failed to copy k_q from user space\n");
        return -EFAULT;
    }

    // 3. Call the core rotation logic
    ret = nymya_3330_rotate(&k_q, axis, theta_fp);

    // 4. Copy modified qubit data back to user space
    if (copy_to_user(user_q, &k_q, sizeof(k_q))) {
        pr_err("nymya_3330_rotate: Failed to copy k_q to user space\n");
        return -EFAULT;
    }

    return ret; // Return the result of the core rotation function
}

#endif

```

---

## File: `nymya_3331_barenco.c`

### Content

```c
// src/nymya_3331_barenco.c

#include "nymya.h"

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>
#define __NR_nymya_3331_barenco NYMYA_BARENCO_CODE

    #include <stdlib.h> // Only for userland
    #include <math.h>
    #include <complex.h>
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/types.h> // For __int128 or other kernel types
    #include <linux/slab.h> // For kmalloc_array if needed by other functions
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/**
 * nymya_3331_barenco - Applies a Barenco (Controlled-Controlled-Controlled-NOT) gate to three qubits (userland).
 * @q1: Pointer to the first control qubit.
 * @q2: Pointer to the second control qubit.
 * @q3: Pointer to the third target qubit.
 *
 * This function implements a Barenco gate, which is a generalized Toffoli gate.
 * It flips the state of @q3 if @q1 and @q2 are both in the |1> state.
 * This is a composite gate typically implemented as H-CNOT-S-CNOT-H.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL.
 */
int nymya_3331_barenco(nymya_qubit* q1, nymya_qubit* q2, nymya_qubit* q3) {
    if (!q1 || !q2 || !q3) return -1;

    // Barenco-style 3-qubit composite (H–CNOT–S–CNOT–H)
    // Note: This decomposition is for a specific type of controlled-controlled-NOT.
    // The exact decomposition may vary based on the desired universal gate set.
    // Assuming these sub-gates are implemented for userland.
    nymya_3308_hadamard_gate(q3);
    nymya_3309_controlled_not(q2, q3);
    nymya_3306_phase_gate(q3); // This is typically an S gate (Phase(pi/2))
    nymya_3309_controlled_not(q1, q3);
    nymya_3308_hadamard_gate(q3);

    log_symbolic_event("BARENCO", q1->id, q1->tag, "Barenco composite applied");
    return 0;
}

#else // __KERNEL__

// Fixed-point helper functions (fixed_point_mul) are now defined as static inline in nymya.h
// and should NOT be redefined here.

// Assuming fixed_point_cos and fixed_point_sin are defined in nymya.h or another included kernel header.
// If not, they would need to be provided here as static inline functions.
// For the purpose of this fix, we assume they are available and correctly implemented.

/**
 * nymya_3331_barenco - Applies a Barenco gate to three qubits (kernel-space core logic).
 * @q1: Pointer to the first control qubit (kernel space).
 * @q2: Pointer to the second control qubit (kernel space).
 * @q3: Pointer to the third target qubit (kernel space).
 *
 * This function encapsulates the core logic for applying the Barenco gate by
 * calling kernel-space versions of Hadamard, CNOT, and Phase gates.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any qubit pointer is NULL.
 * - Error code from underlying gate operations if they fail.
 */
int nymya_3331_barenco(nymya_qubit* q1, nymya_qubit* q2, nymya_qubit* q3) {
    int ret = 0;
    if (!q1 || !q2 || !q3) {
        pr_err("nymya_3331_barenco: NULL qubit pointer passed to kernel core function\n");
        return -EINVAL; // More specific kernel error
    }

    // Call kernel-space versions of the sub-gates
    // These functions must exist and be callable from kernel context.
    // Their prototypes should be in nymya.h (for kernel).
    ret = nymya_3308_hadamard_gate(q3);
    if (ret) return ret;
    ret = nymya_3309_controlled_not(q2, q3);
    if (ret) return ret;
    ret = nymya_3306_phase_gate(q3); // This is typically an S gate (Phase(pi/2))
    if (ret) return ret;
    ret = nymya_3309_controlled_not(q1, q3);
    if (ret) return ret;
    ret = nymya_3308_hadamard_gate(q3);
    if (ret) return ret;

    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3331_barenco);


/**
 * SYSCALL_DEFINE3(nymya_3331_barenco) - Kernel syscall for Barenco gate.
 * @user_q1: User-space pointer to the first control qubit.
 * @user_q2: User-space pointer to the second control qubit.
 * @user_q3: User-space pointer to the target qubit.
 *
 * This syscall copies qubit data from user space, applies the Barenco gate
 * using the shared kernel-space core function, and then copies the modified
 * data back.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from underlying gate operations.
 */
SYSCALL_DEFINE3(nymya_3331_barenco,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2,
    struct nymya_qubit __user *, user_q3) {

    struct nymya_qubit k_q1, k_q2, k_q3;
    int ret = 0;

    // 1. Validate user pointers
    if (!user_q1 || !user_q2 || !user_q3) {
        pr_err("nymya_3331_barenco: Invalid user qubit pointers\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3331_barenco: Failed to copy k_q1 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3331_barenco: Failed to copy k_q2 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q3, user_q3, sizeof(k_q3))) {
        pr_err("nymya_3331_barenco: Failed to copy k_q3 from user space\n");
        return -EFAULT;
    }

    // 3. Apply the Barenco gate using the kernel-space core function
    ret = nymya_3331_barenco(&k_q1, &k_q2, &k_q3);

    // 4. Log event and copy data back to user space if successful
    if (ret == 0) {
        log_symbolic_event("BARENCO", k_q1.id, k_q1.tag, "Barenco composite applied");

        if (copy_to_user(user_q1, &k_q1, sizeof(k_q1)))
            return -EFAULT;
        if (copy_to_user(user_q2, &k_q2, sizeof(k_q2)))
            return -EFAULT;
        if (copy_to_user(user_q3, &k_q3, sizeof(k_q3)))
            return -EFAULT;
    } else {
        pr_err("nymya_3331_barenco: Kernel Barenco operation failed with error %d\n", ret);
    }

    return ret; // Return the result of the kernel operation
}

#endif

```

---

## File: `nymya_3332_berkeley.c`

### Content

```c
// src/nymya_3332_berkeley.c

#include "nymya.h" // This should bring in common definitions and conditional includes

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland only
#define __NR_nymya_3332_berkeley NYMYA_BERKELEY_CODE

    #include <stdlib.h>  // Userland only
    #include <math.h>    // Userland only
    #include <complex.h> // Userland only
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h>
    #include <linux/types.h> // For __int128
    #include <linux/slab.h> // For kmalloc_array if needed
    #include <linux/module.h> // Ensure this is present
    // No math.h or complex.h in kernel
#endif

// Fixed-point constants and helper functions for kernel (if not already in nymya.h)
#ifdef __KERNEL__

// Define PI and PI/2 in fixed-point for kernel calculations if not already in nymya.h
// These are now defined in nymya.h and should not be redefined here.
// #ifndef FIXED_POINT_PI
// #define FIXED_POINT_PI (int64_t)(3.141592653589793 * FIXED_POINT_SCALE)
// #endif
// #ifndef FIXED_POINT_PI_DIV_2
// #define FIXED_POINT_PI_DIV_2 (int64_t)(1.5707963267948966 * FIXED_POINT_SCALE)
// #endif

// fixed_point_mul, fixed_point_cos, fixed_point_sin are now defined as static inline in nymya.h
// and should NOT be redefined here.

#endif // __KERNEL__

#ifndef __KERNEL__

/**
 * nymya_3332_berkeley - Applies a Berkeley gate to two qubits (userland version).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 * @theta: The gate parameter.
 *
 * This function implements a two-qubit Berkeley gate, which is a parameterized
 * entangling gate. The exact transformation depends on the parameter $\theta$.
 * This is a composite gate typically implemented as CNOT-Phase-CNOT.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL.
 */
int nymya_3332_berkeley(nymya_qubit* q1, nymya_qubit* q2, double theta) {
    if (!q1 || !q2) return -1;

    // Assuming userland versions of these gates exist and accept double theta
    nymya_3309_controlled_not(q1, q2);
    nymya_3316_phase_gate(q2, theta); // This expects double theta
    nymya_3309_controlled_not(q1, q2);

    log_symbolic_event("BERKELEY", q1->id, q1->tag, "Berkeley entangler applied");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3332_berkeley - Core kernel-space logic for the Berkeley gate.
 * @q1: Pointer to the first qubit (kernel space).
 * @q2: Pointer to the second qubit (kernel space).
 * @theta_fp: The gate parameter in fixed-point format.
 *
 * This function implements the Berkeley gate logic by calling kernel-space
 * versions of CNOT and Phase gates. It also logs the gate application.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any qubit pointer is NULL, or if a sub-gate fails.
 */
int nymya_3332_berkeley(struct nymya_qubit* q1, struct nymya_qubit* q2, int64_t theta_fp) {
    int ret = 0;
    if (!q1 || !q2) {
        pr_err("nymya_3332_berkeley: Null qubit pointer in core logic.\n");
        return -EINVAL; // Use kernel-style error codes
    }

    // Call kernel-space versions of the sub-gates
    // These functions must exist and be callable from kernel context.
    // Their prototypes should be in nymya.h (for kernel).
    ret = nymya_3309_controlled_not(q1, q2);
    if (ret) {
        pr_err("nymya_3332_berkeley: CNOT failed with error %d\n", ret);
        return ret;
    }
    ret = nymya_3316_phase_gate(q2, theta_fp); // This now expects int64_t theta_fp
    if (ret) {
        pr_err("nymya_3332_berkeley: Phase gate failed with error %d\n", ret);
        return ret;
    }
    ret = nymya_3309_controlled_not(q1, q2);
    if (ret) {
        pr_err("nymya_3332_berkeley: Second CNOT failed with error %d\n", ret);
        return ret;
    }

    // Log event after successful application
    log_symbolic_event("BERKELEY", q1->id, q1->tag, "Berkeley entangler applied");

    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3332_berkeley);



/**
 * SYSCALL_DEFINE3(nymya_3332_berkeley) - Kernel syscall for Berkeley gate.
 * @user_q1: User-space pointer to the first qubit.
 * @user_q2: User-space pointer to the second qubit.
 * @theta_fp: The gate parameter in fixed-point (int64_t) format.
 *
 * This syscall copies qubit data from user space, applies the Berkeley gate
 * using the core kernel-space helper function, and then copies the modified data back.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from underlying gate operations.
 */
SYSCALL_DEFINE3(nymya_3332_berkeley,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2,
    int64_t, theta_fp) {

    struct nymya_qubit k_q1, k_q2;
    int ret = 0;

    // 1. Validate user pointers
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3332_berkeley_syscall: Invalid user qubit pointers\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3332_berkeley_syscall: Failed to copy k_q1 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3332_berkeley_syscall: Failed to copy k_q2 from user space\n");
        return -EFAULT;
    }

    // 3. Call the refactored kernel-space core function
    ret = nymya_3332_berkeley(&k_q1, &k_q2, theta_fp);

    // 4. Copy data back to user space if successful
    if (ret == 0) {
        if (copy_to_user(user_q1, &k_q1, sizeof(k_q1)))
            return -EFAULT;

        if (copy_to_user(user_q2, &k_q2, sizeof(k_q2)))
            return -EFAULT;
    } else {
        pr_err("nymya_3332_berkeley_syscall: Kernel Berkeley operation failed with error %d\n", ret);
    }

    return ret;
}
#endif

```

---

## File: `nymya_3333_c_v.c`

### Content

```c
// src/nymya_3333_c_v.c

#include "nymya.h" // Common definitions like complex_double

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland only
#define __NR_nymya_3333_c_v NYMYA_C_V_CODE

    #include <stdlib.h>  // Userland only
    #include <math.h>    // For cabs in userland
    #include <complex.h> // For _Complex double in userland
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h> // For -EINVAL, -EFAULT
    #include <linux/module.h>
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

// Userland implementation
int nymya_3333_c_v(nymya_qubit* qc, nymya_qubit* qt) {
    if (!qc || !qt) return -1;

    // In userland, cabs calculates the magnitude of a complex double.
    // The condition `cabs(qc->amplitude) > 0.5` implies that the control qubit
    // is predominantly in the |1> state (amplitude magnitude squared > 0.25).
    // This is a simplified check for a "controlled" operation.
    if (cabs(qc->amplitude) > 0.5) {
        nymya_3307_sqrt_x_gate(qt); // Apply sqrt(X) gate to target qubit
        log_symbolic_event("C_V", qt->id, qt->tag, "Controlled-V applied");
    } else {
        log_symbolic_event("C_V", qt->id, qt->tag, "Control=0, no action");
    }
    return 0;
}

#else // __KERNEL__

/**
 * fixed_point_magnitude_sq - Calculates the squared magnitude of a fixed-point complex number.
 * @c: The fixed-point complex number.
 *
 * Returns:
 * The squared magnitude in fixed-point format.
 */
static inline int64_t fixed_point_magnitude_sq(complex_double c) {
    // Magnitude squared = re*re + im*im
    // Use fixed_point_mul for each term to correctly handle scaling.
    return fixed_point_mul(c.re, c.re) + fixed_point_mul(c.im, c.im);
}

/**
 * nymya_3333_c_v - Core logic for the Controlled-V gate.
 * @k_qc: Pointer to the kernel-space control qubit.
 * @k_qt: Pointer to the kernel-space target qubit.
 *
 * Implements the Controlled-V gate. The V gate is typically defined as sqrt(X).
 * The control logic checks if the control qubit's amplitude squared magnitude
 * exceeds a fixed-point threshold (0.25). If it does, the sqrt(X) gate is applied
 * to the target qubit.
 *
 * Returns:
 * - 0 on success.
 * - Error code from underlying gate operations (e.g., nymya_3307_sqrt_x_gate).
 */
int nymya_3333_c_v(struct nymya_qubit *k_qc, struct nymya_qubit *k_qt) {
    int ret = 0;

    // The comparison `cabs(qc->amplitude) > 0.5` in userland means `sqrt(re*re + im*im) > 0.5`,
    // which is `re*re + im*im > 0.25`.
    // In fixed-point, 0.25 * FIXED_POINT_SCALE is `(1ULL << 32) / 4`.
    // Let's use a threshold for the squared magnitude in fixed-point.
    int64_t threshold_sq_fp = FIXED_POINT_SCALE / 4; // Represents 0.25 in Q32.32

    if (fixed_point_magnitude_sq(k_qc->amplitude) > threshold_sq_fp) {
        // Control qubit is "on" (predominantly |1>)
        // Call the kernel version of nymya_3307_sqrt_x_gate
        ret = nymya_3307_sqrt_x_gate(k_qt);
        if (ret == 0) {
            log_symbolic_event("C_V", k_qt->id, k_qt->tag, "Controlled-V applied");
        } else {
            pr_err("nymya_3333_c_v: Failed to apply sqrt_x_gate to target qubit, error %d\n", ret);
        }
    } else {
        // Control qubit is "off" (predominantly |0>)
        log_symbolic_event("C_V", k_qt->id, k_qt->tag, "Control=0, no action");
    }
    return ret;
}
EXPORT_SYMBOL_GPL(nymya_3333_c_v);



/**
 * SYSCALL_DEFINE2(nymya_3333_c_v) - Kernel syscall for Controlled-V gate.
 * @user_qc: User-space pointer to the control qubit.
 * @user_qt: User-space pointer to the target qubit.
 *
 * This syscall copies qubit data from user space, calls the core Controlled-V
 * gate logic, and then copies the modified data back. The V gate is typically
 * defined as sqrt(X).
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from underlying core gate operations.
 */
SYSCALL_DEFINE2(nymya_3333_c_v,
    struct nymya_qubit __user *, user_qc,
    struct nymya_qubit __user *, user_qt) {

    struct nymya_qubit k_qc, k_qt; // Kernel-space copies
    int ret = 0;

    // 1. Validate user pointers
    if (!user_qc || !user_qt) {
        pr_err("nymya_3333_c_v: Invalid user qubit pointers\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_qc, user_qc, sizeof(k_qc))) {
        pr_err("nymya_3333_c_v: Failed to copy k_qc from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_qt, user_qt, sizeof(k_qt))) {
        pr_err("nymya_3333_c_v: Failed to copy k_qt from user space\n");
        return -EFAULT;
    }

    // 3. Call the core logic function with kernel-space copies
    ret = nymya_3333_c_v(&k_qc, &k_qt);

    // 4. Copy modified target qubit data back to user space
    if (copy_to_user(user_qt, &k_qt, sizeof(k_qt))) {
        pr_err("nymya_3333_c_v: Failed to copy k_qt to user space\n");
        return -EFAULT;
    }

    return ret; // Return the result of the operation (0 for success, error code otherwise)
}

#endif

```

---

## File: `nymya_3334_core_entangle.c`

### Content

```c
// src/nymya_3334_core_entangle.c

#include "nymya.h" // Common definitions like complex_double

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland only
#define __NR_nymya_3334_core_entangle NYMYA_CORE_ENTANGLE_CODE

    #include <stdlib.h>  // Userland only
    #include <math.h>    // For complex math functions in userland
    #include <complex.h> // For _Complex double in userland
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h> // For -EINVAL, -EFAULT
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

// Userland implementation
/**
 * nymya_3334_core_entangle - Applies a "core entangle" gate to two qubits (userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 *
 * This function applies a specific two-qubit entangling operation,
 * typically a Bell state preparation (Hadamard on q1, then CNOT with q1 as control, q2 as target).
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL.
 */
int nymya_3334_core_entangle(nymya_qubit* q1, nymya_qubit* q2) {
    if (!q1 || !q2) return -1;

    // Bell state preparation: Hadamard on q1, then CNOT with q1 as control, q2 as target
    nymya_3308_hadamard_gate(q1);
    nymya_3309_controlled_not(q1, q2);

    log_symbolic_event("CORE_EN", q1->id, q1->tag, "Core entanglement applied");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3334_core_entangle - Applies a "core entangle" gate to two qubits (kernel-space).
 * @kq1: Pointer to the first qubit in kernel-space.
 * @kq2: Pointer to the second qubit in kernel-space.
 *
 * This function encapsulates the core logic for the "core entangle" operation.
 * It applies a specific two-qubit entangling operation, typically a Bell state
 * preparation (Hadamard on kq1, then CNOT with kq1 as control, kq2 as target)
 * using kernel-space qubit structures and functions.
 *
 * Returns:
 * - 0 on success.
 * - Error code from underlying gate operations (e.g., nymya_3308_hadamard_gate, nymya_3309_controlled_not).
 */
int nymya_3334_core_entangle(struct nymya_qubit *kq1, struct nymya_qubit *kq2) {
    int ret = 0;

    // Apply the "core entangle" logic for kernel space (Bell state preparation)
    // Call the kernel versions of Hadamard and CNOT gates
    ret = nymya_3308_hadamard_gate(kq1);
    if (ret) {
        pr_err("nymya_3334_core_entangle: Hadamard gate failed on q1, error %d\n", ret);
        return ret;
    }

    ret = nymya_3309_controlled_not(kq1, kq2);
    if (ret) {
        pr_err("nymya_3334_core_entangle: CNOT gate failed, error %d\n", ret);
        return ret;
    }

    log_symbolic_event("CORE_EN", kq1->id, kq1->tag, "Core entanglement applied");

    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3334_core_entangle);



/**
 * SYSCALL_DEFINE2(nymya_3334_core_entangle) - Kernel syscall for "core entangle" gate.
 * @user_q1: User-space pointer to the first qubit.
 * @user_q2: User-space pointer to the second qubit.
 *
 * This syscall copies qubit data from user space, applies the "core entangle" gate
 * logic (Bell state preparation) using kernel-space functions, and then copies the
 * modified data back.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from the core logic function (nymya_3334_core_entangle).
 */
SYSCALL_DEFINE2(nymya_3334_core_entangle,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_q1, k_q2; // Kernel-space copies
    int ret = 0;

    // 1. Validate user pointers
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3334_core_entangle: Invalid user qubit pointers\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3334_core_entangle: Failed to copy k_q1 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3334_core_entangle: Failed to copy k_q2 from user space\n");
        return -EFAULT;
    }

    // 3. Call the core entanglement logic
    ret = nymya_3334_core_entangle(&k_q1, &k_q2);
    if (ret) {
        // Error already logged by the core function
        return ret;
    }

    // 4. Copy modified qubit data back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3334_core_entangle: Failed to copy k_q1 to user space\n");
        return -EFAULT;
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3334_core_entangle: Failed to copy k_q2 to user space\n");
        return -EFAULT;
    }

    return 0; // Return 0 for success
}

#endif

```

---

## File: `nymya_3335_dagwood.c`

### Content

```c
// src/nymya_3335_dagwood.c

#include "nymya.h" // Common definitions like complex_double

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland only
#define __NR_nymya_3335_dagwood NYMYA_DAGWOOD_CODE

    #include <stdlib.h>  // Userland only
    #include <math.h>    // For cabs in userland
    #include <complex.h> // For _Complex double in userland
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h> // For -EINVAL, -EFAULT
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

/**
 * nymya_3335_dagwood - Applies a Dagwood gate to three qubits (userland).
 * @q1: Pointer to the first control qubit.
 * @q2: Pointer to the first target qubit.
 * @q3: Pointer to the second target qubit.
 *
 * This function implements a Dagwood gate. If the control qubit's amplitude
 * magnitude squared is above a threshold (representing a '1' state), it swaps
 * the amplitudes of the two target qubits (q2 and q3). Otherwise, no action is taken.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL.
 */
int nymya_3335_dagwood(nymya_qubit* q1, nymya_qubit* q2, nymya_qubit* q3) {
    if (!q1 || !q2 || !q3) return -1;

    // In userland, q1->amplitude is _Complex double.
    // Calculate the magnitude squared directly using cabs().
    double ctrl_mag_sq = cabs(q1->amplitude) * cabs(q1->amplitude);

    // Define the threshold for control qubit being '1' (0.5^2 = 0.25)
    const double threshold_sq = 0.25;

    // If the control qubit's amplitude magnitude squared is above the threshold, perform SWAP
    if (ctrl_mag_sq > threshold_sq) {
        nymya_3313_swap(q2, q3); // Call userland SWAP gate
        log_symbolic_event("DAGWOOD", q1->id, q1->tag, "Dagwood swap applied");
    } else {
        log_symbolic_event("DAGWOOD", q1->id, q1->tag, "Control=0, no swap");
    }
    return 0;
}

#else // __KERNEL__

/**
 * fixed_point_magnitude_sq - Calculates the squared magnitude of a fixed-point complex number.
 * @c: The fixed-point complex number.
 *
 * Returns:
 * The squared magnitude in fixed-point format.
 */
static inline int64_t fixed_point_magnitude_sq(complex_double c) {
    // Magnitude squared = re*re + im*im
    // Note: This assumes fixed_point_mul is available via nymya.h.
    return fixed_point_mul(c.re, c.re) + fixed_point_mul(c.im, c.im);
}

/**
 * nymya_3335_dagwood - Applies a Dagwood gate to three qubits (kernel-side core logic).
 * @k_q1: Pointer to the kernel-space copy of the control qubit.
 * @k_q2: Pointer to the kernel-space copy of the first target qubit.
 * @k_q3: Pointer to the kernel-space copy of the second target qubit.
 *
 * This function implements the core Dagwood gate logic in kernel space.
 * If the control qubit's fixed-point amplitude magnitude squared is above
 * a predefined threshold (representing a '1' state), it performs a swap
 * between the amplitudes of the two target qubits (k_q2 and k_q3) using
 * the kernel's nymya_3313_swap function. Otherwise, no action is taken.
 *
 * This function operates on kernel-space qubit structures directly.
 *
 * Returns:
 * - 0 on success.
 * - Error code from underlying gate operations (e.g., from nymya_3313_swap),
 *   if the swap was attempted and failed.
 */
int nymya_3335_dagwood(struct nymya_qubit *k_q1, struct nymya_qubit *k_q2, struct nymya_qubit *k_q3) {
    int ret = 0; // Initialize to success (no operation or successful operation)

    // Threshold for control qubit being '1' (0.5^2 = 0.25 in floating point)
    // Convert 0.25 to fixed-point squared value
    const int64_t threshold_sq_fp = FIXED_POINT_SCALE / 4; // Represents 0.25 in Q32.32

    if (fixed_point_magnitude_sq(k_q1->amplitude) > threshold_sq_fp) {
        // Control qubit is "on" (predominantly |1>)
        // Call the kernel version of nymya_3313_swap
        ret = nymya_3313_swap(k_q2, k_q3);
        if (ret == 0) { // Only log success or failure of SWAP, not gate itself
            log_symbolic_event("DAGWOOD", k_q1->id, k_q1->tag, "Dagwood swap applied");
        }
        // If ret != 0, it means nymya_3313_swap failed, and we propagate that error.
    } else {
        // Control qubit is "off" (predominantly |0>)
        log_symbolic_event("DAGWOOD", k_q1->id, k_q1->tag, "Control=0, no swap");
    }

    return ret;
}
EXPORT_SYMBOL_GPL(nymya_3335_dagwood);



/**
 * SYSCALL_DEFINE3(nymya_3335_dagwood) - Kernel syscall for Dagwood gate.
 * @user_q1: User-space pointer to the control qubit.
 * @user_q2: User-space pointer to the first target qubit.
 * @user_q3: User-space pointer to the second target qubit.
 *
 * This syscall copies qubit data from user space, applies the Dagwood gate
 * logic using kernel-space functions, and then copies the modified data back.
 * The Dagwood gate conditionally swaps two target qubits based on a control qubit's state.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from underlying gate operations (e.g., nymya_3313_swap),
 *   if the core logic was executed and failed.
 */
SYSCALL_DEFINE3(nymya_3335_dagwood,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2,
    struct nymya_qubit __user *, user_q3) {

    struct nymya_qubit k_q1, k_q2, k_q3; // Kernel-space copies
    int ret = 0; // Initialize return value for syscall

    // 1. Validate user pointers
    if (!user_q1 || !user_q2 || !user_q3) {
        pr_err("nymya_3335_dagwood: Invalid user qubit pointers\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3335_dagwood: Failed to copy k_q1 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3335_dagwood: Failed to copy k_q2 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q3, user_q3, sizeof(k_q3))) {
        pr_err("nymya_3335_dagwood: Failed to copy k_q3 from user space\n");
        return -EFAULT;
    }

    // 3. Call the newly created core function
    ret = nymya_3335_dagwood(&k_q1, &k_q2, &k_q3);

    // Check if the core logic (specifically, the swap if performed) returned an error
    if (ret != 0) {
        pr_err("nymya_3335_dagwood: Core logic (swap) failed with error %d\n", ret);
        return ret; // Propagate the error from the core function
    }

    // 4. Copy modified qubit data back to user space
    // Note: k_q1 (control qubit) is typically not modified by Fredkin/Dagwood,
    // so it doesn't strictly need to be copied back unless its state *could* change.
    // However, copying it back is safer if there's any ambiguity or future changes.
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3335_dagwood: Failed to copy k_q1 to user space\n");
        return -EFAULT;
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3335_dagwood: Failed to copy k_q2 to user space\n");
        return -EFAULT;
    }
    if (copy_to_user(user_q3, &k_q3, sizeof(k_q3))) {
        pr_err("nymya_3335_dagwood: Failed to copy k_q3 to user space\n");
        return -EFAULT;
    }

    return 0; // Success
}

#endif

```

---

## File: `nymya_3336_echo_cr.c`

### Content

```c
// src/nymya_3336_echo_cr.c

#include "nymya.h" // Common definitions like complex_double

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland only
#define __NR_nymya_3336_echo_cr NYMYA_ECHO_CR_CODE

    #include <stdlib.h>  // Userland only
    #include <math.h>    // For cexp, conj in userland
    #include <complex.h> // For _Complex double in userland
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h> // For -EINVAL, -EFAULT
    #include <linux/printk.h> // For pr_err
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

/**
 * nymya_3336_echo_cr - Applies an Echo Cross-Resonance (CR) gate to two qubits (userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 * @theta: The gate parameter (angle in radians).
 *
 * This function applies a sequence of complex phase rotations to the qubits' amplitudes.
 * Note: The sequence of operations (p, conj(p), conj(p), p) on q1 and q2 respectively
 * appears to result in no net change to the qubit amplitudes if 'p' is a unit complex number,
 * as p * conj(p) = |p|^2 = 1. This implementation directly mirrors the provided userland logic.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL.
 */
int nymya_3336_echo_cr(nymya_qubit* q1, nymya_qubit* q2, double theta) {
    if (!q1 || !q2) return -1;

    // In userland, q1->amplitude and q2->amplitude are _Complex double.
    // cexp(I * theta) computes e^(i*theta).
    _Complex double p = cexp(I * theta);

    // Apply the sequence of complex multiplications
    q1->amplitude *= p;
    q2->amplitude *= conj(p);
    q1->amplitude *= conj(p);
    q2->amplitude *= p;

    log_symbolic_event("ECHO_CR", q1->id, q1->tag, "ECR interaction applied");
    return 0;
}

#else // __KERNEL__

/**
 * @brief Applies an Echo Cross-Resonance (CR) gate to kernel-space qubits.
 * @param kq1 Pointer to the first qubit structure in kernel space.
 * @param kq2 Pointer to the second qubit structure in kernel space.
 * @param theta_fp The gate parameter (angle) in fixed-point format.
 *
 * This function implements the core logic for the Echo Cross-Resonance (CR)
 * gate. It applies a sequence of complex phase rotations to the provided
 * kernel-space qubit amplitudes using fixed-point complex arithmetic.
 *
 * This function is intended to be called by the `sys_nymya_3336_echo_cr`
 * syscall after user-space data has been copied to kernel space, or by
 * other kernel modules directly.
 *
 * @return 0 on success. Currently, no specific failure conditions are
 *         handled within this core logic that would result in a non-zero
 *         return, assuming valid input pointers.
 */
int nymya_3336_echo_cr(struct nymya_qubit *kq1, struct nymya_qubit *kq2, int64_t theta_fp) {
    // Use complex_exp_i for e^(i*theta_fp) and complex_mul for multiplications.
    complex_double p_fp = complex_exp_i(theta_fp);
    complex_double conj_p_fp = complex_conj(p_fp);

    // Apply the sequence of complex multiplications
    kq1->amplitude = complex_mul(kq1->amplitude, p_fp);
    kq2->amplitude = complex_mul(kq2->amplitude, conj_p_fp);
    kq1->amplitude = complex_mul(kq1->amplitude, conj_p_fp);
    kq2->amplitude = complex_mul(kq2->amplitude, p_fp);

    log_symbolic_event("ECHO_CR", kq1->id, kq1->tag, "ECR interaction applied");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3336_echo_cr);



/**
 * SYSCALL_DEFINE3(nymya_3336_echo_cr) - Kernel syscall for Echo Cross-Resonance (CR) gate.
 * @user_q1: User-space pointer to the first qubit.
 * @user_q2: User-space pointer to the second qubit.
 * @theta_fp: The gate parameter (angle) in fixed-point (int64_t) format.
 *
 * This syscall copies qubit data from user space, applies the Echo CR gate
 * logic by calling the `nymya_3336_echo_cr` core function, and then copies
 * the modified data back.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 */
SYSCALL_DEFINE3(nymya_3336_echo_cr,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2,
    int64_t, theta_fp) { // Theta is now fixed-point

    struct nymya_qubit k_q1, k_q2; // Kernel-space copies
    int ret = 0;

    // 1. Validate user pointers
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3336_echo_cr: Invalid user qubit pointers\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3336_echo_cr: Failed to copy k_q1 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3336_echo_cr: Failed to copy k_q2 from user space\n");
        return -EFAULT;
    }

    // 3. Call the core Echo CR logic function with kernel-space copies
    ret = nymya_3336_echo_cr(&k_q1, &k_q2, theta_fp);
    if (ret) {
        // Propagate error from core function if it ever returns one
        pr_err("nymya_3336_echo_cr: Core logic failed with error %d\n", ret);
        return ret;
    }

    // 4. Copy modified qubit data back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3336_echo_cr: Failed to copy k_q1 to user space\n");
        return -EFAULT;
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3336_echo_cr: Failed to copy k_q2 to user space\n");
        return -EFAULT;
    }

    return 0; // Return 0 for success
}

#endif

```

---

## File: `nymya_3337_fermion_sim.c`

### Content

```c
// src/nymya_3337_fermion_sim.c
//
// This file implements the nymya_3337_fermion_sim syscall, which applies a
// two-qubit fermionic simulation gate. This gate typically involves swapping
// the states of two qubits and applying a phase shift, mimicking an exchange
// interaction in fermionic systems.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion and fixed-point arithmetic for kernel operations.

#include "nymya.h" // Common definitions like complex_double, nymya_qubit, and fixed-point helpers

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3337_fermion_sim NYMYA_FERMION_SIM_CODE

    #include <stdlib.h>  // Userland: For general utilities
    #include <math.h>    // Userland: For complex math functions like cabs
    #include <complex.h> // Userland: For _Complex double type and I macro
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT
    #include <linux/module.h>   // ADDED: Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

/**
 * nymya_3337_fermion_sim - Applies a two-qubit fermionic simulation gate (userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 *
 * This function simulates a fermionic exchange interaction. It performs a SWAP
 * operation between the two qubits and then applies a global phase of -1 to
 * the first qubit's amplitude. This effectively implements a permutation with
 * a sign change, characteristic of fermionic statistics.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL (invalid input).
 */
int nymya_3337_fermion_sim(nymya_qubit* q1, nymya_qubit* q2) {
    // Basic null pointer check
    if (!q1 || !q2) return -1;

    // Apply the SWAP gate using the userland nymya_swap macro (which calls nymya_3313_swap)
    nymya_swap(q1, q2);

    // Apply a phase shift of -1 to the first qubit's amplitude
    // In userland, amplitude is _Complex double, so direct multiplication by -1 is fine.
    q1->amplitude *= -1;

    // Log the symbolic event for traceability
    log_symbolic_event("FERMION_SIM", q1->id, q1->tag, "Fermionic exchange");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3337_fermion_sim - Core kernel function for fermionic simulation gate.
 * @k_q1: Pointer to the first kernel-space qubit structure.
 * @k_q2: Pointer to the second kernel-space qubit structure.
 *
 * This function applies the fermionic simulation gate logic. It performs a SWAP
 * operation between the two qubits and then applies a global phase of -1 to
 * the first qubit's amplitude using fixed-point arithmetic.
 * This function is designed to be called directly by other kernel code.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any kernel qubit pointer is NULL.
 * - Error code from underlying gate operations (e.g., nymya_3313_swap).
 */
int nymya_3337_fermion_sim(struct nymya_qubit *k_q1, struct nymya_qubit *k_q2) {
    int ret = 0;

    // 1. Check for null pointers
    if (!k_q1 || !k_q2) {
        pr_err("nymya_3337_fermion_sim: Null kernel qubit pointer(s)\n");
        return -EINVAL;
    }

    // 2. Apply the fermionic simulation logic for kernel space
    // Call the kernel version of the SWAP gate
    ret = nymya_3313_swap(k_q1, k_q2);
    if (ret) {
        pr_err("nymya_3337_fermion_sim: SWAP gate failed, error %d\n", ret);
        return ret; // Propagate error from SWAP gate
    }

    // Apply a phase shift of -1 to the first qubit's amplitude
    // For a complex number (re + i*im), multiplying by -1 results in (-re - i*im).
    k_q1->amplitude.re = -k_q1->amplitude.re;
    k_q1->amplitude.im = -k_q1->amplitude.im;

    // 3. Log the symbolic event for traceability
    log_symbolic_event("FERMION_SIM", k_q1->id, k_q1->tag, "Fermionic exchange");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3337_fermion_sim);



// Export the symbol for this function so other kernel modules/code can call it directly.


/**
 * SYSCALL_DEFINE2(nymya_3337_fermion_sim) - Kernel syscall for fermionic simulation gate.
 * @user_q1: User-space pointer to the first qubit structure.
 * @user_q2: User-space pointer to the second qubit structure.
 *
 * This syscall copies qubit data from user space to kernel space, calls the
 * core fermionic simulation gate logic, and then copies the modified data back
 * to user space.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user qubit pointer is NULL.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from underlying gate operations (e.g., nymya_3313_swap).
 */
SYSCALL_DEFINE2(nymya_3337_fermion_sim,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_q1, k_q2; // Kernel-space copies of qubits
    int ret = 0; // Return value for syscall

    // 1. Check for null pointers from user-space
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3337_fermion_sim: Null user qubit pointer(s)\n");
        return -EINVAL; // Invalid argument
    }

    // 2. Copy the qubit structures from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3337_fermion_sim: Failed to copy k_q1 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3337_fermion_sim: Failed to copy k_q2 from user\n");
        return -EFAULT; // Bad address
    }

    // 3. Call the core fermionic simulation logic
    ret = nymya_3337_fermion_sim(&k_q1, &k_q2);

    if (ret) {
        // Error already logged by core function or underlying swap
        return ret;
    }

    // 4. Copy the modified qubits back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3337_fermion_sim: Failed to copy k_q1 to user\n");
        ret = -EFAULT; // Bad address
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3337_fermion_sim: Failed to copy k_q2 to user\n");
        ret = -EFAULT; // Bad address
    }

    return ret; // Return 0 on success, or error code if any copy_to_user failed
}

#endif


```

---

## File: `nymya_3338_givens.c`

### Content

```c
// src/nymya_3338_givens.c

#include "nymya.h" // Common definitions like complex_double

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland only
#define __NR_nymya_3338_givens NYMYA_GIVENS_CODE

    #include <stdlib.h>  // Userland only
    #include <math.h>    // For cos, sin in userland
    #include <complex.h> // For _Complex double in userland
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/errno.h> // For -EINVAL, -EFAULT
    #include <linux/printk.h> // For pr_err
    #include <linux/module.h> // Ensure this is present for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

/**
 * nymya_3338_givens - Applies a Givens rotation gate to two qubits (userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 * @theta: The rotation angle in radians.
 *
 * This function applies a Givens rotation, which is a two-qubit operation
 * used in quantum linear algebra. It modifies the amplitudes of the two qubits
 * based on the rotation angle.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL.
 */
int nymya_3338_givens(nymya_qubit* q1, nymya_qubit* q2, double theta) {
    if (!q1 || !q2) return -1;

    // In userland, q1->amplitude and q2->amplitude are _Complex double.
    _Complex double a = q1->amplitude;
    _Complex double b = q2->amplitude;

    // Apply the Givens rotation transformation
    // new_a = a * cos(theta) - b * sin(theta)
    // new_b = a * sin(theta) + b * cos(theta)
    _Complex double new_a = a * cos(theta) - b * sin(theta);
    _Complex double new_b = a * sin(theta) + b * cos(theta);

    // Assign the new complex amplitudes directly back to the qubits.
    q1->amplitude = new_a;
    q2->amplitude = new_b;

    log_symbolic_event("GIVENS", q1->id, q1->tag, "Givens rotation applied");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3338_givens - Core kernel logic for applying a Givens rotation.
 * @kq1: Pointer to the first qubit in kernel space.
 * @kq2: Pointer to the second qubit in kernel space.
 * @theta_fp: The rotation angle in fixed-point (int64_t) format.
 *
 * This function performs the Givens rotation on the provided kernel-space
 * qubit structures using fixed-point arithmetic. It modifies the amplitudes
 * of the qubits directly.
 *
 * Returns:
 * - 0 on success.
 * - (Currently, no specific error conditions are handled internally by this function,
 *    but a non-zero return value could be used for future error propagation.)
 */
int nymya_3338_givens(struct nymya_qubit *kq1, struct nymya_qubit *kq2, int64_t theta_fp) {
    // Get fixed-point cosine and sine values from nymya.h wrappers
    int64_t cos_theta_fp = fixed_cos(theta_fp);
    int64_t sin_theta_fp = fixed_sin(theta_fp);

    // Let a = kq1->amplitude and b = kq2->amplitude
    // new_a = a * cos(theta) - b * sin(theta)
    // new_b = a * sin(theta) + b * cos(theta)

    // Calculate new_a.re = a.re * cos_theta_fp - b.re * sin_theta_fp
    // Calculate new_a.im = a.im * cos_theta_fp - b.im * sin_theta_fp
    complex_double new_a_amplitude;
    new_a_amplitude.re = fixed_point_mul(kq1->amplitude.re, cos_theta_fp) -
                         fixed_point_mul(kq2->amplitude.re, sin_theta_fp);
    new_a_amplitude.im = fixed_point_mul(kq1->amplitude.im, cos_theta_fp) -
                         fixed_point_mul(kq2->amplitude.im, sin_theta_fp);

    // Calculate new_b.re = a.re * sin_theta_fp + b.re * cos_theta_fp
    // Calculate new_b.im = a.im * sin_theta_fp + b.im * cos_theta_fp
    complex_double new_b_amplitude;
    new_b_amplitude.re = fixed_point_mul(kq1->amplitude.re, sin_theta_fp) +
                         fixed_point_mul(kq2->amplitude.re, cos_theta_fp);
    new_b_amplitude.im = fixed_point_mul(kq1->amplitude.im, sin_theta_fp) +
                         fixed_point_mul(kq2->amplitude.im, cos_theta_fp);

    kq1->amplitude = new_a_amplitude;
    kq2->amplitude = new_b_amplitude;

    log_symbolic_event("GIVENS", kq1->id, kq1->tag, "Givens rotation applied");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3338_givens);



/**
 * SYSCALL_DEFINE3(nymya_3338_givens) - Kernel syscall for Givens rotation gate.
 * @user_q1: User-space pointer to the first qubit.
 * @user_q2: User-space pointer to the second qubit.
 * @theta_fp: The rotation angle in fixed-point (int64_t) format.
 *
 * This syscall copies qubit data from user space, applies the Givens rotation
 * logic using kernel-space fixed-point complex arithmetic, and then copies
 * the modified data back.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user pointer is invalid.
 * - -EFAULT if copying data to/from user space fails.
 */
SYSCALL_DEFINE3(nymya_3338_givens,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2,
    int64_t, theta_fp) { // Theta is now fixed-point

    struct nymya_qubit k_q1, k_q2; // Kernel-space copies
    int ret; // For return value from core function

    // 1. Validate user pointers
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3338_givens: Invalid user qubit pointers\n");
        return -EINVAL;
    }

    // 2. Copy qubit data from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3338_givens: Failed to copy k_q1 from user space\n");
        return -EFAULT;
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3338_givens: Failed to copy k_q2 from user space\n");
        return -EFAULT;
    }

    // 3. Call the core Givens rotation logic
    ret = nymya_3338_givens(&k_q1, &k_q2, theta_fp);
    if (ret) {
        // Propagate any error from the core logic if it ever returns one
        pr_err("nymya_3338_givens: Core logic failed with error %d\n", ret);
        return ret;
    }

    // 4. Copy modified qubit data back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3338_givens: Failed to copy k_q1 to user space\n");
        return -EFAULT;
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3338_givens: Failed to copy k_q2 to user space\n");
        return -EFAULT;
    }

    return 0; // Success
}

#endif

```

---

## File: `nymya_3339_magic.c`

### Content

```c
// src/nymya_3339_magic.c
//
// This file implements the nymya_3339_magic syscall, which applies a
// two-qubit "Magic" gate. The Magic gate is a specific entangling gate
// often used in quantum information theory, typically constructed from
// a sequence of other fundamental gates like Hadamard, S (Phase), and CNOT.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion and fixed-point arithmetic for kernel operations.

#include "nymya.h" // Common definitions like complex_double, nymya_qubit, and gate macros

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3339_magic NYMYA_MAGIC_CODE

    #include <stdlib.h>  // Userland: For general utilities
    #include <math.h>    // Userland: For complex math functions
    #include <complex.h> // Userland: For _Complex double type
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT
    #include <linux/module.h>   // Kernel: Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations

/**
 * @brief Applies the Magic gate operation to two kernel-space qubits.
 *
 * This function encapsulates the core logic for the Magic gate, decomposing
 * it into a sequence of kernel-level Hadamard, Phase (S), and CNOT gates.
 * It operates directly on kernel-space qubit structures.
 *
 * @param kq1 Pointer to the first kernel-space qubit structure.
 * @param kq2 Pointer to the second kernel-space qubit structure.
 * @return 0 on success, or a negative error code if any underlying gate
 *         operation fails.
 */
int nymya_3339_magic(struct nymya_qubit *kq1, struct nymya_qubit *kq2) {
    int ret = 0;

    // Apply the Magic gate logic for kernel space
    // Call the kernel versions of the gates
    ret = nymya_3308_hadamard_gate(kq1); // Hadamard on q1
    if (ret) {
        pr_err("nymya_3339_magic: Hadamard on q1 failed, error %d\n", ret);
        return ret;
    }

    ret = nymya_3306_phase_gate(kq1); // S (Phase) gate on q1
    if (ret) {
        pr_err("nymya_3339_magic: Phase (S) on q1 failed, error %d\n", ret);
        return ret;
    }

    ret = nymya_3309_controlled_not(kq1, kq2); // CNOT with q1 as control, q2 as target
    if (ret) {
        pr_err("nymya_3339_magic: CNOT failed, error %d\n", ret);
        return ret;
    }

    ret = nymya_3308_hadamard_gate(kq1); // Hadamard on q1 again
    if (ret) {
        pr_err("nymya_3339_magic: Second Hadamard on q1 failed, error %d\n", ret);
        return ret;
    }

    // Log the symbolic event for traceability
    log_symbolic_event("MAGIC", kq1->id, kq1->tag, "Magic gate applied");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3339_magic);


/**
 * SYSCALL_DEFINE2(nymya_3339_magic) - Kernel syscall for Magic gate.
 * @user_q1: User-space pointer to the first qubit structure.
 * @user_q2: User-space pointer to the second qubit structure.
 *
 * This syscall copies qubit data from user space to kernel space, applies the
 * Magic gate logic using kernel-space functions, and then copies the modified
 * data back to user space. The Magic gate is decomposed into kernel-level
 * Hadamard, Phase (S), and CNOT gates.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user qubit pointer is NULL.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from underlying gate operations (e.g., nymya_3308_hadamard_gate).
 */
SYSCALL_DEFINE2(nymya_3339_magic,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_q1, k_q2; // Kernel-space copies of qubits
    int ret = 0; // Return value for syscall

    // 1. Check for null pointers from user-space
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3339_magic: Null user qubit pointer(s)\n");
        return -EINVAL; // Invalid argument
    }

    // 2. Copy the qubit structures from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3339_magic: Failed to copy k_q1 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3339_magic: Failed to copy k_q2 from user\n");
        return -EFAULT; // Bad address
    }

    // 3. Apply the Magic gate logic using the new core function
    ret = nymya_3339_magic(&k_q1, &k_q2);
    if (ret) {
        // Error already logged by the core function
        return ret;
    }

    // 4. Copy the modified qubits back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3339_magic: Failed to copy k_q1 to user\n");
        ret = -EFAULT; // Bad address
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3339_magic: Failed to copy k_q2 to user\n");
        ret = -EFAULT; // Bad address
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif

```

---

## File: `nymya_3340_sycamore.c`

### Content

```c
// src/nymya_3340_sycamore.c
//
// This file implements the nymya_3340_sycamore syscall, which applies a
// two-qubit Sycamore gate. The Sycamore gate is a specific entangling gate
// known from Google's quantum processors, typically constructed from a
// square root of iSWAP gate and a controlled-phase gate.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion and fixed-point arithmetic for kernel operations.

#include "nymya.h" // Common definitions like complex_double, nymya_qubit, and gate macros

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3340_sycamore NYMYA_SYCAMORE_CODE

    #include <stdlib.h>  // Userland: For general utilities
    #include <math.h>    // Userland: For M_PI and other math functions
    #include <complex.h> // Userland: For _Complex double type
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT
    #include <linux/printk.h>   // Kernel: For pr_err
    #include <linux/module.h>   // Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

/**
 * nymya_3340_sycamore - Applies the Sycamore gate to two qubits (userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 *
 * This function implements the Sycamore gate, a two-qubit entangling gate.
 * It is typically decomposed into a square root of iSWAP gate followed by
 * a Controlled-Phase gate with a specific angle (e.g., PI/6).
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL (invalid input).
 */
int nymya_3340_sycamore(nymya_qubit* q1, nymya_qubit* q2) {
    // Basic null pointer check
    if (!q1 || !q2) return -1;

    // Apply the sequence of gates that compose the Sycamore gate
    nymya_3327_sqrt_iswap(q1, q2); // Apply square root of iSWAP gate
    nymya_3317_controlled_phase(q1, q2, M_PI / 6.0); // Apply Controlled-Phase gate with angle PI/6

    // Log the symbolic event for traceability
    log_symbolic_event("SYCAMORE", q1->id, q1->tag, "Sycamore gate applied");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3340_sycamore - Applies the Sycamore gate logic to kernel-space qubits.
 * @k_q1: Pointer to the first qubit in kernel space.
 * @k_q2: Pointer to the second qubit in kernel space.
 *
 * This function implements the core Sycamore gate logic using kernel-level
 * operations and fixed-point arithmetic. It decomposes the Sycamore gate
 * into a square root of iSWAP gate followed by a Controlled-Phase gate
 * with an angle of PI/6 (converted to fixed-point).
 *
 * Returns:
 * - 0 on success.
 * - Negative error code if any underlying gate operation fails.
 */
int nymya_3340_sycamore(struct nymya_qubit *k_q1, struct nymya_qubit *k_q2) {
    int ret = 0;

    // Apply the sequence of gates that compose the Sycamore gate
    ret = nymya_3327_sqrt_iswap(k_q1, k_q2); // Apply square root of iSWAP gate
    if (ret) {
        pr_err("nymya_3340_sycamore: sqrt_iswap failed, error %d\n", ret);
        return ret;
    }

    // Convert M_PI / 6.0 to fixed-point for nymya_3317_controlled_phase
    // M_PI / 6.0 is approximately 0.5235987756 radians
    // Convert to fixed-point: (int64_t)(0.5235987756 * FIXED_POINT_SCALE)
    int64_t phase_angle_fp = (int64_t)(0.5235987756 * FIXED_POINT_SCALE);
    ret = nymya_3317_controlled_phase(k_q1, k_q2, phase_angle_fp); // Apply Controlled-Phase gate
    if (ret) {
        pr_err("nymya_3340_sycamore: controlled_phase failed, error %d\n", ret);
        return ret;
    }

    // Log the symbolic event for traceability
    log_symbolic_event("SYCAMORE", k_q1->id, k_q1->tag, "Sycamore gate applied");

    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3340_sycamore);



/**
 * SYSCALL_DEFINE2(nymya_3340_sycamore) - Kernel syscall for Sycamore gate.
 * @user_q1: User-space pointer to the first qubit structure.
 * @user_q2: User-space pointer to the second qubit structure.
 *
 * This syscall copies qubit data from user space to kernel space, applies the
 * Sycamore gate logic using kernel-space functions and fixed-point arithmetic
 * via the `nymya_3340_sycamore` helper function, and then copies the modified
 * data back to user space.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user qubit pointer is NULL.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from underlying core logic (e.g., nymya_3340_sycamore).
 */
SYSCALL_DEFINE2(nymya_3340_sycamore,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_q1, k_q2; // Kernel-space copies of qubits
    int ret = 0; // Return value for syscall

    // 1. Check for null pointers from user-space
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3340_sycamore: Null user qubit pointer(s)\n");
        return -EINVAL; // Invalid argument
    }

    // 2. Copy the qubit structures from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3340_sycamore: Failed to copy k_q1 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3340_sycamore: Failed to copy k_q2 from user\n");
        return -EFAULT; // Bad address
    }

    // 3. Apply the Sycamore gate logic using the extracted kernel function
    ret = nymya_3340_sycamore(&k_q1, &k_q2);
    if (ret) {
        pr_err("nymya_3340_sycamore: Core logic failed with error %d\n", ret);
        return ret;
    }

    // 4. Copy the modified qubits back to user space
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3340_sycamore: Failed to copy k_q1 to user\n");
        ret = -EFAULT; // Bad address
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3340_sycamore: Failed to copy k_q2 to user\n");
        ret = -EFAULT; // Bad address
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif

```

---

## File: `nymya_3341_cz_swap.c`

### Content

```c
// src/nymya_3341_cz_swap.c
//
// This file implements the nymya_3341_cz_swap syscall, which applies a
// two-qubit CZ-SWAP gate. This gate is a composite operation combining a
// Controlled-Z (CZ) gate and a SWAP gate, typically used to achieve specific
// entanglement patterns or as a building block in larger quantum circuits.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion and fixed-point arithmetic for kernel operations.

#include "nymya.h" // Common definitions like complex_double, nymya_qubit, and gate macros

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3341_cz_swap NYMYA_CZ_SWAP_CODE

    #include <stdlib.h>  // Userland: For general utilities
    #include <math.h>    // Userland: For complex math functions
    #include <complex.h> // Userland: For _Complex double type
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT
    #include <linux/printk.h>   // Kernel: For pr_err
    #include <linux/module.h>   // Kernel: For EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

/**
 * nymya_3341_cz_swap - Applies the CZ-SWAP gate to two qubits (userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 *
 * This function implements the CZ-SWAP gate by applying a Controlled-Z (CZ)
 * gate followed by a SWAP gate between the two qubits. This sequence results
 * in a specific entangling operation.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL (invalid input).
 */
int nymya_3341_cz_swap(nymya_qubit* q1, nymya_qubit* q2) {
    // Basic null pointer check
    if (!q1 || !q2) return -1;

    // Apply the sequence of gates that compose the CZ-SWAP gate
    nymya_3311_controlled_z(q1, q2); // Apply Controlled-Z gate
    nymya_3313_swap(q1, q2);         // Apply SWAP gate

    // Log the symbolic event for traceability
    log_symbolic_event("CZ_SWAP", q1->id, q1->tag, "CZ+SWAP applied");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3341_cz_swap - Applies the CZ-SWAP gate to two qubits (kernel-space).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 *
 * This function implements the CZ-SWAP gate by applying a Controlled-Z (CZ)
 * gate followed by a SWAP gate between the two qubits in kernel space.
 * This sequence results in a specific entangling operation.
 *
 * Returns:
 * - 0 on success.
 * - Error code from underlying gate operations (e.g., -EINVAL from nymya_3311_controlled_z).
 */
int nymya_3341_cz_swap(struct nymya_qubit *q1, struct nymya_qubit *q2) {
    int ret;

    // Apply the sequence of gates that compose the CZ-SWAP gate
    ret = nymya_3311_controlled_z(q1, q2); // Apply Controlled-Z gate
    if (ret) {
        pr_err("nymya_3341_cz_swap: Controlled-Z failed, error %d\n", ret);
        return ret;
    }

    ret = nymya_3313_swap(q1, q2);         // Apply SWAP gate
    if (ret) {
        pr_err("nymya_3341_cz_swap: SWAP failed, error %d\n", ret);
        return ret;
    }

    // Log the symbolic event for traceability
    log_symbolic_event("CZ_SWAP", q1->id, q1->tag, "CZ+SWAP applied");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3341_cz_swap);



/**
 * SYSCALL_DEFINE2(nymya_3341_cz_swap) - Kernel syscall for CZ-SWAP gate.
 * @user_q1: User-space pointer to the first qubit structure.
 * @user_q2: User-space pointer to the second qubit structure.
 *
 * This syscall copies qubit data from user space to kernel space, applies the
 * CZ-SWAP gate logic using the dedicated kernel-space function `nymya_3341_cz_swap`,
 * and then copies the modified data back to user space.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user qubit pointer is NULL.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from the underlying kernel-space `nymya_3341_cz_swap` function.
 */
SYSCALL_DEFINE2(nymya_3341_cz_swap,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_q1, k_q2; // Kernel-space copies of qubits
    int ret = 0; // Return value for syscall

    // 1. Check for null pointers from user-space
    if (!user_q1 || !user_q2) {
        pr_err("nymya_3341_cz_swap: Null user qubit pointer(s)\n");
        return -EINVAL; // Invalid argument
    }

    // 2. Copy the qubit structures from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3341_cz_swap: Failed to copy k_q1 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3341_cz_swap: Failed to copy k_q2 from user\n");
        return -EFAULT; // Bad address
    }

    // 3. Apply the CZ-SWAP gate logic using the extracted kernel-space function
    ret = nymya_3341_cz_swap(&k_q1, &k_q2);
    if (ret) {
        // Error already logged by the core nymya_3341_cz_swap function
        return ret;
    }

    // 4. Copy the modified qubits back to user space
    // Note: k_q1 and k_q2 are both modified by CZ and SWAP, so both need to be copied back.
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3341_cz_swap: Failed to copy k_q1 to user\n");
        ret = -EFAULT; // Bad address
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3341_cz_swap: Failed to copy k_q2 to user\n");
        ret = -EFAULT; // Bad address
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif

```

---

## File: `nymya_3342_deutsch.c`

### Content

```c
// src/nymya_3342_deutsch.c
//
// This file implements the Deutsch algorithm extension for Nymya syscalls.
// The core function applies Hadamard gates around a user-supplied oracle function.

#include "nymya.h" // Declarations for nymya_qubit, nymya_3308_hadamard_gate, log_symbolic_event, and core prototype

#ifndef __KERNEL__
#include <errno.h>
#include <stdio.h>

/**
 * nymya_3342_deutsch - Core Deutsch algorithm (userland)
 * @q1: first qubit (input/output)
 * @q2: second qubit (oracle target)
 * @f:  oracle function to apply (signature void f(nymya_qubit*))
 *
 * Implements: H(q1); f(q2); H(q1);
 * Returns 0 on success, -1 if q1 or q2 is NULL, -EINVAL if f is NULL.
 */
int nymya_3342_deutsch(nymya_qubit* q1, nymya_qubit* q2, void (*f)(nymya_qubit*)) {
    if (!q1 || !q2)
        return -1;
    if (!f)
        return -EINVAL;

    nymya_3308_hadamard_gate(q1);
    f(q2);
    nymya_3308_hadamard_gate(q1);
    log_symbolic_event("DEUTSCH", q1->id, q1->tag, "Deutsch gate applied");
    return 0;
}

#else // __KERNEL__
#include <linux/errno.h>
#include <linux/printk.h>
#include <linux/module.h>

/**
 * nymya_3342_deutsch - Core Deutsch algorithm (kernel)
 * @q1: first qubit
 * @q2: second qubit (oracle target)
 * @f:  oracle function pointer (void f(struct nymya_qubit *))
 *
 * Returns 0 on success, -EINVAL for NULL pointers.
 */
int nymya_3342_deutsch(struct nymya_qubit *q1, struct nymya_qubit *q2, void (*f)(struct nymya_qubit *)) {
    if (!q1 || !q2)
        return -EINVAL;
    if (!f) {
        pr_err("nymya_3342_deutsch: null oracle pointer\n");
        return -EINVAL;
    }

    nymya_3308_hadamard_gate(q1);
    f(q2);
    nymya_3308_hadamard_gate(q1);
    log_symbolic_event("DEUTSCH", q1->id, q1->tag, "Deutsch gate applied");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3342_deutsch);

#endif // __KERNEL__


```

---

## File: `nymya_3343_margolis.c`

### Content

```c
// src/nymya_3343_margolis.c
//
// This file implements the nymya_3343_margolis syscall, which applies a
// three-qubit Margolis gate. The Margolis gate is a controlled operation
// where a phase flip is applied to the target qubit if both control qubits
// are in a specific state (typically |1>).
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion and fixed-point arithmetic for kernel operations.

#include "nymya.h" // Common definitions like complex_double, nymya_qubit, and fixed-point helpers

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3343_margolis NYMYA_MARGOLIS_CODE

    #include <stdlib.h>  // Userland: For general utilities
    #include <math.h>    // Userland: For cabs and other math functions
    #include <complex.h> // Userland: For _Complex double type and I macro
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT
    #include <linux/printk.h>   // Kernel: For pr_err
    #include <linux/module.h>   // ADDED: Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

/**
 * nymya_3343_margolis - Applies a Margolis gate to three qubits (userland).
 * @qc1: Pointer to the first control qubit.
 * @qc2: Pointer to the second control qubit.
 * @qt: Pointer to the target qubit.
 *
 * This function implements a Margolis gate. If both control qubits' amplitude
 * magnitudes squared are above a threshold (representing a '1' state), it
 * applies a phase flip (multiplies by -1) to the target qubit's amplitude.
 * Otherwise, no action is taken.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL (invalid input).
 */
int nymya_3343_margolis(nymya_qubit* qc1, nymya_qubit* qc2, nymya_qubit* qt) {
    // Basic null pointer checks
    if (!qc1 || !qc2 || !qt) return -1;

    // In userland, amplitudes are _Complex double.
    // Calculate magnitude squared for each control qubit.
    double qc1_mag_sq = cabs(qc1->amplitude) * cabs(qc1->amplitude);
    double qc2_mag_sq = cabs(qc2->amplitude) * cabs(qc2->amplitude);

    // Define the threshold for control qubit being '1' (0.5^2 = 0.25)
    const double threshold_sq = 0.25;

    // If both control qubits' amplitude magnitudes squared are above the threshold, apply phase flip
    if (qc1_mag_sq > threshold_sq && qc2_mag_sq > threshold_sq) {
        qt->amplitude *= -1; // Apply phase flip (multiply by -1)
        log_symbolic_event("MARGOLIS", qt->id, qt->tag, "Margolis gate triggered");
    } else {
        log_symbolic_event("MARGOLIS", qt->id, qt->tag, "Conditions not met");
    }
    return 0;
}

#else // __KERNEL__

/**
 * fixed_point_magnitude_sq - Calculates the squared magnitude of a fixed-point complex number.
 * @c: The fixed-point complex number.
 *
 * Returns:
 * The squared magnitude in fixed-point format.
 */
static inline int64_t fixed_point_magnitude_sq(complex_double c) {
    // Magnitude squared = re*re + im*im
    // Note: This assumes fixed_point_mul is available via nymya.h.
    // The result of fixed_point_mul is already scaled by FIXED_POINT_SCALE.
    // So, the sum is also effectively scaled by FIXED_POINT_SCALE.
    return fixed_point_mul(c.re, c.re) + fixed_point_mul(c.im, c.im);
}

/**
 * nymya_3343_margolis - Core kernel function for Margolis gate.
 * @k_qc1: Pointer to the first kernel-space control qubit structure.
 * @k_qc2: Pointer to the second kernel-space control qubit structure.
 * @k_qt: Pointer to the kernel-space target qubit structure.
 *
 * This function applies the Margolis gate logic. It applies a phase flip
 * to the target qubit if both control qubits are in a '1' state (based on
 * amplitude magnitude using fixed-point arithmetic).
 * This function is designed to be called directly by other kernel code.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any kernel qubit pointer is NULL.
 */
int nymya_3343_margolis(struct nymya_qubit *k_qc1, struct nymya_qubit *k_qc2, struct nymya_qubit *k_qt) {
    // 1. Check for null pointers
    if (!k_qc1 || !k_qc2 || !k_qt) {
        pr_err("nymya_3343_margolis: Null kernel qubit pointer(s)\n");
        return -EINVAL;
    }

    // Define the threshold for control qubit being '1' (0.5^2 = 0.25 in floating point)
    // Convert 0.25 to fixed-point scaled by FIXED_POINT_SCALE.
    const int64_t threshold_sq_fp = FIXED_POINT_SCALE / 4; // Represents 0.25 in Q32.32

    // Check if both control qubits' amplitude magnitudes squared are above the threshold
    if (fixed_point_magnitude_sq(k_qc1->amplitude) > threshold_sq_fp &&
        fixed_point_magnitude_sq(k_qc2->amplitude) > threshold_sq_fp) {
        // Apply phase flip (multiply by -1) to the target qubit's amplitude
        // For a complex number (re + i*im), multiplying by -1 results in (-re - i*im).
        k_qt->amplitude.re = -k_qt->amplitude.re;
        k_qt->amplitude.im = -k_qt->amplitude.im;

        log_symbolic_event("MARGOLIS", k_qt->id, k_qt->tag, "Margolis gate triggered");
    } else {
        log_symbolic_event("MARGOLIS", k_qt->id, k_qt->tag, "Conditions not met");
    }
    return 0; // Indicate success for this path
}
EXPORT_SYMBOL_GPL(nymya_3343_margolis);



// Export the symbol for this function so other kernel modules/code can call it directly.


/**
 * SYSCALL_DEFINE3(nymya_3343_margolis) - Kernel syscall for Margolis gate.
 * @user_qc1: User-space pointer to the first control qubit structure.
 * @user_qc2: User-space pointer to the second control qubit structure.
 * @user_qt: User-space pointer to the target qubit structure.
 *
 * This syscall copies qubit data from user space to kernel space, calls the
 * core Margolis gate logic, and then copies the modified data back to user space.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user qubit pointer is NULL.
 * - -EFAULT if copying data to/from user space fails.
 */
SYSCALL_DEFINE3(nymya_3343_margolis,
    struct nymya_qubit __user *, user_qc1,
    struct nymya_qubit __user *, user_qc2,
    struct nymya_qubit __user *, user_qt) {

    struct nymya_qubit k_qc1, k_qc2, k_qt; // Kernel-space copies
    int ret = 0; // Return value for syscall

    // 1. Check for null pointers from user-space
    if (!user_qc1 || !user_qc2 || !user_qt) {
        pr_err("nymya_3343_margolis: Null user qubit pointer(s)\n");
        return -EINVAL; // Invalid argument
    }

    // 2. Copy the qubit structures from user space to kernel space
    if (copy_from_user(&k_qc1, user_qc1, sizeof(k_qc1))) {
        pr_err("nymya_3343_margolis: Failed to copy k_qc1 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_qc2, user_qc2, sizeof(k_qc2))) {
        pr_err("nymya_3343_margolis: Failed to copy k_qc2 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_qt, user_qt, sizeof(k_qt))) {
        pr_err("nymya_3343_margolis: Failed to copy k_qt from user\n");
        return -EFAULT; // Bad address
    }

    // 3. Call the core Margolis gate logic
    ret = nymya_3343_margolis(&k_qc1, &k_qc2, &k_qt);

    if (ret) {
        // Error already logged by core function
        return ret;
    }

    // 4. Copy the modified target qubit back to user space
    // Control qubits (k_qc1, k_qc2) are typically not modified by Margolis gate,
    // so only k_qt needs to be copied back.
    if (copy_to_user(user_qt, &k_qt, sizeof(k_qt))) {
        pr_err("nymya_3343_margolis: Failed to copy k_qt to user\n");
        ret = -EFAULT; // Bad address
    }

    return ret; // Return 0 on success, or error code if copy_to_user failed
}

#endif


```

---

## File: `nymya_3344_peres.c`

### Content

```c
// src/nymya_3344_peres.c
//
// This file implements the nymya_3344_peres syscall, which applies a
// three-qubit Peres gate. The Peres gate is a reversible logic gate that
// combines a CNOT gate and a Toffoli (Controlled-Controlled-NOT) gate.
// It is often used as a building block for other quantum circuits due to
// its universality and reversibility.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion and fixed-point arithmetic for kernel operations.

#include "nymya.h" // Common definitions like nymya_qubit, and gate macros

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3344_peres NYMYA_PERES_CODE

    #include <stdlib.h>  // Userland: For general utilities
    #include <math.h>    // Userland: For complex math functions (if needed by sub-gates)
    #include <complex.h> // Userland: For _Complex double type (if needed by sub-gates)
#else // __KERNEL__
    int nymya_3344_peres_kernel_logic(struct nymya_qubit *q1,
                                      struct nymya_qubit *q2,
                                      struct nymya_qubit *q3);


    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT
    #include <linux/printk.h>   // Kernel: For pr_err
    #include <linux/module.h>   // Kernel: For EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

/**
 * nymya_3344_peres - Applies the Peres gate to three qubits (userland).
 * @q1: Pointer to the first qubit (often a control for the CNOT).
 * @q2: Pointer to the second qubit (often a control for the Margolis/Toffoli part).
 * @q3: Pointer to the third qubit (often the target for both CNOT and Margolis/Toffoli).
 *
 * This function implements the Peres gate using a decomposition into a CNOT
 * gate followed by a Margolis (Controlled-Controlled-NOT/Toffoli-like) gate.
 * Specifically, it applies CNOT(q1, q3) and then Margolis(q1, q2, q3).
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL (invalid input).
 */
int nymya_3344_peres(nymya_qubit* q1, nymya_qubit* q2, nymya_qubit* q3) {
    // Basic null pointer checks
    if (!q1 || !q2 || !q3) return -1;

    // Apply the sequence of gates that compose the Peres gate
    cnot(q1, q3);               // Apply CNOT with q1 as control, q3 as target
    nymya_3343_margolis(q1, q2, q3); // Apply Margolis with q1, q2 as controls, q3 as target

    // Log the symbolic event for traceability
    log_symbolic_event("PERES", q1->id, q1->tag, "Peres gate applied");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3344_peres_kernel_logic - Applies the Peres gate to three qubits (kernel-space core logic).
 * @q1: Pointer to the first qubit (often a control for the CNOT).
 * @q2: Pointer to the second qubit (often a control for the Margolis/Toffoli part).
 * @q3: Pointer to the third qubit (often the target for both CNOT and Margolis/Toffoli).
 *
 * This function implements the Peres gate using a decomposition into kernel-level
 * CNOT and Margolis (Controlled-Controlled-NOT/Toffoli-like) gates.
 * Specifically, it applies CNOT(q1, q3) and then Margolis(q1, q2, q3).
 *
 * This function operates on kernel-space qubit structures and is intended to be
 * called by the `nymya_3344_peres` syscall implementation after copying data
 * from user space.
 *
 * Returns:
 * - 0 on success.
 * - Error code from underlying gate operations (e.g., nymya_3309_controlled_not).
 */
int nymya_3344_peres_kernel_logic(struct nymya_qubit *q1,
                                  struct nymya_qubit *q2,
                                  struct nymya_qubit *q3)
{
    int ret = 0;

    // Apply the Peres gate logic for kernel space
    ret = nymya_3309_controlled_not(q1, q3); // CNOT with q1 as control, q3 as target
    if (ret) {
        pr_err("nymya_3344_peres_kernel_logic: CNOT failed, error %d\n", ret);
        return ret;
    }

    ret = nymya_3343_margolis(q1, q2, q3); // Margolis with q1, q2 as controls, q3 as target
    if (ret) {
        pr_err("nymya_3344_peres_kernel_logic: Margolis failed, error %d\n", ret);
        return ret;
    }

    // Log the symbolic event for traceability
    log_symbolic_event("PERES", q1->id, q1->tag, "Peres gate applied");

    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3344_peres_kernel_logic);


/**
 * SYSCALL_DEFINE3(nymya_3344_peres) - Kernel syscall for Peres gate.
 * @user_q1: User-space pointer to the first qubit structure.
 * @user_q2: User-space pointer to the second qubit structure.
 * @user_q3: User-space pointer to the third qubit structure.
 *
 * This syscall copies qubit data from user space to kernel space, applies the
 * Peres gate logic using kernel-space functions, and then copies the modified
 * data back to user space. The Peres gate is decomposed into kernel-level
 * CNOT and Margolis gates.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user qubit pointer is NULL.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from underlying gate operations (e.g., nymya_3309_controlled_not).
 */
SYSCALL_DEFINE3(nymya_3344_peres,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2,
    struct nymya_qubit __user *, user_q3) {

    struct nymya_qubit k_q1, k_q2, k_q3; // Kernel-space copies of qubits
    int ret = 0; // Return value for syscall and gate operations

    // 1. Check for null pointers from user-space
    if (!user_q1 || !user_q2 || !user_q3) {
        pr_err("nymya_3344_peres: Null user qubit pointer(s)\n");
        return -EINVAL; // Invalid argument
    }

    // 2. Copy the qubit structures from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3344_peres: Failed to copy k_q1 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3344_peres: Failed to copy k_q2 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_q3, user_q3, sizeof(k_q3))) {
        pr_err("nymya_3344_peres: Failed to copy k_q3 from user\n");
        return -EFAULT; // Bad address
    }

    // 3. Apply the Peres gate logic for kernel space using the new helper function
    ret = nymya_3344_peres_kernel_logic(&k_q1, &k_q2, &k_q3);
    if (ret) {
        pr_err("nymya_3344_peres: Core logic failed, error %d\n", ret);
        return ret;
    }

    // 5. Copy the modified qubits back to user space
    // Note: All three qubits can be modified by the composite gate, so all should be copied back.
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3344_peres: Failed to copy k_q1 to user\n");
        ret = -EFAULT; // Bad address
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3344_peres: Failed to copy k_q2 to user\n");
        ret = -EFAULT; // Bad address
    }
    if (copy_to_user(user_q3, &k_q3, sizeof(k_q3))) {
        pr_err("nymya_3344_peres: Failed to copy k_q3 to user\n");
        ret = -EFAULT; // Bad address
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif
```

---

## File: `nymya_3345_cf_swap.c`

### Content

```c
// src/nymya_3345_cf_swap.c
//
// This file implements the nymya_3345_cf_swap syscall, which applies a
// Controlled-Fredkin (CF-SWAP) gate. This is a three-qubit gate where the
// swap operation between two target qubits (q1, q2) is controlled by a
// third qubit (qc). If the control qubit is in the |1> state, the target
// qubits are swapped; otherwise, no operation occurs on the targets.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion and fixed-point arithmetic for kernel operations.

#include "nymya.h" // Common definitions like complex_double, nymya_qubit, and fixed-point helpers

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3345_cf_swap NYMYA_CF_SWAP_CODE

    #include <stdlib.h>  // Userland: For general utilities
    #include <math.h>    // Userland: For cabs and other math functions
    #include <complex.h> // Userland: For _Complex double type and I macro
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT
    #include <linux/printk.h>   // Kernel: For pr_err
    #include <linux/module.h>   // Kernel: Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

/**
 * nymya_3345_cf_swap - Applies a Controlled-Fredkin (CF-SWAP) gate to three qubits (userland).
 * @qc: Pointer to the control qubit.
 * @q1: Pointer to the first target qubit.
 * @q2: Pointer to the second target qubit.
 *
 * This function implements a Controlled-Fredkin gate. If the control qubit's
 * amplitude magnitude squared is above a threshold (representing a '1' state),
 * it performs a fermionic simulation (which includes a swap) between the two
 * target qubits. Otherwise, no action is taken on the targets.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL (invalid input).
 */
int nymya_3345_cf_swap(nymya_qubit* qc, nymya_qubit* q1, nymya_qubit* q2) {
    // Basic null pointer checks
    if (!qc || !q1 || !q2) return -1;

    // In userland, qc->amplitude is _Complex double.
    // Calculate the magnitude squared directly using cabs().
    double qc_mag_sq = cabs(qc->amplitude) * cabs(qc->amplitude);

    // Define the threshold for control qubit being '1' (0.5^2 = 0.25)
    const double threshold_sq = 0.25;

    // If the control qubit's amplitude magnitude squared is above the threshold, perform the controlled operation
    if (qc_mag_sq > threshold_sq) {
        // The userland version calls nymya_3337_fermion_sim, which includes a swap and a phase flip.
        nymya_3337_fermion_sim(q1, q2);
        log_symbolic_event("CF_SWAP", q1->id, q1->tag, "Controlled Fermionic SWAP triggered");
    } else {
        log_symbolic_event("CF_SWAP", q1->id, q1->tag, "Control=0, no action");
    }
    return 0;
}

#else // __KERNEL__

/**
 * fixed_point_magnitude_sq - Calculates the squared magnitude of a fixed-point complex number.
 * @c: The fixed-point complex number.
 *
 * Returns:
 * The squared magnitude in fixed-point format.
 */
static inline int64_t fixed_point_magnitude_sq(complex_double c) {
    // Magnitude squared = re*re + im*im
    // Note: This assumes fixed_point_mul is available via nymya.h.
    return fixed_point_mul(c.re, c.re) + fixed_point_mul(c.im, c.im);
}

/**
 * nymya_3345_cf_swap - Applies a Controlled-Fredkin (CF-SWAP) gate to three qubits (kernel-space).
 * @qc: Pointer to the control qubit (in kernel space).
 * @q1: Pointer to the first target qubit (in kernel space).
 * @q2: Pointer to the second target qubit (in kernel space).
 *
 * This function implements the core logic for the Controlled-Fredkin gate.
 * It checks the state of the control qubit (@qc) using fixed-point arithmetic.
 * If the control qubit's amplitude magnitude squared is above a threshold
 * (representing a '1' state), it performs a fermionic simulation (which includes
 * a swap and phase flip) between the two target qubits (@q1, @q2).
 * Otherwise, no operation occurs on the target qubits.
 *
 * This function operates directly on kernel-space qubit structures and does not
 * handle user-space copying.
 *
 * Returns:
 * - 0 on success.
 * - Error code from underlying gate operations (e.g., nymya_3337_fermion_sim) on failure.
 */
int nymya_3345_cf_swap(struct nymya_qubit *qc, struct nymya_qubit *q1, struct nymya_qubit *q2) {
    int ret = 0;

    // Define the threshold for control qubit being '1' (0.5^2 = 0.25 in floating point)
    // Convert 0.25 to fixed-point squared value
    const int64_t threshold_sq_fp = FIXED_POINT_SCALE / 4; // Represents 0.25 in Q32.32

    // Check if the control qubit's amplitude magnitude squared is above the threshold
    if (fixed_point_magnitude_sq(qc->amplitude) > threshold_sq_fp) {
        // Control qubit is "on" (predominantly |1>)
        // Call the kernel version of nymya_3337_fermion_sim
        ret = nymya_3337_fermion_sim(q1, q2);
        if (ret == 0) {
            log_symbolic_event("CF_SWAP", q1->id, q1->tag, "Controlled Fermionic SWAP triggered");
        } else {
            pr_err("nymya_3345_cf_swap: Underlying fermionic simulation failed, error %d\n", ret);
        }
    } else {
        // Control qubit is "off" (predominantly |0>)
        log_symbolic_event("CF_SWAP", q1->id, q1->tag, "Control=0, no action");
        ret = 0; // No error, just no action
    }

    return ret;
}
EXPORT_SYMBOL_GPL(nymya_3345_cf_swap);


/**
 * SYSCALL_DEFINE3(nymya_3345_cf_swap) - Kernel syscall for Controlled-Fredkin (CF-SWAP) gate.
 * @user_qc: User-space pointer to the control qubit structure.
 * @user_q1: User-space pointer to the first target qubit structure.
 * @user_q2: User-space pointer to the second target qubit structure.
 *
 * This syscall copies qubit data from user space to kernel space, applies the
 * Controlled-Fredkin gate logic using kernel-space functions and fixed-point
 * arithmetic, and then copies the modified data back to user space. The gate
 * conditionally applies a fermionic simulation (including a swap and phase flip)
 * to the target qubits based on the control qubit's state.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user qubit pointer is NULL.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from underlying gate operations (e.g., nymya_3337_fermion_sim).
 */
SYSCALL_DEFINE3(nymya_3345_cf_swap,
    struct nymya_qubit __user *, user_qc,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2) {

    struct nymya_qubit k_qc, k_q1, k_q2; // Kernel-space copies
    int ret = 0; // Return value for syscall

    // 1. Check for null pointers from user-space
    if (!user_qc || !user_q1 || !user_q2) {
        pr_err("nymya_3345_cf_swap: Null user qubit pointer(s)\n");
        return -EINVAL; // Invalid argument
    }

    // 2. Copy the qubit structures from user space to kernel space
    if (copy_from_user(&k_qc, user_qc, sizeof(k_qc))) {
        pr_err("nymya_3345_cf_swap: Failed to copy k_qc from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3345_cf_swap: Failed to copy k_q1 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3345_cf_swap: Failed to copy k_q2 from user\n");
        return -EFAULT; // Bad address
    }

    // 3. Call the core kernel function to apply the gate logic
    ret = nymya_3345_cf_swap(&k_qc, &k_q1, &k_q2);
    if (ret != 0) {
        // If the core logic failed, propagate its error code
        return ret;
    }

    // 4. Copy the modified target qubits back to user space
    // Control qubit (k_qc) is typically not modified by Fredkin/CF-SWAP,
    // so only k_q1 and k_q2 need to be copied back.
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3345_cf_swap: Failed to copy k_q1 to user\n");
        return -EFAULT; // Bad address
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3345_cf_swap: Failed to copy k_q2 to user\n");
        return -EFAULT; // Bad address
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif

```

---

## File: `nymya_3346_triangular_lattice.c`

### Content

```c
// src/nymya_3346_triangular_lattice.c
//
// This file implements the nymya_3346_triangular_lattice syscall, which applies
// a sequence of operations to three qubits to simulate an interaction pattern
// often found in triangular lattice configurations. This typically involves
// entangling operations between adjacent qubits in the "triangle".
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion and fixed-point arithmetic for kernel operations.

#include "nymya.h" // Common definitions like nymya_qubit, and gate macros

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3346_triangular_lattice NYMYA_TRIANGULAR_LATTICE_CODE

    #include <stdlib.h>  // Userland: For general utilities
    #include <math.h>    // Userland: For complex math functions (if needed by sub-gates)
    #include <complex.h> // Userland: For _Complex double type (if needed by sub-gates)
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT
    #include <linux/printk.h>   // Kernel: For pr_err
    #include <linux/module.h>   // Kernel: Required for EXPORT_SYMBOL_GPL
    // No math.h or complex.h in kernel; fixed-point math assumed for amplitude operations
#endif

#ifndef __KERNEL__

/**
 * nymya_3346_triangular_lattice - Applies operations to three qubits in a triangular lattice (userland).
 * @q1: Pointer to the first qubit.
 * @q2: Pointer to the second qubit.
 * @q3: Pointer to the third qubit.
 *
 * This function simulates a triangular lattice interaction by applying a sequence
 * of gates: Hadamard on q1, then CNOT(q1, q2), CNOT(q2, q3), and CNOT(q3, q1).
 * This sequence creates entanglement across the three qubits in a cyclic manner.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer is NULL (invalid input).
 */
int nymya_3346_triangular_lattice(nymya_qubit* q1, nymya_qubit* q2, nymya_qubit* q3) {
    // Basic null pointer checks
    if (!q1 || !q2 || !q3) return -1;

    // Apply the sequence of gates to simulate triangular lattice interaction
    hadamard(q1);   // Hadamard on q1
    cnot(q1, q2);   // CNOT with q1 as control, q2 as target
    cnot(q2, q3);   // CNOT with q2 as control, q3 as target
    cnot(q3, q1);   // CNOT with q3 as control, q1 as target

    // Log the symbolic event for traceability
    log_symbolic_event("TRI_LATTICE", q1->id, q1->tag, "Triangle lattice formed");
    return 0;
}

#else // __KERNEL__

/**
 * nymya_3346_triangular_lattice - Applies operations to three qubits in a triangular lattice (kernel-space).
 * @q1: Pointer to the first kernel-space qubit structure.
 * @q2: Pointer to the second kernel-space qubit structure.
 * @q3: Pointer to the third kernel-space qubit structure.
 *
 * This function applies a sequence of gates to simulate a triangular lattice
 * interaction: Hadamard on q1, then CNOT(q1, q2), CNOT(q2, q3), and CNOT(q3, q1).
 * This sequence creates entanglement across the three qubits in a cyclic manner.
 * It operates directly on kernel-space qubit structures.
 *
 * Returns:
 * - 0 on success.
 * - An error code (e.g., from nymya_3308_hadamard_gate or nymya_3309_controlled_not) on failure.
 */
int nymya_3346_triangular_lattice(struct nymya_qubit *q1,
                                  struct nymya_qubit *q2,
                                  struct nymya_qubit *q3) {
    int ret;

    // Apply the sequence of gates to simulate triangular lattice interaction
    ret = nymya_3308_hadamard_gate(q1); // Hadamard on q1
    if (ret) {
        pr_err("nymya_3346_triangular_lattice: Hadamard on q1 failed, error %d\n", ret);
        return ret;
    }

    ret = nymya_3309_controlled_not(q1, q2); // CNOT(q1, q2)
    if (ret) {
        pr_err("nymya_3346_triangular_lattice: CNOT(q1, q2) failed, error %d\n", ret);
        return ret;
    }

    ret = nymya_3309_controlled_not(q2, q3); // CNOT(q2, q3)
    if (ret) {
        pr_err("nymya_3346_triangular_lattice: CNOT(q2, q3) failed, error %d\n", ret);
        return ret;
    }

    ret = nymya_3309_controlled_not(q3, q1); // CNOT(q3, q1)
    if (ret) {
        pr_err("nymya_3346_triangular_lattice: CNOT(q3, q1) failed, error %d\n", ret);
        return ret;
    }

    // Log the symbolic event for traceability
    log_symbolic_event("TRI_LATTICE", q1->id, q1->tag, "Triangle lattice formed");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3346_triangular_lattice);



/**
 * SYSCALL_DEFINE3(nymya_3346_triangular_lattice) - Kernel syscall for triangular lattice operation.
 * @user_q1: User-space pointer to the first qubit structure.
 * @user_q2: User-space pointer to the second qubit structure.
 * @user_q3: User-space pointer to the third qubit structure.
 *
 * This syscall copies qubit data from user space to kernel space, applies the
 * triangular lattice gate logic using kernel-space functions, and then copies
 * the modified data back to user space. The operation involves a sequence of
 * Hadamard and CNOT gates to entangle the three qubits.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any user qubit pointer is NULL.
 * - -EFAULT if copying data to/from user space fails.
 * - Error code from underlying gate operations (e.g., nymya_3308_hadamard_gate).
 */
SYSCALL_DEFINE3(nymya_3346_triangular_lattice,
    struct nymya_qubit __user *, user_q1,
    struct nymya_qubit __user *, user_q2,
    struct nymya_qubit __user *, user_q3) {

    struct nymya_qubit k_q1, k_q2, k_q3; // Kernel-space copies of qubits
    int ret = 0; // Return value for syscall and gate operations

    // 1. Check for null pointers from user-space
    if (!user_q1 || !user_q2 || !user_q3) {
        pr_err("nymya_3346_triangular_lattice: Null user qubit pointer(s)\n");
        return -EINVAL; // Invalid argument
    }

    // 2. Copy the qubit structures from user space to kernel space
    if (copy_from_user(&k_q1, user_q1, sizeof(k_q1))) {
        pr_err("nymya_3346_triangular_lattice: Failed to copy k_q1 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_q2, user_q2, sizeof(k_q2))) {
        pr_err("nymya_3346_triangular_lattice: Failed to copy k_q2 from user\n");
        return -EFAULT; // Bad address
    }
    if (copy_from_user(&k_q3, user_q3, sizeof(k_q3))) {
        pr_err("nymya_3346_triangular_lattice: Failed to copy k_q3 from user\n");
        return -EFAULT; // Bad address
    }

    // 3. Call the core kernel-space logic
    ret = nymya_3346_triangular_lattice(&k_q1, &k_q2, &k_q3);
    if (ret) {
        // Error already logged by the core function
        return ret;
    }

    // 4. Copy the modified qubits back to user space
    // All three qubits can be modified, so all should be copied back.
    if (copy_to_user(user_q1, &k_q1, sizeof(k_q1))) {
        pr_err("nymya_3346_triangular_lattice: Failed to copy k_q1 to user\n");
        ret = -EFAULT; // Bad address
    }
    if (copy_to_user(user_q2, &k_q2, sizeof(k_q2))) {
        pr_err("nymya_3346_triangular_lattice: Failed to copy k_q2 to user\n");
        ret = -EFAULT; // Bad address
    }
    if (copy_to_user(user_q3, &k_q3, sizeof(k_q3))) {
        pr_err("nymya_3346_triangular_lattice: Failed to copy k_q3 to user\n");
        ret = -EFAULT; // Bad address
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif

```

---

## File: `nymya_3347_hexagonal_lattice.c`

### Content

```c
// src/nymya_3347_hexagonal_lattice.c
//
// This file implements the nymya_3347_hexagonal_lattice syscall, which applies
// operations to six qubits arranged in a hexagonal lattice configuration. This
// typically involves entangling operations between adjacent qubits in the "hexagon".
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion and fixed-point arithmetic for kernel operations.

#include "nymya.h" // Common definitions like nymya_qubit, and gate macros

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3347_hexagonal_lattice NYMYA_HEXAGONAL_LATTICE_CODE

    #include <stdlib.h>  // Userland: For general utilities
    #include <math.h>    // Userland: For complex math functions (if needed by sub-gates)
    #include <complex.h> // Userland: For _Complex double type (if needed by sub-gates)
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT
    #include <linux/printk.h>   // Kernel: For pr_err
    #include <linux/slab.h>     // Kernel: For kmalloc, kfree
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/**
 * nymya_3347_hexagonal_lattice - Applies operations to six qubits in a hexagonal lattice (userland).
 * @q: An array of six pointers to nymya_qubit objects.
 *
 * This function simulates a hexagonal lattice interaction by applying a sequence
 * of gates: Hadamard on each qubit, then CNOT gates between adjacent qubits
 * in a cyclic manner (q[i] to q[(i+1)%6]). This creates entanglement across the
 * six qubits forming a hexagonal ring.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer in the array is NULL (invalid input).
 */
int nymya_3347_hexagonal_lattice(nymya_qubit* q[6]) {
    // Basic null pointer checks for each qubit in the array
    for (int i = 0; i < 6; i++) {
        if (!q[i]) return -1;
    }

    // Apply Hadamard gate to each qubit
    for (int i = 0; i < 6; i++) {
        hadamard(q[i]);
    }

    // Apply CNOT gates between adjacent qubits in a cyclic manner
    for (int i = 0; i < 6; i++) {
        cnot(q[i], q[(i + 1) % 6]);
    }

    // Log the symbolic event for traceability
    // Using the ID and tag of the first qubit for logging purposes.
    log_symbolic_event("HEX_LATTICE", q[0]->id, q[0]->tag, "Hexagonal ring lattice formed");
    return 0;
}

#else // __KERNEL__

/**
 * @brief Applies hexagonal lattice operations to an array of six kernel-space qubits.
 *
 * This function encapsulates the core quantum gate logic for the hexagonal lattice
 * operation. It applies Hadamard gates to each qubit, followed by cyclic CNOT
 * gates between adjacent qubits (q[i] to q[(i+1)%6]).
 *
 * @param k_qubits An array of pointers to six kernel-space nymya_qubit structures.
 *                 These structures are expected to be valid and allocated.
 * @return 0 on success, or a negative kernel error code if any underlying gate
 *         operation fails (e.g., from nymya_3308_hadamard_gate or nymya_3309_controlled_not).
 */
int nymya_3347_hexagonal_lattice(struct nymya_qubit *k_qubits[6]) {
    int ret = 0;
    int i;

    // Apply Hadamard gate to each qubit
    for (i = 0; i < 6; i++) {
        ret = nymya_3308_hadamard_gate(k_qubits[i]);
        if (ret) {
            pr_err("nymya_3347_hexagonal_lattice: Hadamard on q[%d] failed, error %d\n", i, ret);
            return ret;
        }
    }

    // Apply CNOT gates between adjacent qubits in a cyclic manner
    for (i = 0; i < 6; i++) {
        ret = nymya_3309_controlled_not(k_qubits[i], k_qubits[(i + 1) % 6]);
        if (ret) {
            pr_err("nymya_3347_hexagonal_lattice: CNOT(q[%d], q[%d]) failed, error %d\n", i, (i + 1) % 6, ret);
            return ret;
        }
    }

    // Log the symbolic event for traceability
    // Using the ID and tag of the first qubit for logging purposes.
    log_symbolic_event("HEX_LATTICE", k_qubits[0]->id, k_qubits[0]->tag, "Hexagonal ring lattice formed");

    return 0;
}

EXPORT_SYMBOL_GPL(nymya_3347_hexagonal_lattice); // Export the core function

/**
 * SYSCALL_DEFINE1(nymya_3347_hexagonal_lattice) - Kernel syscall for hexagonal lattice operation.
 * @user_q_array: User-space pointer to an array of 6 user-space qubit pointers.
 * (i.e., `struct nymya_qubit __user *[6]`)
 *
 * This syscall copies the array of user-space qubit pointers, then copies each
 * individual qubit structure from user space to kernel space. It applies the
 * hexagonal lattice gate logic using kernel-space functions (Hadamard and CNOT),
 * and finally copies the modified qubit data back to user space.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if the user_q_array pointer is NULL or any individual user qubit pointer is NULL.
 * - -EFAULT if copying data to/from user space fails for any qubit or pointer.
 * - -ENOMEM if kernel memory allocation fails.
 * - Error code from underlying gate operations (now propagated from nymya_3347_hexagonal_lattice).
 */
SYSCALL_DEFINE1(nymya_3347_hexagonal_lattice,
    struct nymya_qubit __user * __user *, user_q_array) {

    struct nymya_qubit *k_qubits[6]; // Array of pointers to kernel-space qubit data
    // Array to hold the user-space pointers themselves, copied from user_q_array
    struct nymya_qubit __user *user_qubit_ptrs[6];
    int ret = 0; // Return value for syscall and gate operations
    int i; // Loop counter

    // Initialize k_qubits pointers to NULL for safe cleanup
    for (i = 0; i < 6; i++) {
        k_qubits[i] = NULL;
    }

    // 1. Check for null pointer for the array of pointers itself
    if (!user_q_array) {
        pr_err("nymya_3347_hexagonal_lattice: Null user_q_array pointer\n");
        return -EINVAL; // Invalid argument
    }

    // 2. Copy the array of user-space qubit pointers from user space
    // This copies the addresses of the user-space qubits, not the qubit data itself.
    if (copy_from_user(user_qubit_ptrs, user_q_array, sizeof(user_qubit_ptrs))) {
        pr_err("nymya_3347_hexagonal_lattice: Failed to copy user qubit pointers array\n");
        return -EFAULT;
    }

    // 3. Allocate kernel memory for each qubit and copy individual qubit data from user space
    for (i = 0; i < 6; i++) {
        // Check if individual user-space qubit pointer is NULL
        if (!user_qubit_ptrs[i]) {
            pr_err("nymya_3347_hexagonal_lattice: Null individual user qubit pointer at index %d\n", i);
            ret = -EINVAL;
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Allocate memory for the kernel-space copy of the qubit
        k_qubits[i] = kmalloc(sizeof(struct nymya_qubit), GFP_KERNEL);
        if (!k_qubits[i]) {
            pr_err("nymya_3347_hexagonal_lattice: Failed to allocate memory for k_qubit[%d]\n", i);
            ret = -ENOMEM; // Out of memory
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Copy the actual qubit data from user space into the allocated kernel memory
        if (copy_from_user(k_qubits[i], user_qubit_ptrs[i], sizeof(struct nymya_qubit))) {
            pr_err("nymya_3347_hexagonal_lattice: Failed to copy k_qubit[%d] data from user\n", i);
            ret = -EFAULT; // Bad address
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }
    }

    // Call the newly extracted core logic function
    ret = nymya_3347_hexagonal_lattice(k_qubits);
    if (ret) {
        // Error from core logic, propagate it
        goto cleanup_k_qubits;
    }

    // 6. Copy the modified qubits back to user space
    // All six qubits can be modified, so all should be copied back.
    for (i = 0; i < 6; i++) {
        if (copy_to_user(user_qubit_ptrs[i], k_qubits[i], sizeof(struct nymya_qubit))) {
            pr_err("nymya_3347_hexagonal_lattice: Failed to copy k_qubit[%d] to user\n", i);
            // If previous ret was 0 (success), set it to -EFAULT.
            // If it was already an error from the core logic, we keep that error.
            if (ret == 0) {
                ret = -EFAULT;
            }
        }
    }

cleanup_k_qubits:
    // 7. Free all allocated kernel memory for qubits
    for (int j = 0; j < 6; j++) {
        if (k_qubits[j]) { // Only free if memory was successfully allocated
            kfree(k_qubits[j]);
            k_qubits[j] = NULL; // Prevent double free
        }
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif

```

---

## File: `nymya_3348_hex_rhombi_lattice.c`

### Content

```c
// src/nymya_3348_hex_rhombi_lattice.c
//
// This file implements the nymya_3348_hex_rhombi_lattice syscall, which applies
// operations to seven qubits arranged in a hexagonal-rhombic lattice configuration.
// This typically involves entangling operations between a central qubit and its
// surrounding six qubits, and then between the outer qubits to form rhombi.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion and fixed-point arithmetic for kernel operations.

#include "nymya.h" // Common definitions like nymya_qubit, and gate macros

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3348_hex_rhombi_lattice NYMYA_HEX_RHOMBI_LATTICE_CODE

    #include <stdlib.h>  // Userland: For general utilities
    #include <math.h>    // Userland: For complex math functions (if needed by sub-gates)
    #include <complex.h> // Userland: For _Complex double type (if needed by sub-gates)
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT
    #include <linux/printk.h>   // Kernel: For pr_err
    #include <linux/slab.h>     // Kernel: For kmalloc, kfree
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/**
 * nymya_3348_hex_rhombi_lattice - Applies operations to seven qubits in a hexagonal-rhombic lattice (userland).
 * @q: An array of seven pointers to nymya_qubit objects.
 * q[0] is typically the central qubit.
 * q[1] through q[6] are the surrounding hexagonal qubits.
 *
 * This function simulates a hexagonal-rhombic lattice interaction. It applies
 * Hadamard gates to the outer qubits and entangles the central qubit with
 * each outer qubit using CNOTs. It then creates rhombi structures by applying
 * CNOTs between adjacent outer qubits and connecting them back to the center.
 *
 * Returns:
 * - 0 on success.
 * - -1 if any qubit pointer in the array is NULL (invalid input).
 */
int nymya_3348_hex_rhombi_lattice(nymya_qubit* q[7]) {
    // Basic null pointer checks for each qubit in the array
    for (int i = 0; i < 7; i++) {
        if (!q[i]) return -1;
    }

    // Apply Hadamard to outer qubits (q[1] to q[6]) and entangle central qubit (q[0]) with them
    for (int i = 1; i < 7; i++) {
        hadamard(q[i]);     // Hadamard on outer qubit
        cnot(q[0], q[i]);   // CNOT with central q[0] as control, q[i] as target
    }

    // Create rhombi by entangling adjacent outer qubits and connecting back to center
    // Rhombi are formed by (q[i], q[i+1], q[0]).
    // Loop from q[1]-q[2] up to q[5]-q[6]
    for (int i = 1; i < 6; i++) {
        cnot(q[i], q[i + 1]);   // CNOT between adjacent outer qubits
        cnot(q[i + 1], q[0]);   // CNOT with outer qubit as control, central q[0] as target
    }
    // Complete the cycle for the last rhombus: (q[6], q[1], q[0])
    cnot(q[6], q[1]);       // CNOT between q[6] and q[1]
    cnot(q[1], q[0]);       // CNOT with q[1] as control, central q[0] as target

    // Log the symbolic event for traceability
    // Using the ID and tag of the central qubit for logging purposes.
    log_symbolic_event("HEX_RHOMBI", q[0]->id, q[0]->tag, "Hexagon tessellated into 3 rhombi");
    return 0;
}

#else // __KERNEL__


/**
 * nymya_3348_hex_rhombi_lattice - Applies operations to seven qubits in a hexagonal-rhombic lattice (kernel-side).
 * @k_qubits: An array of seven pointers to kernel-space nymya_qubit objects.
 *            k_qubits[0] is typically the central qubit.
 *            k_qubits[1] through k_qubits[6] are the surrounding hexagonal qubits.
 *
 * This function implements the core quantum gate logic for the hexagonal-rhombic
 * lattice. It applies Hadamard gates to the outer qubits and entangles the
 * central qubit with each outer qubit using CNOTs. It then forms rhombi structures
 * by applying CNOTs between adjacent outer qubits and connecting them back to the center.
 *
 * Returns:
 * - 0 on success.
 * - Error code from underlying gate operations (e.g., nymya_3308_hadamard_gate,
 *   nymya_3309_controlled_not) if any gate application fails.
 */
int nymya_3348_hex_rhombi_lattice(struct nymya_qubit *k_qubits[7]) {
    int ret = 0;
    int i;

    // Apply Hadamard to outer qubits (k_qubits[1] to k_qubits[6]) and entangle central qubit (k_qubits[0]) with them
    for (i = 1; i < 7; i++) {
        ret = nymya_3308_hadamard_gate(k_qubits[i]); // Hadamard on outer qubit
        if (ret) {
            pr_err("nymya_3348_hex_rhombi_lattice: Hadamard on q[%d] failed, error %d\n", i, ret);
            return ret; // Propagate error
        }
        ret = nymya_3309_controlled_not(k_qubits[0], k_qubits[i]); // CNOT(central, outer)
        if (ret) {
            pr_err("nymya_3348_hex_rhombi_lattice: CNOT(q[0], q[%d]) failed, error %d\n", i, ret);
            return ret; // Propagate error
        }
    }

    // Create rhombi by entangling adjacent outer qubits and connecting back to center
    // Rhombi are formed by (q[i], q[i+1], q[0]).
    // Loop from q[1]-q[2] up to q[5]-q[6]
    for (i = 1; i < 6; i++) {
        ret = nymya_3309_controlled_not(k_qubits[i], k_qubits[i + 1]); // CNOT(adjacent outer)
        if (ret) {
            pr_err("nymya_3348_hex_rhombi_lattice: CNOT(q[%d], q[%d]) failed, error %d\n", i, i + 1, ret);
            return ret; // Propagate error
        }
        ret = nymya_3309_controlled_not(k_qubits[i + 1], k_qubits[0]); // CNOT(outer, central)
        if (ret) {
            pr_err("nymya_3348_hex_rhombi_lattice: CNOT(q[%d], q[0]) failed, error %d\n", i + 1, ret);
            return ret; // Propagate error
        }
    }
    // Complete the cycle for the last rhombus: (q[6], q[1], q[0])
    ret = nymya_3309_controlled_not(k_qubits[6], k_qubits[1]); // CNOT(q[6], q[1])
    if (ret) {
        pr_err("nymya_3348_hex_rhombi_lattice: CNOT(q[6], q[1]) failed, error %d\n", ret);
        return ret; // Propagate error
    }
    ret = nymya_3309_controlled_not(k_qubits[1], k_qubits[0]); // CNOT(q[1], q[0])
    if (ret) {
        pr_err("nymya_3348_hex_rhombi_lattice: CNOT(q[1], q[0]) failed, error %d\n", ret);
        return ret; // Propagate error
    }

    // Log the symbolic event for traceability
    // Using the ID and tag of the central qubit for logging purposes.
    log_symbolic_event("HEX_RHOMBI", k_qubits[0]->id, k_qubits[0]->tag, "Hexagon tessellated into 3 rhombi");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3348_hex_rhombi_lattice);



/**
 * SYSCALL_DEFINE1(nymya_3348_hex_rhombi_lattice) - Kernel syscall for hexagonal-rhombic lattice operation.
 * @user_q_array: User-space pointer to an array of 7 user-space qubit pointers.
 * (i.e., `struct nymya_qubit __user *[7]`)
 *
 * This syscall copies the array of user-space qubit pointers, then copies each
 * individual qubit structure from user space to kernel space. It calls the
 * kernel-side core function `nymya_3348_hex_rhombi_lattice` to apply the gate logic,
 * and finally copies the modified qubit data back to user space.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if the user_q_array pointer is NULL or any individual user qubit pointer is NULL.
 * - -EFAULT if copying data to/from user space fails for any qubit or pointer.
 * - -ENOMEM if kernel memory allocation fails.
 * - Error code propagated from the underlying gate operations.
 */
SYSCALL_DEFINE1(nymya_3348_hex_rhombi_lattice,
    struct nymya_qubit __user * __user *, user_q_array) {

    struct nymya_qubit *k_qubits[7]; // Array of pointers to kernel-space qubit data
    // Array to hold the user-space pointers themselves, copied from user_q_array
    struct nymya_qubit __user *user_qubit_ptrs[7];
    int ret = 0; // Return value for syscall and gate operations
    int i; // Loop counter

    // Initialize k_qubits pointers to NULL for safe cleanup
    for (i = 0; i < 7; i++) {
        k_qubits[i] = NULL;
    }

    // 1. Check for null pointer for the array of pointers itself
    if (!user_q_array) {
        pr_err("sys_nymya_3348_hex_rhombi_lattice: Null user_q_array pointer\n");
        return -EINVAL; // Invalid argument
    }

    // 2. Copy the array of user-space qubit pointers from user space
    // This copies the addresses of the user-space qubits, not the qubit data itself.
    if (copy_from_user(user_qubit_ptrs, user_q_array, sizeof(user_qubit_ptrs))) {
        pr_err("sys_nymya_3348_hex_rhombi_lattice: Failed to copy user qubit pointers array\n");
        ret = -EFAULT;
        goto cleanup_k_qubits;
    }

    // 3. Allocate kernel memory for each qubit and copy individual qubit data from user space
    for (i = 0; i < 7; i++) {
        // Check if individual user-space qubit pointer is NULL
        if (!user_qubit_ptrs[i]) {
            pr_err("sys_nymya_3348_hex_rhombi_lattice: Null individual user qubit pointer at index %d\n", i);
            ret = -EINVAL;
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Allocate memory for the kernel-space copy of the qubit
        k_qubits[i] = kmalloc(sizeof(struct nymya_qubit), GFP_KERNEL);
        if (!k_qubits[i]) {
            pr_err("sys_nymya_3348_hex_rhombi_lattice: Failed to allocate memory for k_qubit[%d]\n", i);
            ret = -ENOMEM; // Out of memory
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Copy the actual qubit data from user space into the allocated kernel memory
        if (copy_from_user(k_qubits[i], user_qubit_ptrs[i], sizeof(struct nymya_qubit))) {
            pr_err("sys_nymya_3348_hex_rhombi_lattice: Failed to copy k_qubit[%d] data from user\n", i);
            ret = -EFAULT; // Bad address
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }
    }

    // 4. Call the core kernel function to apply the hexagonal-rhombic lattice logic
    ret = nymya_3348_hex_rhombi_lattice(k_qubits);
    if (ret) {
        pr_err("sys_nymya_3348_hex_rhombi_lattice: Core logic failed with error %d\n", ret);
        goto cleanup_k_qubits;
    }

    // 5. Copy the modified qubits back to user space
    // All seven qubits can be modified, so all should be copied back.
    for (i = 0; i < 7; i++) {
        if (copy_to_user(user_qubit_ptrs[i], k_qubits[i], sizeof(struct nymya_qubit))) {
            pr_err("sys_nymya_3348_hex_rhombi_lattice: Failed to copy k_qubit[%d] to user\n", i);
            // Set ret to -EFAULT if any copy fails, but continue to free memory
            if (ret == 0) ret = -EFAULT;
        }
    }

cleanup_k_qubits:
    // 6. Free all allocated kernel memory for qubits
    for (int j = 0; j < 7; j++) {
        if (k_qubits[j]) { // Only free if memory was successfully allocated
            kfree(k_qubits[j]);
            k_qubits[j] = NULL; // Prevent double free
        }
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif

```

---

## File: `nymya_3349_tessellated_triangles.c`

### Content

```c
// src/nymya_3349_tessellated_triangles.c
//
// This file implements the nymya_3349_tessellated_triangles syscall, which
// applies operations to a set of qubits arranged in a tessellated pattern of
// triangles. This function processes qubits in groups of three, applying a
// specific entangling sequence (Hadamard and CNOTs) to each triangle.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion, memory management, and fixed-point
// arithmetic for kernel operations.

#include "nymya.h" // Common definitions like nymya_qubit, and gate macros

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3349_tessellated_triangles NYMYA_TESS_TRIANGLES_CODE

    #include <stdlib.h>  // Userland: For general utilities (e.g., size_t)
    #include <math.h>    // Userland: For complex math functions (if needed by sub-gates)
    #include <complex.h> // Userland: For _Complex double type (if needed by sub-gates)
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT, -ENOMEM
    #include <linux/printk.h>   // Kernel: For pr_err
    #include <linux/slab.h>     // Kernel: For kmalloc, kfree, kmalloc_array
    #include <linux/module.h>
#endif

#ifndef __KERNEL__

/**
 * nymya_3349_tessellated_triangles - Applies operations across a tessellated pattern of triangles (userland).
 * @q: An array of pointers to nymya_qubit objects.
 * @count: The total number of qubits in the array.
 *
 * This function processes the provided qubits in groups of three, forming
 * "triangles". For each complete triangle (three qubits), it applies a
 * sequence of gates: Hadamard on the first qubit, then CNOT(a, b), CNOT(b, c),
 * and CNOT(c, a), where a, b, c are the qubits in the triangle. This simulates
 * entanglement patterns in a triangular lattice. The function only processes
 * full triangles, so any remaining qubits (if count is not a multiple of 3)
 * are ignored.
 *
 * Returns:
 * - 0 on success.
 * - -1 if the qubit array is NULL or if `count` is less than 3 (cannot form a triangle).
 * - -1 if any individual qubit pointer within a processed triangle is NULL.
 */
int nymya_3349_tessellated_triangles(nymya_qubit* q[], size_t count) {
    // Basic null pointer and minimum count check
    if (!q || count < 3) return -1;

    // Calculate the number of complete triangles that can be formed
    size_t groups = count / 3;

    // Iterate through each triangle group
    for (size_t g = 0; g < groups; g++) {
        // Get pointers to the three qubits in the current triangle
        nymya_qubit *a = q[3 * g];
        nymya_qubit *b = q[3 * g + 1];
        nymya_qubit *c = q[3 * g + 2];

        // Check for null pointers within the current triangle
        if (!a || !b || !c) return -1; // Return error if any qubit in the triangle is NULL

        // Apply the gate sequence for a triangular entanglement
        hadamard(a);   // Hadamard on qubit 'a'
        cnot(a, b);    // CNOT with 'a' as control, 'b' as target
        cnot(b, c);    // CNOT with 'b' as control, 'c' as target
        cnot(c, a);    // CNOT with 'c' as control, 'a' as target

        // Log the symbolic event for traceability, using the first qubit of the triangle
        log_symbolic_event("TRI_TESS", a->id, a->tag, "Triangle entangle");
    }
    return 0; // Success
}

#else // __KERNEL__

/**
 * @brief Applies tessellated triangle operations to kernel-space qubits.
 *
 * This function processes an array of kernel-space nymya_qubit structures
 * in groups of three, forming "triangles". For each complete triangle,
 * it applies a sequence of gates: Hadamard on the first qubit, then CNOT(a, b),
 * CNOT(b, c), and CNOT(c, a), where a, b, c are the qubits in the triangle.
 *
 * This function operates purely on kernel-space qubit structures and
 * does not handle user-space memory operations. It expects `k_qubits`
 * to be an array of valid kernel-allocated `struct nymya_qubit *`.
 *
 * @param k_qubits A pointer to an array of kernel-space nymya_qubit pointers.
 * @param count The total number of qubits in the `k_qubits` array.
 * @return 0 on success, or a negative kernel error code on failure.
 *         Possible errors include those from underlying gate operations
 *         (e.g., nymya_3308_hadamard_gate, nymya_3309_controlled_not).
 */
int nymya_3349_tessellated_triangles(struct nymya_qubit **k_qubits, size_t count) {
    int ret = 0; // Return value for gate operations
    size_t groups; // Number of complete triangles
    size_t g; // Loop counter for groups

    // The syscall wrapper handles initial validation of `count < 3`.
    // This function assumes `k_qubits` is a valid kernel array.
    groups = count / 3;

    // Iterate through each triangle group
    for (g = 0; g < groups; g++) {
        // Get pointers to the three qubits in the current triangle (kernel-space copies)
        struct nymya_qubit *a = k_qubits[3 * g];
        struct nymya_qubit *b = k_qubits[3 * g + 1];
        struct nymya_qubit *c = k_qubits[3 * g + 2];

        // Apply the gate sequence for a triangular entanglement using kernel functions
        ret = nymya_3308_hadamard_gate(a); // Hadamard on qubit 'a'
        if (ret) {
            pr_err("nymya_3349_tessellated_triangles: Hadamard on triangle %zu, qubit 'a' failed, error %d\n", g, ret);
            return ret; // Propagate error
        }

        ret = nymya_3309_controlled_not(a, b); // CNOT(a, b)
        if (ret) {
            pr_err("nymya_3349_tessellated_triangles: CNOT(a, b) on triangle %zu failed, error %d\n", g, ret);
            return ret; // Propagate error
        }

        ret = nymya_3309_controlled_not(b, c); // CNOT(b, c)
        if (ret) {
            pr_err("nymya_3349_tessellated_triangles: CNOT(b, c) on triangle %zu failed, error %d\n", g, ret);
            return ret; // Propagate error
        }

        ret = nymya_3309_controlled_not(c, a); // CNOT(c, a)
        if (ret) {
            pr_err("nymya_3349_tessellated_triangles: CNOT(c, a) on triangle %zu failed, error %d\n", g, ret);
            return ret; // Propagate error
        }

        // Log the symbolic event for traceability
        log_symbolic_event("TRI_TESS", a->id, a->tag, "Triangle entangle");
    }

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3349_tessellated_triangles);



/**
 * SYSCALL_DEFINE2(nymya_3349_tessellated_triangles) - Kernel syscall for tessellated triangles operation.
 * @user_q_array: User-space pointer to an array of user-space qubit pointers.
 * (i.e., `struct nymya_qubit __user *[]`)
 * @count: The total number of qubits in the array provided by user space.
 *
 * This syscall copies the array of user-space qubit pointers, then copies each
 * individual qubit structure from user space to kernel space. It applies the
 * tessellated triangular lattice gate logic using kernel-space functions
 * (Hadamard and CNOT) to groups of three qubits, and finally copies the
 * modified qubit data back to user space.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if the user_q_array pointer is NULL or `count` is less than 3,
 * or if any individual user qubit pointer within a triangle is NULL.
 * - -EFAULT if copying data to/from user space fails for any qubit or pointer.
 * - -ENOMEM if kernel memory allocation fails.
 * - Error code from underlying gate operations (e.g., nymya_3308_hadamard_gate).
 */
SYSCALL_DEFINE2(nymya_3349_tessellated_triangles,
    struct nymya_qubit __user * __user *, user_q_array,
    size_t, count) {

    struct nymya_qubit **k_qubits = NULL; // Array of pointers to kernel-space qubit data
    struct nymya_qubit __user **user_qubit_ptrs = NULL; // Array to hold user-space pointers
    int ret = 0; // Return value for syscall and gate operations
    size_t i; // Loop counter

    // 1. Basic validation: Check for null array pointer and minimum count
    if (!user_q_array || count < 3) {
        pr_err("nymya_3349_tessellated_triangles: Invalid user_q_array or count (%zu)\n", count);
        return -EINVAL;
    }

    // 2. Allocate kernel memory for the array of user-space qubit pointers
    user_qubit_ptrs = kmalloc_array(count, sizeof(struct nymya_qubit __user *), GFP_KERNEL);
    if (!user_qubit_ptrs) {
        pr_err("nymya_3349_tessellated_triangles: Failed to allocate memory for user_qubit_ptrs array\n");
        return -ENOMEM;
    }

    // Copy the array of user-space qubit pointers from user space
    if (copy_from_user(user_qubit_ptrs, user_q_array, count * sizeof(struct nymya_qubit __user *))) {
        pr_err("nymya_3349_tessellated_triangles: Failed to copy user qubit pointers array\n");
        ret = -EFAULT;
        goto cleanup_user_ptrs_array;
    }

    // 3. Allocate kernel memory for the array of kernel-space qubit structures
    k_qubits = kmalloc_array(count, sizeof(struct nymya_qubit *), GFP_KERNEL);
    if (!k_qubits) {
        pr_err("nymya_3349_tessellated_triangles: Failed to allocate memory for k_qubits array\n");
        ret = -ENOMEM;
        goto cleanup_user_ptrs_array;
    }

    // Initialize k_qubits pointers to NULL for safe cleanup
    for (i = 0; i < count; i++) {
        k_qubits[i] = NULL;
    }

    // 4. Allocate memory for each individual qubit and copy data from user space
    for (i = 0; i < count; i++) {
        // Check if individual user-space qubit pointer is NULL
        if (!user_qubit_ptrs[i]) {
            pr_err("nymya_3349_tessellated_triangles: Null individual user qubit pointer at index %zu\n", i);
            ret = -EINVAL;
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Allocate memory for the kernel-space copy of the qubit
        k_qubits[i] = kmalloc(sizeof(struct nymya_qubit), GFP_KERNEL);
        if (!k_qubits[i]) {
            pr_err("nymya_3349_tessellated_triangles: Failed to allocate memory for k_qubit[%zu]\n", i);
            ret = -ENOMEM; // Out of memory
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Copy the actual qubit data from user space into the allocated kernel memory
        if (copy_from_user(k_qubits[i], user_qubit_ptrs[i], sizeof(struct nymya_qubit))) {
            pr_err("nymya_3349_tessellated_triangles: Failed to copy k_qubit[%zu] data from user\n", i);
            ret = -EFAULT; // Bad address
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }
    }

    // 5. Call the extracted core logic function
    ret = nymya_3349_tessellated_triangles(k_qubits, count);
    if (ret) {
        // Error already logged by the core function if it was a gate error.
        goto cleanup_k_qubits;
    }

    // 6. Copy the modified qubits back to user space
    // Only proceed if no errors occurred during core function execution (ret is 0 here)
    for (i = 0; i < count; i++) {
        // Copy the actual qubit data from kernel memory back to user space
        if (copy_to_user(user_qubit_ptrs[i], k_qubits[i], sizeof(struct nymya_qubit))) {
            pr_err("nymya_3349_tessellated_triangles: Failed to copy k_qubit[%zu] to user\n", i);
            // Set ret to -EFAULT if any copy fails, but continue to free memory
            if (ret == 0) ret = -EFAULT;
        }
    }

cleanup_k_qubits:
    // 7. Free all allocated kernel memory for individual qubits
    for (size_t j = 0; j < count; j++) {
        if (k_qubits && k_qubits[j]) { // Check if k_qubits array and individual pointer are valid
            kfree(k_qubits[j]);
            k_qubits[j] = NULL; // Prevent double free
        }
    }
    if (k_qubits) {
        kfree(k_qubits); // Free the array of pointers itself
        k_qubits = NULL;
    }

cleanup_user_ptrs_array:
    if (user_qubit_ptrs) {
        kfree(user_qubit_ptrs); // Free the array holding user-space pointers
        user_qubit_ptrs = NULL;
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif

```

---

## File: `nymya_3350_tessellated_hexagons.c`

### Content

```c
// src/nymya_3350_tessellated_hexagons.c
//
// This file implements the nymya_3350_tessellated_hexagons syscall, which
// applies operations to a set of qubits arranged in a tessellated pattern of
// hexagons. This function processes qubits in groups of six, applying a
// specific entangling sequence (Hadamard and CNOTs) to each hexagon.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion, memory management, and fixed-point
// arithmetic for kernel operations.

#include "nymya.h" // Common definitions like nymya_qubit, and gate macros

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3350_tessellated_hexagons NYMYA_TESS_HEXAGONS_CODE

    #include <stdlib.h>  // Userland: For general utilities (e.g., size_t)
    #include <math.h>    // Userland: For complex math functions (if needed by sub-gates)
    #include <complex.h> // Userland: For _Complex double type (if needed by sub-gates)
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT, -ENOMEM
    #include <linux/printk.h>   // Kernel: For pr_err
    #include <linux/slab.h>     // Kernel: For kmalloc, kfree, kmalloc_array
    #include <linux/module.h>   // Kernel: For EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/**
 * nymya_3350_tessellated_hexagons - Applies operations across a tessellated pattern of hexagons (userland).
 * @q: An array of pointers to nymya_qubit objects.
 * @count: The total number of qubits in the array.
 *
 * This function processes the provided qubits in groups of six, forming
 * "hexagons". For each complete hexagon (six qubits), it applies a
 * sequence of gates: Hadamard on each qubit within the hexagon, then CNOT
 * gates between adjacent qubits in a cyclic manner. This simulates
 * entanglement patterns in a hexagonal lattice. The function only processes
 * full hexagons, so any remaining qubits (if count is not a multiple of 6)
 * are ignored.
 *
 * Returns:
 * - 0 on success.
 * - -1 if the qubit array is NULL or if `count` is less than 6 (cannot form a hexagon).
 * - -1 if any individual qubit pointer within a processed hexagon is NULL.
 */
int nymya_3350_tessellated_hexagons(nymya_qubit* q[], size_t count) {
    // Basic null pointer and minimum count check
    if (!q || count < 6) return -1;

    // Calculate the number of complete hexagons that can be formed
    size_t groups = count / 6;

    // Iterate through each hexagon group
    for (size_t g = 0; g < groups; g++) {
        size_t base = 6 * g; // Base index for the current hexagon's qubits

        // Check for null pointers within the current hexagon and apply Hadamard
        for (int i = 0; i < 6; i++) {
            if (!q[base + i]) return -1; // Return error if any qubit in the hexagon is NULL
            hadamard(q[base + i]);   // Hadamard on each qubit in the hexagon
        }

        // Apply CNOT gates between adjacent qubits in a cyclic manner
        for (int i = 0; i < 6; i++) {
            cnot(q[base + i], q[base + (i + 1) % 6]);
        }

        // Log the symbolic event for traceability, using the first qubit of the hexagon
        log_symbolic_event("HEX_TESS", q[base]->id, q[base]->tag, "Hexagon ring entangle");
    }
    return 0; // Success
}

#else // __KERNEL__

/**
 * @brief Applies operations across a tessellated pattern of hexagons (kernel core logic).
 *
 * This function contains the core quantum gate logic for applying operations
 * to qubits arranged in a tessellated hexagonal pattern. It operates on
 * kernel-space qubit structures. It processes qubits in groups of six,
 * applying a specific entangling sequence (Hadamard and CNOTs) to each hexagon.
 * The function only processes full hexagons; any remaining qubits (if count
 * is not a multiple of 6) are ignored.
 *
 * @param k_qubits An array of pointers to kernel-space `nymya_qubit` objects.
 * @param count The total number of qubits in the `k_qubits` array.
 * @return 0 on success, or a negative errno on failure.
 */
int nymya_3350_tessellated_hexagons(struct nymya_qubit **k_qubits, size_t count) {
    int ret = 0;
    size_t groups; // Number of complete hexagons

    // We assume basic validation (count >= 6, k_qubits and its elements valid)
    // has been done by the caller (the syscall wrapper).
    groups = count / 6;

    // Iterate through each hexagon group
    for (size_t g = 0; g < groups; g++) {
        size_t base = 6 * g; // Base index for the current hexagon's qubits

        // Apply Hadamard gate to each qubit in the hexagon
        for (int j = 0; j < 6; j++) {
            ret = nymya_3308_hadamard_gate(k_qubits[base + j]);
            if (ret) {
                pr_err("nymya_3350_tessellated_hexagons: Hadamard on hexagon %zu, qubit %d failed, error %d\n", g, j, ret);
                return ret; // Propagate error immediately
            }
        }

        // Apply CNOT gates between adjacent qubits in a cyclic manner
        for (int j = 0; j < 6; j++) {
            ret = nymya_3309_controlled_not(k_qubits[base + j], k_qubits[base + (j + 1) % 6]);
            if (ret) {
                pr_err("nymya_3350_tessellated_hexagons: CNOT(q[%zu+%d], q[%zu+%d]) on hexagon %zu failed, error %d\n", base, j, base, (j + 1) % 6, g, ret);
                return ret; // Propagate error immediately
            }
        }

        // Log the symbolic event for traceability
        log_symbolic_event("HEX_TESS", k_qubits[base]->id, k_qubits[base]->tag, "Hexagon ring entangle");
    }
    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3350_tessellated_hexagons);



/**
 * SYSCALL_DEFINE2(nymya_3350_tessellated_hexagons) - Kernel syscall for tessellated hexagons operation.
 * @user_q_array: User-space pointer to an array of user-space qubit pointers.
 * (i.e., `struct nymya_qubit __user *[]`)
 * @count: The total number of qubits in the array provided by user space.
 *
 * This syscall copies the array of user-space qubit pointers, then copies each
 * individual qubit structure from user space to kernel space. It applies the
 * tessellated hexagonal lattice gate logic using the kernel-space
 * `nymya_3350_tessellated_hexagons` function, and finally copies the
 * modified qubit data back to user space.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if the user_q_array pointer is NULL or `count` is less than 6,
 * or if any individual user qubit pointer within a hexagon is NULL.
 * - -EFAULT if copying data to/from user space fails for any qubit or pointer.
 * - -ENOMEM if kernel memory allocation fails.
 * - Error code from underlying gate operations (propagated from `nymya_3350_tessellated_hexagons`).
 */
SYSCALL_DEFINE2(nymya_3350_tessellated_hexagons,
    struct nymya_qubit __user * __user *, user_q_array,
    size_t, count) {

    struct nymya_qubit **k_qubits = NULL; // Array of pointers to kernel-space qubit data
    struct nymya_qubit __user **user_qubit_ptrs = NULL; // Array to hold user-space pointers
    int ret = 0; // Return value for syscall and gate operations
    size_t i; // Loop counter
    // size_t groups; // No longer needed here, calculated by core function

    // 1. Basic validation: Check for null array pointer and minimum count
    if (!user_q_array || count < 6) {
        pr_err("sys_nymya_3350_tessellated_hexagons: Invalid user_q_array or count (%zu)\n", count);
        return -EINVAL;
    }

    // Calculate the number of complete hexagons
    // groups = count / 6; // Moved calculation to core function

    // 2. Allocate kernel memory for the array of user-space qubit pointers
    user_qubit_ptrs = kmalloc_array(count, sizeof(struct nymya_qubit __user *), GFP_KERNEL);
    if (!user_qubit_ptrs) {
        pr_err("sys_nymya_3350_tessellated_hexagons: Failed to allocate memory for user_qubit_ptrs array\n");
        return -ENOMEM;
    }

    // Copy the array of user-space qubit pointers from user space
    if (copy_from_user(user_qubit_ptrs, user_q_array, count * sizeof(struct nymya_qubit __user *))) {
        pr_err("sys_nymya_3350_tessellated_hexagons: Failed to copy user qubit pointers array\n");
        ret = -EFAULT;
        goto cleanup_user_ptrs_array;
    }

    // 3. Allocate kernel memory for the array of kernel-space qubit structures
    k_qubits = kmalloc_array(count, sizeof(struct nymya_qubit *), GFP_KERNEL);
    if (!k_qubits) {
        pr_err("sys_nymya_3350_tessellated_hexagons: Failed to allocate memory for k_qubits array\n");
        ret = -ENOMEM;
        goto cleanup_user_ptrs_array;
    }

    // Initialize k_qubits pointers to NULL for safe cleanup
    for (i = 0; i < count; i++) {
        k_qubits[i] = NULL;
    }

    // 4. Allocate memory for each individual qubit and copy data from user space
    for (i = 0; i < count; i++) {
        // Check if individual user-space qubit pointer is NULL
        if (!user_qubit_ptrs[i]) {
            pr_err("sys_nymya_3350_tessellated_hexagons: Null individual user qubit pointer at index %zu\n", i);
            ret = -EINVAL;
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Allocate memory for the kernel-space copy of the qubit
        k_qubits[i] = kmalloc(sizeof(struct nymya_qubit), GFP_KERNEL);
        if (!k_qubits[i]) {
            pr_err("sys_nymya_3350_tessellated_hexagons: Failed to allocate memory for k_qubit[%zu]\n", i);
            ret = -ENOMEM; // Out of memory
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Copy the actual qubit data from user space into the allocated kernel memory
        if (copy_from_user(k_qubits[i], user_qubit_ptrs[i], sizeof(struct nymya_qubit))) {
            pr_err("sys_nymya_3350_tessellated_hexagons: Failed to copy k_qubit[%zu] data from user\n", i);
            ret = -EFAULT; // Bad address
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }
    }

    // 5. Call the extracted core logic function for kernel space
    ret = nymya_3350_tessellated_hexagons(k_qubits, count);
    if (ret) {
        // Error already logged by the core function
        goto cleanup_k_qubits;
    }

    // 6. Copy the modified qubits back to user space
    // Only proceed if no errors occurred during gate applications (ret == 0)
    for (i = 0; i < count; i++) {
        // Copy the actual qubit data from kernel memory back to user space
        if (copy_to_user(user_qubit_ptrs[i], k_qubits[i], sizeof(struct nymya_qubit))) {
            pr_err("sys_nymya_3350_tessellated_hexagons: Failed to copy k_qubit[%zu] to user\n", i);
            // If previous operations were successful (ret is 0), set ret to -EFAULT for copy_to_user failure.
            // If ret was already an error from core logic, preserve that error.
            if (ret == 0) ret = -EFAULT;
        }
    }

cleanup_k_qubits:
    // 7. Free all allocated kernel memory for individual qubits
    for (size_t j = 0; j < count; j++) {
        if (k_qubits && k_qubits[j]) { // Check if k_qubits array and individual pointer are valid
            kfree(k_qubits[j]);
            k_qubits[j] = NULL; // Prevent double free
        }
    }
    if (k_qubits) {
        kfree(k_qubits); // Free the array of pointers itself
        k_qubits = NULL;
    }

cleanup_user_ptrs_array:
    if (user_qubit_ptrs) {
        kfree(user_qubit_ptrs); // Free the array holding user-space pointers
        user_qubit_ptrs = NULL;
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif

```

---

## File: `nymya_3351_tessellated_hex_rhombi.c`

### Content

```c
// src/nymya_3351_tessellated_hex_rhombi.c
//
// This file implements the nymya_3351_tessellated_hex_rhombi syscall, which
// applies operations to a set of qubits arranged in a tessellated pattern of
// hexagonal-rhombic shapes. This function processes qubits in groups of seven
// (one central, six surrounding), applying specific entangling sequences
// (Hadamard and CNOTs) to each hex-rhombi unit.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion, memory management, and fixed-point
// arithmetic for kernel operations.

#include "nymya.h" // Common definitions like nymya_qubit, and gate macros

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3351_tessellated_hex_rhombi NYMYA_TESS_HEX_RHOMBI_CODE

#include <stdlib.h>  // Userland: For general utilities (e.g., size_t)
#include <math.h>    // Userland: For complex math functions (if needed by sub-gates)
#include <complex.h> // Userland: For _Complex double type (if needed by sub-gates)
#else // __KERNEL__
    int nymya_3351_tessellated_hex_rhombi_core(struct nymya_qubit **k_qubits, size_t count);


#include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
#include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
#include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
#include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT, -ENOMEM
#include <linux/printk.h>   // Kernel: For pr_err
#include <linux/slab.h>     // Kernel: For kmalloc, kfree, kmalloc_array
#include <linux/module.h>   // Kernel: For EXPORT_SYMBOL_GPL
#endif

#ifndef __KERNEL__

/**
 * nymya_3351_tessellated_hex_rhombi - Applies operations across a tessellated pattern of hexagonal-rhombic units (userland).
 * @q: An array of pointers to nymya_qubit objects.
 * @count: The total number of qubits in the array.
 *
 * This function processes the provided qubits in groups of seven, forming
 * "hex-rhombi" units (one central qubit and six surrounding ones). For each
 * complete unit, it applies a sequence of gates:
 * 1. Hadamard on each of the six outer qubits.
 * 2. CNOTs between the central qubit (q[base]) and each of the six outer qubits.
 * 3. CNOTs to form rhombi edges: between adjacent outer qubits and connecting
 * them back to the central qubit in a cyclic manner.
 * The function only processes full hex-rhombi units, so any remaining qubits
 * (if count is not a multiple of 7) are ignored.
 *
 * Returns:
 * - 0 on success.
 * - -1 if the qubit array is NULL or if `count` is less than 7 (cannot form a unit).
 * - -1 if any individual qubit pointer within a processed unit is NULL.
 */
int nymya_3351_tessellated_hex_rhombi(nymya_qubit* q[], size_t count) {
    // Basic null pointer and minimum count check
    if (!q || count < 7) return -1;

    // Calculate the number of complete hex-rhombi groups that can be formed
    size_t groups = count / 7;

    // Iterate through each hex-rhombi group
    for (size_t g = 0; g < groups; g++) {
        size_t base = 7 * g; // Base index for the current group's qubits

        // Check for null pointer for the central qubit
        if (!q[base]) return -1;

        // Entangle center with all six outer qubits
        for (int i = 1; i <= 6; i++) {
            if (!q[base + i]) return -1; // Check for null pointer for outer qubits
            hadamard(q[base + i]);   // Hadamard on outer qubit
            cnot(q[base], q[base + i]); // CNOT with central as control, outer as target
        }

        // Build rhombi edges: CNOTs between adjacent outer qubits and back to center
        // Loop for (q[1]-q[2]-q[0]-q[6]), (q[2]-q[3]-q[0]-q[1]), ...
        for (int i = 1; i <= 5; i++) {
            cnot(q[base + i], q[base + i + 1]);   // CNOT between adjacent outer qubits
            cnot(q[base + i + 1], q[base]);       // CNOT with outer as control, central as target
        }
        // Complete the cycle for the last rhombus: (q[6], q[1], q[0])
        cnot(q[base + 6], q[base + 1]);   // CNOT between q[6] and q[1]
        cnot(q[base + 1], q[base]);       // CNOT with q[1] as control, central q[0] as target

        // Log the symbolic event for traceability, using the central qubit of the group
        log_symbolic_event("HEX_RHOM_T", q[base]->id, q[base]->tag, "Hex→3 rhombi tessellate");
    }
    return 0; // Success
}

#else // __KERNEL__

/**
 * nymya_3351_tessellated_hex_rhombi_core - Applies operations across a tessellated pattern of hexagonal-rhombic units (kernel-space).
 * @k_qubits: An array of pointers to kernel-space nymya_qubit structures.
 * @count: The total number of qubits in the array.
 *
 * This function processes the provided qubits in groups of seven, forming
 * "hex-rhombi" units (one central qubit and six surrounding ones). For each
 * complete unit, it applies a sequence of gates: Hadamard, CNOTs, and then
 * CNOTs to form rhombi edges. It operates directly on kernel-space qubit data.
 * If `count` is less than 7, no units can be formed, and the function returns 0.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if any individual qubit pointer within a processed unit is NULL.
 * - Error code from underlying gate operations (e.g., nymya_3308_hadamard_gate,
 *   nymya_3309_controlled_not).
 */
int nymya_3351_tessellated_hex_rhombi_core(struct nymya_qubit **k_qubits, size_t count) {
    size_t groups;
    int ret = 0;

    // Calculate the number of complete hex-rhombi groups that can be formed
    if (count < 7) {
        // No full groups can be formed, so nothing to do. Return success.
        return 0;
    }
    groups = count / 7;

    // Apply the tessellated hex-rhombi logic for kernel space
    // Iterate through each hex-rhombi group
    for (size_t g = 0; g < groups; g++) {
        size_t base = 7 * g; // Base index for the current group's qubits

        // Check for null pointer for the central qubit in kernel space (should be handled by syscall, but defensive)
        if (!k_qubits[base]) {
            pr_err("nymya_3351_tessellated_hex_rhombi_core: Central qubit k_q[%zu] is NULL\n", base);
            return -EINVAL;
        }

        // Entangle center with all six outer qubits
        for (int j = 1; j <= 6; j++) {
            if (!k_qubits[base + j]) { // Defensive check
                pr_err("nymya_3351_tessellated_hex_rhombi_core: Outer qubit k_q[%zu+%d] is NULL\n", base, j);
                return -EINVAL;
            }
            ret = nymya_3308_hadamard_gate(k_qubits[base + j]); // Hadamard on outer qubit
            if (ret) {
                pr_err("nymya_3351_tessellated_hex_rhombi_core: Hadamard on outer qubit %d failed, error %d\n", j, ret);
                return ret;
            }
            ret = nymya_3309_controlled_not(k_qubits[base], k_qubits[base + j]); // CNOT(central, outer)
            if (ret) {
                pr_err("nymya_3351_tessellated_hex_rhombi_core: CNOT(central, outer %d) failed, error %d\n", j, ret);
                return ret;
            }
        }

        // Build rhombi edges: CNOTs between adjacent outer qubits and back to center
        for (int j = 1; j <= 5; j++) {
            if (!k_qubits[base + j] || !k_qubits[base + j + 1]) { // Defensive check
                pr_err("nymya_3351_tessellated_hex_rhombi_core: Rhombi qubits k_q[%zu+%d] or k_q[%zu+%d] are NULL\n", base, j, base, j + 1);
                return -EINVAL;
            }
            ret = nymya_3309_controlled_not(k_qubits[base + j], k_qubits[base + j + 1]); // CNOT between adjacent outer
            if (ret) {
                pr_err("nymya_3351_tessellated_hex_rhombi_core: CNOT(outer %d, outer %d) failed, error %d\n", j, j + 1, ret);
                return ret;
            }
            ret = nymya_3309_controlled_not(k_qubits[base + j + 1], k_qubits[base]); // CNOT(outer, central)
            if (ret) {
                pr_err("nymya_3351_tessellated_hex_rhombi_core: CNOT(outer %d, central) failed, error %d\n", j + 1, ret);
                return ret;
            }
        }
        // Complete the cycle for the last rhombus: (q[6], q[1], q[0])
        if (!k_qubits[base + 6] || !k_qubits[base + 1]) { // Defensive check
            pr_err("nymya_3351_tessellated_hex_rhombi_core: Last rhombus qubits k_q[%zu+6] or k_q[%zu+1] are NULL\n", base, base);
            return -EINVAL;
        }
        ret = nymya_3309_controlled_not(k_qubits[base + 6], k_qubits[base + 1]); // CNOT(q[6], q[1])
        if (ret) {
            pr_err("nymya_3351_tessellated_hex_rhombi_core: CNOT(q[6], q[1]) failed, error %d\n", ret);
            return ret;
        }
        ret = nymya_3309_controlled_not(k_qubits[base + 1], k_qubits[base]); // CNOT(q[1], q[0])
        if (ret) {
            pr_err("nymya_3351_tessellated_hex_rhombi_core: CNOT(q[1], q[0]) failed, error %d\n", ret);
            return ret;
        }

        // Log the symbolic event for traceability
        log_symbolic_event("HEX_RHOM_T", k_qubits[base]->id, k_qubits[base]->tag, "Hex→3 rhombi tessellate");
    }
    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3351_tessellated_hex_rhombi_core);


/**
 * SYSCALL_DEFINE2(nymya_3351_tessellated_hex_rhombi) - Kernel syscall for tessellated hex-rhombi lattice operation.
 * @user_q_array: User-space pointer to an array of user-space qubit pointers.
 * (i.e., `struct nymya_qubit __user *[]`)
 * @count: The total number of qubits in the array provided by user space.
 *
 * This syscall copies the array of user-space qubit pointers, then copies each
 * individual qubit structure from user space to kernel space. It applies the
 * tessellated hexagonal-rhombic lattice gate logic using the
 * `nymya_3351_tessellated_hex_rhombi_core` function to groups of seven qubits,
 * and finally copies the modified qubit data back to user space.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if the user_q_array pointer is NULL or `count` is less than 7,
 * or if any individual user qubit pointer within a unit is NULL.
 * - -EFAULT if copying data to/from user space fails for any qubit or pointer.
 * - -ENOMEM if kernel memory allocation fails.
 * - Error code from underlying gate operations (e.g., nymya_3308_hadamard_gate)
 *   propagated from `nymya_3351_tessellated_hex_rhombi_core`.
 */
SYSCALL_DEFINE2(nymya_3351_tessellated_hex_rhombi,
    struct nymya_qubit __user * __user *, user_q_array,
    size_t, count) {

    struct nymya_qubit **k_qubits = NULL; // Array of pointers to kernel-space qubit data
    struct nymya_qubit __user **user_qubit_ptrs = NULL; // Array to hold user-space pointers
    int ret = 0; // Return value for syscall and gate operations
    size_t i; // Loop counter

    // 1. Basic validation: Check for null array pointer and minimum count
    if (!user_q_array || count < 7) {
        pr_err("nymya_3351_tessellated_hex_rhombi: Invalid user_q_array or count (%zu)\n", count);
        return -EINVAL;
    }

    // 2. Allocate kernel memory for the array of user-space qubit pointers
    user_qubit_ptrs = kmalloc_array(count, sizeof(struct nymya_qubit __user *), GFP_KERNEL);
    if (!user_qubit_ptrs) {
        pr_err("nymya_3351_tessellated_hex_rhombi: Failed to allocate memory for user_qubit_ptrs array\n");
        return -ENOMEM;
    }

    // Copy the array of user-space qubit pointers from user space
    if (copy_from_user(user_qubit_ptrs, user_q_array, count * sizeof(struct nymya_qubit __user *))) {
        pr_err("nymya_3351_tessellated_hex_rhombi: Failed to copy user qubit pointers array\n");
        ret = -EFAULT;
        goto cleanup_user_ptrs_array;
    }

    // 3. Allocate kernel memory for the array of kernel-space qubit structures
    k_qubits = kmalloc_array(count, sizeof(struct nymya_qubit *), GFP_KERNEL);
    if (!k_qubits) {
        pr_err("nymya_3351_tessellated_hex_rhombi: Failed to allocate memory for k_qubits array\n");
        ret = -ENOMEM;
        goto cleanup_user_ptrs_array;
    }

    // Initialize k_qubits pointers to NULL for safe cleanup
    for (i = 0; i < count; i++) {
        k_qubits[i] = NULL;
    }

    // 4. Allocate memory for each individual qubit and copy data from user space
    for (i = 0; i < count; i++) {
        // Check if individual user-space qubit pointer is NULL
        if (!user_qubit_ptrs[i]) {
            pr_err("nymya_3351_tessellated_hex_rhombi: Null individual user qubit pointer at index %zu\n", i);
            ret = -EINVAL;
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Allocate memory for the kernel-space copy of the qubit
        k_qubits[i] = kmalloc(sizeof(struct nymya_qubit), GFP_KERNEL);
        if (!k_qubits[i]) {
            pr_err("nymya_3351_tessellated_hex_rhombi: Failed to allocate memory for k_qubit[%zu]\n", i);
            ret = -ENOMEM; // Out of memory
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Copy the actual qubit data from user space into the allocated kernel memory
        if (copy_from_user(k_qubits[i], user_qubit_ptrs[i], sizeof(struct nymya_qubit))) {
            pr_err("nymya_3351_tessellated_hex_rhombi: Failed to copy k_qubit[%zu] data from user\n", i);
            ret = -EFAULT; // Bad address
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }
    }

    // 5. Call the core logic function with kernel-space qubits
    ret = nymya_3351_tessellated_hex_rhombi_core(k_qubits, count);
    if (ret) {
        // Error already logged by core function, just propagate it
        goto cleanup_k_qubits;
    }

    // 6. Copy the modified qubits back to user space
    // Only proceed if no errors occurred during gate applications (ret == 0 at this point)
    for (i = 0; i < count; i++) {
        // Copy the actual qubit data from kernel memory back to user space
        if (copy_to_user(user_qubit_ptrs[i], k_qubits[i], sizeof(struct nymya_qubit))) {
            pr_err("nymya_3351_tessellated_hex_rhombi: Failed to copy k_qubit[%zu] to user\n", i);
            // Set ret to -EFAULT if any copy fails, but continue to free memory
            // This ensures all allocated kernel memory is freed even if some copy_to_user fails.
            if (ret == 0) ret = -EFAULT;
        }
    }

cleanup_k_qubits:
    // 7. Free all allocated kernel memory for individual qubits
    for (size_t j = 0; j < count; j++) {
        if (k_qubits && k_qubits[j]) { // Check if k_qubits array and individual pointer are valid
            kfree(k_qubits[j]);
            k_qubits[j] = NULL; // Prevent double free
        }
    }
    if (k_qubits) {
        kfree(k_qubits); // Free the array of pointers itself
        k_qubits = NULL;
    }

cleanup_user_ptrs_array:
    if (user_qubit_ptrs) {
        kfree(user_qubit_ptrs); // Free the array holding user-space pointers
        user_qubit_ptrs = NULL;
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif
```

---

## File: `nymya_3352_e8_group.c`

### Content

```c
// src/nymya_3352_e8_group.c
//
// This file implements the nymya_3352_e8_group syscall, which applies
// operations to eight qubits, simulating entanglement patterns related to
// the E8 Lie group. The core exports a fixed-size array signature matching
// the header declaration.

#include "nymya.h" // Common definitions like nymya_qubit and gate macros

#ifndef __KERNEL__
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <complex.h>

/**
 * nymya_3352_e8_group - Applies E8 group entanglement (userland)
 * @q: array of 8 pointers to nymya_qubit
 *
 * Applies Hadamard to each qubit, then for every pair (i<j):
 *    cnot(q[i],q[j]); cnot(q[j],q[i]);
 * Returns 0 on success, -1 on null pointer.
 */
int nymya_3352_e8_group(nymya_qubit* q[8]) {
    for (int i = 0; i < 8; i++) {
        if (!q[i]) return -1;
        hadamard(q[i]);
    }
    for (int i = 0; i < 8; i++) {
        for (int j = i+1; j < 8; j++) {
            cnot(q[i], q[j]);
            cnot(q[j], q[i]);
        }
    }
    log_symbolic_event("E8_GROUP", q[0]->id, q[0]->tag, "E8 8-node full entanglement");
    return 0;
}

#else // __KERNEL__
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/errno.h>
#include <linux/printk.h>
#include <linux/slab.h>
#include <linux/module.h>

/**
 * nymya_3352_e8_group - Applies E8 group entanglement (kernel)
 * @q: array of 8 pointers to kernel-space nymya_qubit
 *
 * Matches declaration: int nymya_3352_e8_group(nymya_qubit* q[8]);
 */
int nymya_3352_e8_group(nymya_qubit* q[8]) {
    int ret;
    for (int i = 0; i < 8; i++) {
        if (!q[i]) return -EINVAL;
        ret = nymya_3308_hadamard_gate(q[i]);
        if (ret) return ret;
    }
    for (int i = 0; i < 8; i++) {
        for (int j = i+1; j < 8; j++) {
            ret = nymya_3309_controlled_not(q[i], q[j]); if (ret) return ret;
            ret = nymya_3309_controlled_not(q[j], q[i]); if (ret) return ret;
        }
    }
    log_symbolic_event("E8_GROUP", q[0]->id, q[0]->tag, "E8 8-node full entanglement");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3352_e8_group);

/**
 * SYSCALL_DEFINE1 - Kernel entry point for syscall
 * @user_q: User-space array of 8 pointers to nymya_qubit
 *
 * This syscall copies the array of qubit pointers and each qubit struct
 * into kernel space, runs the entanglement logic, then copies them back.
 */
SYSCALL_DEFINE1(nymya_3352_e8_group,
    nymya_qubit* __user *, user_q)
{
    nymya_qubit* k_q[8];
    int ret;  // return value for core function

    // Copy user pointers
    if (copy_from_user(k_q, user_q, 8 * sizeof(nymya_qubit *)))
        return -EFAULT;

    // Copy structures individually
    for (int i = 0; i < 8; i++) {
        if (!k_q[i])
            return -EINVAL;
        if (copy_from_user(&k_q[i][0], k_q[i], sizeof(nymya_qubit)))
            return -EFAULT;
    }

    // Core logic
    ret = nymya_3352_e8_group(k_q);

    // Copy back modified qubits
    for (int i = 0; i < 8; i++) {
        if (copy_to_user(k_q[i], &k_q[i][0], sizeof(nymya_qubit)))
            return -EFAULT;
    }

    return ret;
}

#endif // __KERNEL__


```

---

## File: `nymya_3353_flower_of_life.c`

### Content

```c
// src/nymya_3353_flower_of_life.c
//
// This file implements the nymya_3353_flower_of_life syscall, which applies
// operations to a set of qubits arranged in a pattern inspired by the
// "Flower of Life" geometric design. This involves entangling a central
// qubit with surrounding ones and then creating connections between the
// outer qubits to form a complex entangled structure.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion, robust memory management, and fixed-point
// arithmetic for kernel operations.

#include "nymya.h" // Common definitions like nymya_qubit, and gate macros

#ifndef __KERNEL__
#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
    #include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#define __NR_nymya_3353_flower_of_life NYMYA_FLOWER_OF_LIFE_CODE

    #include <stdlib.h>  // Userland: For general utilities (e.g., size_t)
    #include <math.h>    // Userland: For complex math functions (if needed by sub-gates)
    #include <complex.h> // Userland: For _Complex double type (if needed by sub-gates)
#else
    #include <linux/kernel.h>   // Kernel: For pr_err and general kernel functions
    #include <linux/syscalls.h> // Kernel: For SYSCALL_DEFINE macros
    #include <linux/uaccess.h>  // Kernel: For copy_from_user, copy_to_user
    #include <linux/errno.h>    // Kernel: For error codes like -EINVAL, -EFAULT, -ENOMEM
    #include <linux/printk.h>   // Kernel: For pr_err
    #include <linux/slab.h>     // Kernel: For kmalloc, kfree, kmalloc_array
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL


/**
 * nymya_3353_flower_of_life - Applies the "Flower of Life" entanglement pattern to kernel-space qubits.
 * @k_qubits: An array of pointers to kernel-space nymya_qubit objects.
 * @count: The total number of qubits in the array.
 *
 * This function applies entanglement patterns inspired by the "Flower of Life"
 * geometry. It expects at least 19 qubits to form a central qubit and two rings
 * of 6 and 12 qubits, respectively. The operations include:
 * 1. Applying Hadamard gates to all 19 qubits.
 * 2. Entangling the central qubit (k_qubits[0]) with all other 18 qubits using CNOTs.
 * 3. Applying CNOTs between adjacent qubits in the first ring (k_qubits[1] to k_qubits[6] cyclically).
 * 4. Applying CNOTs between adjacent qubits in the second ring (k_qubits[7] to k_qubits[18] cyclically).
 *
 * This function operates directly on kernel-space `nymya_qubit` structures.
 * It does not handle user-space memory operations.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if `count` is less than 19, or if any required qubit index is out of bounds.
 * - Error code from underlying gate operations (e.g., nymya_3308_hadamard_gate,
 *   nymya_3309_controlled_not).
 */
int nymya_3353_flower_of_life(struct nymya_qubit **k_qubits, size_t count) {
    int ret = 0;
    size_t i;
    static const size_t required_qubits = 19;

    // The syscall layer should ensure k_qubits is not NULL and count is sufficient
    // before calling this function, but a defensive check is included.
    if (!k_qubits || count < required_qubits) {
        pr_err("nymya_3353_flower_of_life: Internal error - invalid k_qubits array or count (%zu). Expected %zu.\n", count, required_qubits);
        return -EINVAL;
    }

    // Apply Hadamard to all 19 qubits
    for (i = 0; i < required_qubits; i++) {
        ret = nymya_3308_hadamard_gate(k_qubits[i]);
        if (ret) {
            pr_err("nymya_3353_flower_of_life: Hadamard on q[%zu] failed, error %d\n", i, ret);
            return ret;
        }
    }

    // Entangle the central qubit (k_qubits[0]) with all other 18 qubits
    for (i = 1; i < required_qubits; i++) {
        ret = nymya_3309_controlled_not(k_qubits[0], k_qubits[i]);
        if (ret) {
            pr_err("nymya_3353_flower_of_life: CNOT(q[0], q[%zu]) failed, error %d\n", i, ret);
            return ret;
        }
    }

    // Entangle qubits in the first ring (k_qubits[1] to k_qubits[6]) cyclically
    for (int j = 1; j <= 6; j++) {
        size_t current_idx = j;
        size_t next_idx = (j % 6) + 1; // 1->2, 2->3, ..., 6->1

        // Defensive check
        if (current_idx >= required_qubits || next_idx >= required_qubits) {
            pr_err("nymya_3353_flower_of_life: Ring 1 CNOT indices out of bounds: %zu, %zu (expected < %zu)\n", current_idx, next_idx, required_qubits);
            return -EINVAL;
        }
        ret = nymya_3309_controlled_not(k_qubits[current_idx], k_qubits[next_idx]);
        if (ret) {
            pr_err("nymya_3353_flower_of_life: CNOT(q[%zu], q[%zu]) failed, error %d\n", current_idx, next_idx, ret);
            return ret;
        }
    }

    // Entangle qubits in the second ring (k_qubits[7] to k_qubits[18]) cyclically
    for (int j = 7; j < 18; j++) {
        size_t current_idx = j;
        size_t next_idx = j + 1;

        // Defensive check
        if (current_idx >= required_qubits || next_idx >= required_qubits) {
            pr_err("nymya_3353_flower_of_life: Ring 2 CNOT indices out of bounds: %zu, %zu (expected < %zu)\n", current_idx, next_idx, required_qubits);
            return -EINVAL;
        }
        ret = nymya_3309_controlled_not(k_qubits[current_idx], k_qubits[next_idx]);
        if (ret) {
            pr_err("nymya_3353_flower_of_life: CNOT(q[%zu], q[%zu]) failed, error %d\n", current_idx, next_idx, ret);
            return ret;
        }
    }
    // Complete the cycle for the last connection: q[18] to q[7]
    // Defensive check
    if (18 >= required_qubits || 7 >= required_qubits) {
        pr_err("nymya_3353_flower_of_life: Last Ring 2 CNOT indices out of bounds: 18, 7 (expected < %zu)\n", required_qubits);
        return -EINVAL;
    }
    ret = nymya_3309_controlled_not(k_qubits[18], k_qubits[7]);
    if (ret) {
        pr_err("nymya_3353_flower_of_life: CNOT(q[18], q[7]) failed, error %d\n", ret);
        return ret;
    }

    // Log the symbolic event for traceability
    log_symbolic_event("FLOWER", k_qubits[0]->id, k_qubits[0]->tag, "Flower of Life pattern entangled");

    return 0; // Success
}
EXPORT_SYMBOL_GPL(nymya_3353_flower_of_life);

/**
 * SYSCALL_DEFINE2(nymya_3353_flower_of_life) - Kernel syscall for Flower of Life entanglement operation.
 * @user_q_array: User-space pointer to an array of user-space qubit pointers.
 * (i.e., `struct nymya_qubit __user *[]`)
 * @count: The total number of qubits in the array provided by user space.
 *
 * This syscall copies the array of user-space qubit pointers, then copies each
 * individual qubit structure from user space to kernel space. It applies the
 * Flower of Life entanglement logic using kernel-space functions (Hadamard and CNOT)
 * to 19 qubits (if available), and finally copies the modified qubit data back to user space.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if the user_q_array pointer is NULL or `count` is less than 19,
 * or if any individual user qubit pointer within the unit is NULL.
 * - -EFAULT if copying data to/from user space fails for any qubit or pointer.
 * - -ENOMEM if kernel memory allocation fails.
 * - Error code from underlying gate operations (e.g., nymya_3308_hadamard_gate).
 */
SYSCALL_DEFINE2(nymya_3353_flower_of_life,
    struct nymya_qubit __user * __user *, user_q_array,
    size_t, count) {

    struct nymya_qubit **k_qubits = NULL; // Pointer to array of kernel-space qubit pointers
    struct nymya_qubit __user **user_qubit_ptrs = NULL; // Pointer to array of user-space qubit pointers
    int ret = 0; // Return value for syscall and gate operations
    size_t i; // Loop counter
    const size_t required_qubits = 19; // Minimum qubits for one Flower of Life unit

    // 1. Basic validation: Check for null array pointer and minimum count
    if (!user_q_array || count < required_qubits) {
        pr_err("nymya_3353_flower_of_life: Invalid user_q_array or count (%zu). Minimum %zu qubits required.\n", count, required_qubits);
        return -EINVAL;
    }

    // 2. Allocate kernel memory for the array of user-space qubit pointers
    user_qubit_ptrs = kmalloc_array(count, sizeof(struct nymya_qubit __user *), GFP_KERNEL);
    if (!user_qubit_ptrs) {
        pr_err("nymya_3353_flower_of_life: Failed to allocate memory for user_qubit_ptrs array\n");
        return -ENOMEM;
    }

    // Copy the array of user-space qubit pointers from user space
    if (copy_from_user(user_qubit_ptrs, user_q_array, count * sizeof(struct nymya_qubit __user *))) {
        pr_err("nymya_3353_flower_of_life: Failed to copy user qubit pointers array\n");
        ret = -EFAULT;
        goto cleanup_user_ptrs_array;
    }

    // 3. Allocate kernel memory for the array of kernel-space qubit structures
    k_qubits = kmalloc_array(count, sizeof(struct nymya_qubit *), GFP_KERNEL);
    if (!k_qubits) {
        pr_err("nymya_3353_flower_of_life: Failed to allocate memory for k_qubits array\n");
        ret = -ENOMEM;
        goto cleanup_user_ptrs_array;
    }

    // Initialize k_qubits elements to NULL for safe cleanup
    for (i = 0; i < count; i++) {
        k_qubits[i] = NULL;
    }

    // 4. Allocate memory for each individual qubit and copy data from user space
    for (i = 0; i < count; i++) {
        // Check if individual user-space qubit pointer is NULL
        if (!user_qubit_ptrs[i]) {
            pr_err("nymya_3353_flower_of_life: Null individual user qubit pointer at index %zu\n", i);
            ret = -EINVAL;
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Allocate memory for the kernel-space copy of the qubit
        k_qubits[i] = kmalloc(sizeof(struct nymya_qubit), GFP_KERNEL);
        if (!k_qubits[i]) {
            pr_err("nymya_3353_flower_of_life: Failed to allocate memory for k_qubit[%zu]\n", i);
            ret = -ENOMEM; // Out of memory
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }

        // Copy the actual qubit data from user space into the allocated kernel memory
        if (copy_from_user(k_qubits[i], user_qubit_ptrs[i], sizeof(struct nymya_qubit))) {
            pr_err("nymya_3353_flower_of_life: Failed to copy k_qubit[%zu] data from user\n", i);
            ret = -EFAULT; // Bad address
            goto cleanup_k_qubits; // Jump to cleanup allocated memory
        }
    }

    // 5. Call the extracted core logic function
    ret = nymya_3353_flower_of_life(k_qubits, count);
    if (ret) {
        pr_err("nymya_3353_flower_of_life: Core logic failed with error %d\n", ret);
        goto cleanup_k_qubits;
    }

    // 6. Copy the modified qubits back to user space
    // Only proceed if no errors occurred during gate applications
    if (ret == 0) { // This check is redundant after the `if (ret)` block above, but harmless.
        for (i = 0; i < count; i++) {
            // Copy the actual qubit data from kernel memory back to user space
            if (copy_to_user(user_qubit_ptrs[i], k_qubits[i], sizeof(struct nymya_qubit))) {
                pr_err("nymya_3353_flower_of_life: Failed to copy k_qubit[%zu] to user\n", i);
                // Set ret to -EFAULT if any copy fails, but continue to free memory
                if (ret == 0) ret = -EFAULT; // Preserve first error
            }
        }
    }

cleanup_k_qubits:
    // 7. Free all allocated kernel memory for individual qubits
    for (size_t j = 0; j < count; j++) {
        if (k_qubits && k_qubits[j]) { // Check if k_qubits array pointer is valid and individual pointer is valid
            kfree(k_qubits[j]);
            k_qubits[j] = NULL;
        }
    }
    if (k_qubits) {
        kfree(k_qubits); // Free the array of pointers itself
        k_qubits = NULL;
    }

cleanup_user_ptrs_array:
    if (user_qubit_ptrs) {
        kfree(user_qubit_ptrs); // Free the array holding user-space pointers
        user_qubit_ptrs = NULL;
    }

    return ret; // Return 0 on success, or error code if any operation failed
}

#endif

```

---

## File: `nymya_3354_metatron_cube.c`

### Content

```c
// src/nymya_3354_metatron_cube.c
//
// This file implements the nymya_3354_metatron_cube syscall, which applies
// operations to a set of qubits arranged in a pattern inspired by the
// "Metatron's Cube" geometric design. This involves entangling a central
// qubit with surrounding ones and then creating connections between specific
// outer qubits to form a complex entangled structure.
//
// The implementation includes both userland and kernel-space versions,
// ensuring proper header inclusion, robust memory management, and fixed-point
// arithmetic for kernel operations.

#include "nymya.h" // Common definitions like nymya_qubit, and gate macros

#ifndef __KERNEL__

#include <stdint.h>
#include <errno.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdio.h>    // Userland: For standard I/O (e.g., in log_symbolic_event)
#include <stdlib.h>   // Userland: For general utilities (e.g., size_t)
#include <math.h>     // Userland: For complex math functions (if needed by sub-gates)
#include <complex.h>  // Userland: For _Complex double type (if needed by sub-gates)
#define __NR_nymya_3354_metatron_cube NYMYA_METATRON_CUBE_CODE

/**
 * nymya_3354_metatron_cube - Applies operations related to the "Metatron's Cube" pattern to qubits (userland).
 * @q: An array of pointers to nymya_qubit objects.
 * @count: The total number of qubits in the array.
 *
 * Returns:
 * - 0 on success.
 * - -1 if the qubit array is NULL or if `count` is less than 13.
 * - -1 if any individual qubit pointer within the processed unit is NULL.
 */
int nymya_3354_metatron_cube(nymya_qubit* q[], size_t count) {
    if (!q || count < 13) return -1;

    for (size_t i = 0; i < 13; i++) {
        if (!q[i]) return -1;
        hadamard(q[i]);
    }

    for (size_t i = 1; i < 13; i++) {
        cnot(q[0], q[i]);
    }

    for (int i = 1; i <= 6; i++) {
        cnot(q[i], q[i + 6]);
    }

    log_symbolic_event("METATRON", q[0]->id, q[0]->tag,
        "Metatron’s Cube geometry entangled");
    return 0;
}

#else  // __KERNEL__

    int nymya_3354_metatron_cube_core(struct nymya_qubit **k_qubits, size_t count);


#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/errno.h>
#include <linux/printk.h>
#include <linux/slab.h>
#include <linux/module.h>

extern int nymya_3308_hadamard_gate(struct nymya_qubit *q);
extern int nymya_3309_controlled_not(struct nymya_qubit *q_ctrl, struct nymya_qubit *q_target);
extern int log_symbolic_event(const char* gate, uint64_t id, const char* tag, const char* msg);

int nymya_3354_metatron_cube_core(struct nymya_qubit **k_qubits, size_t count) {
    int ret = 0;
    const size_t required_qubits = 13;

    for (size_t i = 0; i < required_qubits; i++) {
        ret = nymya_3308_hadamard_gate(k_qubits[i]);
        if (ret) {
            pr_err("nymya_3354_metatron_cube_core: Hadamard on q[%zu] failed, error %d\n", i, ret);
            return ret;
        }
    }

    for (size_t i = 1; i < required_qubits; i++) {
        ret = nymya_3309_controlled_not(k_qubits[0], k_qubits[i]);
        if (ret) {
            pr_err("nymya_3354_metatron_cube_core: CNOT(q[0], q[%zu]) failed, error %d\n", i, ret);
            return ret;
        }
    }

    for (int j = 1; j <= 6; j++) {
        size_t current_idx = j;
        size_t target_idx = j + 6;
        if (current_idx >= count || target_idx >= count) {
            pr_err("nymya_3354_metatron_cube_core: CNOT index out of bounds: %zu, %zu\n", current_idx, target_idx);
            return -EINVAL;
        }
        ret = nymya_3309_controlled_not(k_qubits[current_idx], k_qubits[target_idx]);
        if (ret) {
            pr_err("nymya_3354_metatron_cube_core: CNOT(q[%zu], q[%zu]) failed, error %d\n", current_idx, target_idx, ret);
            return ret;
        }
    }

    log_symbolic_event("METATRON", k_qubits[0]->id, k_qubits[0]->tag,
        "Metatron’s Cube geometry entangled");

    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3354_metatron_cube_core);

SYSCALL_DEFINE2(nymya_3354_metatron_cube,
    struct nymya_qubit __user * __user *, user_q_array,
    size_t, count) {

    struct nymya_qubit **k_qubits = NULL;
    struct nymya_qubit __user **user_qubit_ptrs = NULL;
    int ret = 0;
    const size_t required_qubits = 13;

    if (!user_q_array || count < required_qubits) {
        pr_err("nymya_3354_metatron_cube: Invalid input\n");
        return -EINVAL;
    }

    user_qubit_ptrs = kmalloc_array(count, sizeof(*user_qubit_ptrs), GFP_KERNEL);
    if (!user_qubit_ptrs) {
        ret = -ENOMEM;
        goto cleanup_user_ptrs_array;
    }

    if (copy_from_user(user_qubit_ptrs, user_q_array, count * sizeof(*user_qubit_ptrs))) {
        ret = -EFAULT;
        goto cleanup_user_ptrs_array;
    }

    k_qubits = kmalloc_array(count, sizeof(*k_qubits), GFP_KERNEL);
    if (!k_qubits) {
        ret = -ENOMEM;
        goto cleanup_user_ptrs_array;
    }

    for (size_t i = 0; i < count; i++) {
        k_qubits[i] = NULL;
    }

    for (size_t i = 0; i < count; i++) {
        if (!user_qubit_ptrs[i]) {
            ret = -EINVAL;
            goto cleanup_k_qubits;
        }

        k_qubits[i] = kmalloc(sizeof(struct nymya_qubit), GFP_KERNEL);
        if (!k_qubits[i]) {
            ret = -ENOMEM;
            goto cleanup_k_qubits;
        }

        if (copy_from_user(k_qubits[i], user_qubit_ptrs[i], sizeof(struct nymya_qubit))) {
            ret = -EFAULT;
            goto cleanup_k_qubits;
        }
    }

    ret = nymya_3354_metatron_cube_core(k_qubits, count);
    if (ret)
        goto cleanup_k_qubits;

    for (size_t i = 0; i < count; i++) {
        if (copy_to_user(user_qubit_ptrs[i], k_qubits[i], sizeof(struct nymya_qubit))) {
            if (ret == 0) ret = -EFAULT;
        }
    }

cleanup_k_qubits:
    for (size_t j = 0; j < count; j++) {
        if (k_qubits && k_qubits[j]) {
            kfree(k_qubits[j]);
            k_qubits[j] = NULL;
        }
    }
    kfree(k_qubits);

cleanup_user_ptrs_array:
    kfree(user_qubit_ptrs);

    return ret;
}

#endif  // __KERNEL__

```

---

## File: `nymya_3355_fcc_lattice.c`

### Content

```c
// src/nymya_3355_fcc_lattice.c
//
// Implements nymya_3355_fcc_lattice syscall: simulates quantum operations on qubits
// arranged in an FCC lattice. Includes both userland and kernel-space versions.

#include "nymya.h" // Defines nymya_qpos3d, nymya_qpos3d_k, FIXED_POINT_SCALE, and __NR_* codes

#ifndef __KERNEL__
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>

#define __NR_nymya_3355_fcc_lattice NYMYA_FCC_LATTICE_CODE

/**
 * nymya_3355_fcc_lattice - Userland wrapper for FCC lattice entanglement.
 * @qubits: array of nymya_qpos3d with length count
 * @count: number of qubits (>=14)
 *
 * Converts to fixed-point, invokes syscall, then rescales results.
 * Returns 0 on success, -1 on invalid input or memory failure, or syscall code.
 */
int nymya_3355_fcc_lattice(nymya_qpos3d qubits[], size_t count) {
    if (!qubits || count < 14) return -1;

    nymya_qpos3d_k *buf = malloc(count * sizeof(*buf));
    if (!buf) return -1;

    // Scale to fixed-point
    for (size_t i = 0; i < count; i++) {
        buf[i].q = qubits[i].q;
        buf[i].x = (int64_t)(qubits[i].x * FIXED_POINT_SCALE);
        buf[i].y = (int64_t)(qubits[i].y * FIXED_POINT_SCALE);
        buf[i].z = (int64_t)(qubits[i].z * FIXED_POINT_SCALE);
    }

    // Syscall
    long ret = syscall(__NR_nymya_3355_fcc_lattice, (unsigned long)buf, count);

    if (ret == 0) {
        // Rescale back
        for (size_t i = 0; i < count; i++) {
            qubits[i].q = buf[i].q;
            qubits[i].x = (double)buf[i].x / FIXED_POINT_SCALE;
            qubits[i].y = (double)buf[i].y / FIXED_POINT_SCALE;
            qubits[i].z = (double)buf[i].z / FIXED_POINT_SCALE;
        }
    }
    free(buf);
    return (int)ret;
}

#else // __KERNEL__
    int nymya_3355_fcc_lattice_core(nymya_qpos3d_k *k_qubits, size_t count);


#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/types.h>
#include <linux/errno.h>

static inline int64_t fcc_distance_sq_k(const nymya_qpos3d_k *a,
                                        const nymya_qpos3d_k *b) {
    int64_t dx = a->x - b->x;
    int64_t dy = a->y - b->y;
    int64_t dz = a->z - b->z;
    return fixed_point_square(dx)
         + fixed_point_square(dy)
         + fixed_point_square(dz);
}

/**
 * nymya_3355_fcc_lattice_core - Core FCC lattice logic (kernel).
 * @k_qubits: fixed-point qubit positions array
 * @count: number of qubits
 *
 * Applies Hadamard on each qubit, then CNOT for pairs within threshold.
 */
int nymya_3355_fcc_lattice_core(nymya_qpos3d_k *k_qubits, size_t count) {
    int ret;

    // Hadamard on each
    for (size_t i = 0; i < count; i++) {
        ret = nymya_3308_hadamard_gate(&k_qubits[i].q);
        if (ret) return ret;
    }

    // distance threshold squared
    const int64_t eps2 = (int64_t)(1.0201 * FIXED_POINT_SCALE * FIXED_POINT_SCALE);

    for (size_t i = 0; i < count; i++) {
        for (size_t j = i + 1; j < count; j++) {
            if (fcc_distance_sq_k(&k_qubits[i], &k_qubits[j]) <= eps2) {
                ret = nymya_3309_controlled_not(&k_qubits[i].q,
                                                &k_qubits[j].q);
                if (ret) return ret;
            }
        }
    }

    log_symbolic_event("FCC_3D", k_qubits[0].q.id,
                       k_qubits[0].q.tag,
                       "FCC lattice entangled");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3355_fcc_lattice_core);

SYSCALL_DEFINE2(nymya_3355_fcc_lattice,
    unsigned long, user_ptr,
    size_t,        count)
{
    nymya_qpos3d_k *k_qubits;
    nymya_qpos3d_k __user *u_qubits = (nymya_qpos3d_k __user *)user_ptr;
    int ret;

    if (!u_qubits || count < 14)
        return -EINVAL;

    k_qubits = kmalloc_array(count, sizeof(*k_qubits), GFP_KERNEL);
    if (!k_qubits)
        return -ENOMEM;

    if (copy_from_user(k_qubits, u_qubits,
                       count * sizeof(*k_qubits))) {
        ret = -EFAULT;
        goto out;
    }

    ret = nymya_3355_fcc_lattice_core(k_qubits, count);
    if (ret) goto out;

    if (copy_to_user(u_qubits, k_qubits,
                     count * sizeof(*k_qubits)))
        ret = -EFAULT;

out:
    kfree(k_qubits);
    return ret;
}

#endif // __KERNEL__
```

---

## File: `nymya_3356_hcp_lattice.c`

### Content

```c
// src/nymya_3356_hcp_lattice.c

#include "nymya.h" // Defines: nymya_qubit, nymya_qpos3d, nymya_qpos3d_k, FIXED_POINT_SCALE, fixed_point_square, NYMYA_HCP_LATTICE_CODE

#ifndef __KERNEL__
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <errno.h>
#define __NR_nymya_3356_hcp_lattice NYMYA_HCP_LATTICE_CODE

/**
 * hcp_distance - Calculates Euclidean distance between two qubit positions.
 */
double hcp_distance(nymya_qpos3d a, nymya_qpos3d b) {
    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));
}

/**
 * nymya_3356_hcp_lattice - Userland wrapper for HCP lattice syscall.
 */
int nymya_3356_hcp_lattice(nymya_qpos3d qubits[], size_t count) {
    if (!qubits || count < 17) return -1;
    nymya_qpos3d_k *buf = malloc(count * sizeof(*buf));
    if (!buf) return -ENOMEM;
    for (size_t i = 0; i < count; i++) {
        buf[i].q = qubits[i].q;
        buf[i].x = (int64_t)(qubits[i].x * FIXED_POINT_SCALE);
        buf[i].y = (int64_t)(qubits[i].y * FIXED_POINT_SCALE);
        buf[i].z = (int64_t)(qubits[i].z * FIXED_POINT_SCALE);
    }
    long ret = syscall(__NR_nymya_3356_hcp_lattice, (unsigned long)buf, count);
    if (ret == 0) {
        for (size_t i = 0; i < count; i++) {
            qubits[i].q = buf[i].q;
            qubits[i].x = (double)buf[i].x / FIXED_POINT_SCALE;
            qubits[i].y = (double)buf[i].y / FIXED_POINT_SCALE;
            qubits[i].z = (double)buf[i].z / FIXED_POINT_SCALE;
        }
    }
    free(buf);
    return (int)ret;
}

#else // __KERNEL__
    int nymya_3356_hcp_lattice_core(nymya_qpos3d_k *k_qubits, size_t count);


#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/module.h>

static int64_t hcp_distance_squared_k(const nymya_qpos3d_k *a,
                                        const nymya_qpos3d_k *b) {
    int64_t dx = a->x - b->x;
    int64_t dy = a->y - b->y;
    int64_t dz = a->z - b->z;
    return fixed_point_square(dx) + fixed_point_square(dy) + fixed_point_square(dz);
}

/**
 * nymya_3356_hcp_lattice_core - Kernel core for HCP lattice operations.
 */
int nymya_3356_hcp_lattice_core(nymya_qpos3d_k *k_qubits, size_t count) {
    int ret;
    const int64_t EPS_FP = (int64_t)(1.01 * FIXED_POINT_SCALE);
    const int64_t EPS2 = fixed_point_square(EPS_FP);
    for (size_t i = 0; i < count; i++) {
        ret = nymya_3308_hadamard_gate(&k_qubits[i].q);
        if (ret) return ret;
    }
    for (size_t i = 0; i < count; i++) {
        for (size_t j = i+1; j < count; j++) {
            if (hcp_distance_squared_k(&k_qubits[i], &k_qubits[j]) <= EPS2) {
                ret = nymya_3309_controlled_not(&k_qubits[i].q, &k_qubits[j].q);
                if (ret) return ret;
            }
        }
    }
    log_symbolic_event("HCP_3D", k_qubits[0].q.id, k_qubits[0].q.tag, "HCP lattice entangled");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3356_hcp_lattice_core);

SYSCALL_DEFINE2(nymya_3356_hcp_lattice,
    unsigned long, user_ptr,
    size_t, count) {
    nymya_qpos3d_k *k_qubits;
    nymya_qpos3d_k __user *u_qubits = (nymya_qpos3d_k __user *)user_ptr;
    int ret;
    if (!u_qubits || count < 17)
        return -EINVAL;
    k_qubits = kmalloc_array(count, sizeof(*k_qubits), GFP_KERNEL);
    if (!k_qubits) return -ENOMEM;
    if (copy_from_user(k_qubits, u_qubits, count * sizeof(*k_qubits))) {
        ret = -EFAULT;
        goto out;
    }
    ret = nymya_3356_hcp_lattice_core(k_qubits, count);
    if (!ret)
        if (copy_to_user(u_qubits, k_qubits, count * sizeof(*k_qubits)))
            ret = -EFAULT;
out:
    kfree(k_qubits);
    return ret;
}
#endif // __KERNEL__
```

---

## File: `nymya_3357_e8_projected_lattice.c`

### Content

```c
// src/nymya_3357_e8_projected_lattice.c

#include "nymya.h" // Defines: nymya_qubit, nymya_qpos3d, nymya_qpos3d_k, FIXED_POINT_SCALE, fixed_point_square, NYMYA_E8_PROJECTED_CODE

#ifndef __KERNEL__
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <errno.h>
#define __NR_nymya_3357_e8_projected_lattice NYMYA_E8_PROJECTED_CODE

/**
 * e8_distance - Calculates Euclidean distance between two qubit positions.
 */
double e8_distance(nymya_qpos3d a, nymya_qpos3d b) {
    return sqrt(pow(a.x - b.x,2) + pow(a.y - b.y,2) + pow(a.z - b.z,2));
}

/**
 * nymya_3357_e8_projected_lattice - Userland wrapper for E8 projected lattice syscall.
 */
int nymya_3357_e8_projected_lattice(nymya_qpos3d qubits[], size_t count) {
    if (!qubits || count < 30) return -1;
    nymya_qpos3d_k *buf = malloc(count * sizeof(*buf));
    if (!buf) return -ENOMEM;
    for (size_t i=0; i<count; i++) {
        buf[i].q = qubits[i].q;
        buf[i].x = (int64_t)(qubits[i].x * FIXED_POINT_SCALE);
        buf[i].y = (int64_t)(qubits[i].y * FIXED_POINT_SCALE);
        buf[i].z = (int64_t)(qubits[i].z * FIXED_POINT_SCALE);
    }
    long ret = syscall(__NR_nymya_3357_e8_projected_lattice, (unsigned long)buf, count);
    if (ret==0) {
        for (size_t i=0; i<count; i++) {
            qubits[i].q = buf[i].q;
            qubits[i].x = (double)buf[i].x / FIXED_POINT_SCALE;
            qubits[i].y = (double)buf[i].y / FIXED_POINT_SCALE;
            qubits[i].z = (double)buf[i].z / FIXED_POINT_SCALE;
        }
    }
    free(buf);
    return (int)ret;
}

#else // __KERNEL__
    int nymya_3357_e8_projected_lattice_core(nymya_qpos3d_k *k_qubits, size_t count);


#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/module.h>

static int64_t e8_distance_squared_k(const nymya_qpos3d_k *a, const nymya_qpos3d_k *b) {
    int64_t dx=a->x-b->x, dy=a->y-b->y, dz=a->z-b->z;
    return fixed_point_square(dx)+fixed_point_square(dy)+fixed_point_square(dz);
}

/**
 * nymya_3357_e8_projected_lattice_core - Kernel core for E8 projected lattice.
 */
int nymya_3357_e8_projected_lattice_core(nymya_qpos3d_k *k_qubits, size_t count) {
    int ret;
    const int64_t EPS=(int64_t)(1.00*FIXED_POINT_SCALE);
    const int64_t EPS2=fixed_point_square(EPS);
    for (size_t i=0;i<count;i++) {
        ret=hadamard(&k_qubits[i].q);
        if (ret) return ret;
    }
    for (size_t i=0;i<count;i++) {
        for (size_t j=i+1;j<count;j++) {
            if (e8_distance_squared_k(&k_qubits[i],&k_qubits[j])<=EPS2) {
                ret=cnot(&k_qubits[i].q,&k_qubits[j].q);
                if (ret) return ret;
            }
        }
    }
    log_symbolic_event("E8_PROJECTED",k_qubits[0].q.id,k_qubits[0].q.tag,
                       "Projected E8 lattice entangled");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3357_e8_projected_lattice_core);

SYSCALL_DEFINE2(nymya_3357_e8_projected_lattice,
    unsigned long,user_ptr,
    size_t,count) {
    nymya_qpos3d_k *k_qubits;
    nymya_qpos3d_k __user *u_qubits=(nymya_qpos3d_k __user*)user_ptr;
    int ret;
    if (!u_qubits||count<30) return -EINVAL;
    k_qubits=kmalloc_array(count,sizeof(*k_qubits),GFP_KERNEL);
    if (!k_qubits) return -ENOMEM;
    if (copy_from_user(k_qubits,u_qubits,count*sizeof(*k_qubits))) {ret=-EFAULT;goto out;}
    ret=nymya_3357_e8_projected_lattice_core(k_qubits,count);
    if (!ret) if (copy_to_user(u_qubits,k_qubits,count*sizeof(*k_qubits))) ret=-EFAULT;
out:
    kfree(k_qubits);
    return ret;
}
#endif
```

---

## File: `nymya_3358_d4_lattice.c`

### Content

```c
// src/nymya_3358_d4_lattice.c

#include "nymya.h" // Defines: nymya_qubit, nymya_qpos4d, nymya_qpos4d_k, FIXED_POINT_SCALE, fixed_point_square, NYMYA_D4_LATTICE_CODE

#ifndef __KERNEL__
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <errno.h>
#define __NR_nymya_3358_d4_lattice NYMYA_D4_LATTICE_CODE

/**
 * dist4d - Calculates Euclidean distance in 4D userland.
 */
double dist4d(nymya_qpos4d a, nymya_qpos4d b) {
    return sqrt(pow(a.x - b.x,2) + pow(a.y - b.y,2)
                + pow(a.z - b.z,2) + pow(a.w - b.w,2));
}

/**
 * nymya_3358_d4_lattice - Userland wrapper for D4 lattice syscall.
 */
int nymya_3358_d4_lattice(nymya_qpos4d q[], size_t count) {
    if (!q || count < 24) return -1;
    nymya_qpos4d_k *buf = malloc(count * sizeof(*buf));
    if (!buf) return -ENOMEM;
    for (size_t i=0;i<count;i++) {
        buf[i].q = q[i].q;
        buf[i].x = (int64_t)(q[i].x * FIXED_POINT_SCALE);
        buf[i].y = (int64_t)(q[i].y * FIXED_POINT_SCALE);
        buf[i].z = (int64_t)(q[i].z * FIXED_POINT_SCALE);
        buf[i].w = (int64_t)(q[i].w * FIXED_POINT_SCALE);
    }
    long ret = syscall(__NR_nymya_3358_d4_lattice,(unsigned long)buf,count);
    if (ret==0) {
        for (size_t i=0;i<count;i++) {
            q[i].q = buf[i].q;
            q[i].x = (double)buf[i].x / FIXED_POINT_SCALE;
            q[i].y = (double)buf[i].y / FIXED_POINT_SCALE;
            q[i].z = (double)buf[i].z / FIXED_POINT_SCALE;
            q[i].w = (double)buf[i].w / FIXED_POINT_SCALE;
        }
    }
    free(buf);
    return (int)ret;
}

#else // __KERNEL__
    int nymya_3358_d4_lattice_core(nymya_qpos4d_k *k_q, size_t count);


#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/module.h>

static int64_t dist4d_squared_k(const nymya_qpos4d_k *a, const nymya_qpos4d_k *b) {
    int64_t dx=a->x-b->x, dy=a->y-b->y, dz=a->z-b->z, dw=a->w-b->w;
    return fixed_point_square(dx)+fixed_point_square(dy)
         + fixed_point_square(dz)+fixed_point_square(dw);
}

/**
 * nymya_3358_d4_lattice_core - Kernel core for D4 lattice logic.
 */
int nymya_3358_d4_lattice_core(nymya_qpos4d_k *k_q, size_t count) {
    int ret;
    const int64_t EPS_FP=(int64_t)(1.01*FIXED_POINT_SCALE);
    const int64_t EPS2=fixed_point_square(EPS_FP);
    for (size_t i=0;i<count;i++) {
        ret=hadamard(&k_q[i].q);
        if (ret) return ret;
    }
    for (size_t i=0;i<count;i++) {
        for (size_t j=i+1;j<count;j++) {
            if (dist4d_squared_k(&k_q[i],&k_q[j])<=EPS2) {
                ret=cnot(&k_q[i].q,&k_q[j].q);
                if (ret) return ret;
            }
        }
    }
    log_symbolic_event("D4_LATTICE",k_q[0].q.id,k_q[0].q.tag,
                       "D4 lattice entangled in 4D");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3358_d4_lattice_core);

SYSCALL_DEFINE2(nymya_3358_d4_lattice,
    unsigned long, user_ptr,
    size_t, count) {
    nymya_qpos4d_k *k_q;
    nymya_qpos4d_k __user *u_q=(nymya_qpos4d_k __user*)user_ptr;
    int ret;
    if (!u_q||count<24) return -EINVAL;
    k_q=kmalloc_array(count,sizeof(*k_q),GFP_KERNEL);
    if (!k_q) return -ENOMEM;
    if (copy_from_user(k_q,u_q,count*sizeof(*k_q))) {ret=-EFAULT;goto out;}
    ret=nymya_3358_d4_lattice_core(k_q,count);
    if (!ret) if (copy_to_user(u_q,k_q,count*sizeof(*k_q))) ret=-EFAULT;
out:
    kfree(k_q);
    return ret;
}
#endif
```

---

## File: `nymya_3359_b5_lattice.c`

### Content

```c
// src/nymya_3359_b5_lattice.c

#include "nymya.h" // Defines: nymya_qubit, nymya_qpos5d, nymya_qpos5d_k, FIXED_POINT_SCALE, fixed_point_square, NYMYA_B5_LATTICE_CODE

#ifndef __KERNEL__
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <errno.h>
#define __NR_nymya_3359_b5_lattice NYMYA_B5_LATTICE_CODE

/**
 * dist5d - Calculates Euclidean distance in 5D userland.
 */
double dist5d(nymya_qpos5d a, nymya_qpos5d b) {
    return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2)
                +pow(a.z-b.z,2)+pow(a.w-b.w,2)
                +pow(a.v-b.v,2));
}

/**
 * nymya_3359_b5_lattice - Userland wrapper for B5 lattice syscall.
 */
int nymya_3359_b5_lattice(nymya_qpos5d q[], size_t count) {
    if (!q || count < 32) return -1;
    nymya_qpos5d_k *buf = malloc(count * sizeof(*buf));
    if (!buf) return -ENOMEM;
    for (size_t i=0;i<count;i++) {
        buf[i].q = q[i].q;
        buf[i].x = (int64_t)(q[i].x*FIXED_POINT_SCALE);
        buf[i].y = (int64_t)(q[i].y*FIXED_POINT_SCALE);
        buf[i].z = (int64_t)(q[i].z*FIXED_POINT_SCALE);
        buf[i].w = (int64_t)(q[i].w*FIXED_POINT_SCALE);
        buf[i].v = (int64_t)(q[i].v*FIXED_POINT_SCALE);
    }
    long ret = syscall(__NR_nymya_3359_b5_lattice,(unsigned long)buf,count);
    if (ret==0) {
        for (size_t i=0;i<count;i++) {
            q[i].q = buf[i].q;
            q[i].x = (double)buf[i].x/ FIXED_POINT_SCALE;
            q[i].y = (double)buf[i].y/ FIXED_POINT_SCALE;
            q[i].z = (double)buf[i].z/ FIXED_POINT_SCALE;
            q[i].w = (double)buf[i].w/ FIXED_POINT_SCALE;
            q[i].v = (double)buf[i].v/ FIXED_POINT_SCALE;
        }
    }
    free(buf);
    return (int)ret;
}

#else // __KERNEL__
    int nymya_3359_b5_lattice_core(nymya_qpos5d_k *k_q, size_t count);


#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/module.h>

static int64_t dist5d_squared_k(const nymya_qpos5d_k *a, const nymya_qpos5d_k *b) {
    int64_t dx=a->x-b->x, dy=a->y-b->y, dz=a->z-b->z;
    int64_t dw=a->w-b->w, dv=a->v-b->v;
    return fixed_point_square(dx)+fixed_point_square(dy)
         + fixed_point_square(dz)+fixed_point_square(dw)
         + fixed_point_square(dv);
}

/**
 * nymya_3359_b5_lattice_core - Kernel core for B5 lattice logic.
 */
int nymya_3359_b5_lattice_core(nymya_qpos5d_k *k_q, size_t count) {
    int ret;
    const int64_t EPS_FP=(int64_t)(1.00*FIXED_POINT_SCALE);
    const int64_t EPS2=fixed_point_square(EPS_FP);
    for (size_t i=0;i<count;i++) {
        ret=hadamard(&k_q[i].q);
        if (ret) return ret;
    }
    for (size_t i=0;i<count;i++) {
        for (size_t j=i+1;j<count;j++) {
            if (dist5d_squared_k(&k_q[i],&k_q[j])<=EPS2) {
                ret=cnot(&k_q[i].q,&k_q[j].q);
                if (ret) return ret;
            }
        }
    }
    log_symbolic_event("B5_LATTICE",k_q[0].q.id,k_q[0].q.tag,
                       "5D B5 lattice entangled");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3359_b5_lattice_core);

SYSCALL_DEFINE2(nymya_3359_b5_lattice,
    unsigned long, user_ptr,
    size_t, count) {
    nymya_qpos5d_k *k_q;
    nymya_qpos5d_k __user *u_q=(nymya_qpos5d_k __user*)user_ptr;
    int ret;
    if (!u_q||count<32) return -EINVAL;
    k_q=kmalloc_array(count,sizeof(*k_q),GFP_KERNEL);
    if (!k_q) return -ENOMEM;
    if (copy_from_user(k_q,u_q,count*sizeof(*k_q))) {ret=-EFAULT;goto out;}
    ret=nymya_3359_b5_lattice_core(k_q,count);
    if (!ret) if (copy_to_user(u_q,k_q,count*sizeof(*k_q))) ret=-EFAULT;
out:
    kfree(k_q);
    return ret;
}
#endif
```

---

## File: `nymya_3360_e5_projected_lattice.c`

### Content

```c
// src/nymya_3360_e5_projected_lattice.c

#include "nymya.h" // Defines: nymya_qubit, nymya_qpos5d, nymya_qpos5d_k, FIXED_POINT_SCALE, fixed_point_square, NYMYA_E5_PROJECTED_CODE

#ifndef __KERNEL__
#include <stdio.h>
#include <stdlib.h> // For malloc, free
#include <math.h>   // For sqrt, pow
#include <unistd.h> // For syscall
#include <sys/syscall.h>
#include <errno.h>
#define __NR_nymya_3360_e5_projected_lattice NYMYA_E5_PROJECTED_CODE

/**
 * dist5d - Calculates the Euclidean distance between two nymya_qpos5d points (userland).
 */

/**
 * nymya_3360_e5_projected_lattice - Userland wrapper for E5 projected lattice syscall.
 */
int nymya_3360_e5_projected_lattice(nymya_qpos5d q[], size_t count) {
    if (!q || count < 40) return -1;
    nymya_qpos5d_k *buf = malloc(count * sizeof(*buf));
    if (!buf) return -ENOMEM;
    for (size_t i = 0; i < count; i++) {
        buf[i].q = q[i].q;
        buf[i].x = (int64_t)(q[i].x * FIXED_POINT_SCALE);
        buf[i].y = (int64_t)(q[i].y * FIXED_POINT_SCALE);
        buf[i].z = (int64_t)(q[i].z * FIXED_POINT_SCALE);
        buf[i].w = (int64_t)(q[i].w * FIXED_POINT_SCALE);
        buf[i].v = (int64_t)(q[i].v * FIXED_POINT_SCALE);
    }
    long ret = syscall(__NR_nymya_3360_e5_projected_lattice, (unsigned long)buf, count);
    if (ret == 0) {
        for (size_t i = 0; i < count; i++) {
            q[i].q = buf[i].q;
            q[i].x = (double)buf[i].x / FIXED_POINT_SCALE;
            q[i].y = (double)buf[i].y / FIXED_POINT_SCALE;
            q[i].z = (double)buf[i].z / FIXED_POINT_SCALE;
            q[i].w = (double)buf[i].w / FIXED_POINT_SCALE;
            q[i].v = (double)buf[i].v / FIXED_POINT_SCALE;
        }
    }
    free(buf);
    return (int)ret;
}

#else // __KERNEL__
    int nymya_3360_e5_projected_lattice_core(nymya_qpos5d_k *k_q, size_t count);


#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/slab.h>
#include <linux/module.h>

static int64_t dist5d_squared_k(const nymya_qpos5d_k *a, const nymya_qpos5d_k *b) {
    int64_t dx = a->x - b->x;
    int64_t dy = a->y - b->y;
    int64_t dz = a->z - b->z;
    int64_t dw = a->w - b->w;
    int64_t dv = a->v - b->v;
    return fixed_point_square(dx) +
           fixed_point_square(dy) +
           fixed_point_square(dz) +
           fixed_point_square(dw) +
           fixed_point_square(dv);
}

/**
 * nymya_3360_e5_projected_lattice_core - Kernel core logic for E5 projected lattice.
 */
int nymya_3360_e5_projected_lattice_core(nymya_qpos5d_k *k_q, size_t count) {
    int ret;
    const int64_t EPS_FP = (int64_t)(1.05 * FIXED_POINT_SCALE);
    const int64_t EPS2 = fixed_point_square(EPS_FP);
    for (size_t i = 0; i < count; i++) {
        ret = hadamard(&k_q[i].q);
        if (ret) return ret;
    }
    for (size_t i = 0; i < count; i++) {
        for (size_t j = i + 1; j < count; j++) {
            if (dist5d_squared_k(&k_q[i], &k_q[j]) <= EPS2) {
                ret = cnot(&k_q[i].q, &k_q[j].q);
                if (ret) return ret;
            }
        }
    }
    log_symbolic_event("E5_PROJECTED", k_q[0].q.id, k_q[0].q.tag,
                       "Projected E5 root lattice entanglement");
    return 0;
}
EXPORT_SYMBOL_GPL(nymya_3360_e5_projected_lattice_core);

SYSCALL_DEFINE2(nymya_3360_e5_projected_lattice,
    unsigned long, user_ptr,
    size_t, count) {

    nymya_qpos5d_k *k_q;
    nymya_qpos5d_k __user *u_q = (nymya_qpos5d_k __user *)user_ptr;
    int ret;

    if (!u_q || count < 40)
        return -EINVAL;
    k_q = kmalloc_array(count, sizeof(*k_q), GFP_KERNEL);
    if (!k_q)
        return -ENOMEM;
    if (copy_from_user(k_q, u_q, count * sizeof(*k_q))) { ret = -EFAULT; goto out; }
    ret = nymya_3360_e5_projected_lattice_core(k_q, count);
    if (!ret && copy_to_user(u_q, k_q, count * sizeof(*k_q)))
        ret = -EFAULT;
out:
    kfree(k_q);
    return ret;
}
#endif
```

---

## File: `nymya_3361_qrng_range.c`

### Content

```c
// src/nymya_3361_qrng_range.c

#include "nymya.h" // Defines: nymya_qubit, FIXED_POINT_SCALE, NYMYA_QRNG_CODE, make_complex, hadamard, global_phase, log_symbolic_event

#ifndef __KERNEL__
#include <stdint.h>
    #include <stdio.h>
    #include <stdlib.h> // For malloc, free, srand, rand in userland
    #include <time.h>   // For time(NULL) in userland
    #include <math.h>   // Not strictly needed for this file, but often grouped with other userland includes
    #include <unistd.h> // For syscall
    #include <sys/syscall.h> // For syscall() function prototype
    #include <errno.h>  // For ENOMEM and other errno values in userland
#else
    #include <linux/kernel.h>
    #include <linux/syscalls.h>
    #include <linux/uaccess.h>
    #include <linux/slab.h> // For kmalloc, kfree
    #include <linux/random.h> // For get_random_u32
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL
    // No stdlib.h, time.h, math.h for kernel
#endif

#ifndef __KERNEL__

// Define the syscall number for userland, using the code from nymya.h.
// This is necessary because syscall() expects the __NR_ prefix.
#define __NR_nymya_3361_qrng_range NYMYA_QRNG_CODE

/**
 * nymya_3361_qrng_range - Userland wrapper for the QRNG syscall.
 * @out: Pointer to an array where the generated random numbers will be stored.
 * @min: The minimum value for the random numbers (inclusive).
 * @max: The maximum value for the random numbers (inclusive).
 * @count: The number of random numbers to generate.
 *
 * This function simulates quantum random number generation in userland.
 * It initializes qubits, applies quantum gates (symbolically), and then
 * generates a random bit to determine the output value within the specified range.
 *
 * Returns:
 * - 0 on success.
 * - -1 if input parameters are invalid.
 */
int nymya_3361_qrng_range(uint64_t* out, uint64_t min, uint64_t max, size_t count) {
    if (!out || min >= max || count == 0) return -1;

    // In userland, we can still use stdlib's rand for demonstration or testing
    // if a true quantum RNG is not available.
    static int seeded = 0;
    if (!seeded) {
        srand((unsigned int)time(NULL)); // Seed RNG in userland
        seeded = 1;
    }

    // The userland function now primarily acts as a wrapper to call the kernel syscall.
    // The actual QRNG logic resides in the kernel implementation.
    long ret = syscall(__NR_nymya_3361_qrng_range, (unsigned long)out, min, max, count);

    return (int)ret;
}

#else // __KERNEL__

// External kernel functions for qubit operations and logging.
// These are assumed to be defined elsewhere in the kernel and linked,
// and their declarations are now expected to be in nymya.h.
extern int hadamard(nymya_qubit *q);
extern int global_phase(nymya_qubit *q, int64_t theta_fp);
extern int log_symbolic_event(const char* gate, uint64_t id, const char* tag, const char* msg);


/**
 * @brief Performs the core logic for Quantum Random Number Generation within a range.
 *
 * This function simulates quantum random number generation. It performs
 * symbolic quantum operations (Hadamard, Global Phase) on a conceptual qubit
 * for each number generated, and then uses a kernel-safe pseudo-random number
 * generator to produce a bit, which is scaled to the desired range.
 *
 * It handles the allocation of temporary kernel memory, the generation loop,
 * and copying the results back to user space.
 *
 * @param user_out Pointer to a user-space array of uint64_t where the generated numbers will be stored.
 * @param min The minimum value for the random numbers (inclusive).
 * @param max The maximum value for the random numbers (inclusive).
 * @param count The number of random numbers to generate.
 *
 * @return 0 on success.
 * @return -EINVAL if input parameters are invalid.
 * @return -ENOMEM if kernel memory allocation fails.
 * @return -EFAULT if copying data to user space fails.
 */
int nymya_3361_qrng_range(uint64_t __user *user_out, uint64_t min, uint64_t max, size_t count) {
    int ret = 0;
    uint64_t* k_out = NULL;

    if (!user_out || min >= max || count == 0)
        return -EINVAL;

    k_out = kmalloc(sizeof(uint64_t) * count, GFP_KERNEL);
    if (!k_out)
        return -ENOMEM;

    // Use get_random_u32 for kernel-safe random number generation.
    // This function draws from the kernel's entropy pool and does not
    // require explicit seeding within this syscall.

    for (size_t i = 0; i < count; i++) {
        // Conceptual qubit for symbolic operations
        struct nymya_qubit q = {
            .id = i,
            .tag = "qrng",
            .amplitude = make_complex(FIXED_POINT_SCALE, 0) // Initialize to |0> state in fixed-point
        };

        // Symbolic quantum operations
        // These functions are assumed to modify the amplitude of 'q' symbolically
        // or perform other logging/tracking.
        hadamard(&q);          // Symbolic superposition
        global_phase(&q, 0);   // Symbolic identity phase (0 in fixed-point)

        // Generate a pseudo-random bit using kernel's get_random_u32
        // We only need a bit, so we mask the result.
        int bit = get_random_u32() & 1; // Get a single random bit (0 or 1)

        // Map the random bit to either min or max.
        // This simulates a binary outcome from a quantum measurement.
        k_out[i] = bit == 0 ? min : max;

        // Log the symbolic event for the generated bit
        log_symbolic_event("QRNG_BIT", q.id, q.tag, bit ? "1" : "0");
    }

    // Copy generated numbers to user space
    if (copy_to_user(user_out, k_out, sizeof(uint64_t) * count)) {
        ret = -EFAULT;
    }

    kfree(k_out);
    return ret;
}
EXPORT_SYMBOL_GPL(nymya_3361_qrng_range);



/**
 * nymya_3361_qrng_range - Kernel syscall for Quantum Random Number Generation within a range.
 * @user_out: Pointer to a user-space array of uint64_t where the generated numbers will be stored.
 * @min: The minimum value for the random numbers (inclusive).
 * @max: The maximum value for the random numbers (inclusive).
 * @count: The number of random numbers to generate.
 *
 * This system call is a wrapper around the core `nymya_3361_qrng_range` function,
 * providing the standard syscall entry point.
 *
 * Returns:
 * - 0 on success.
 * - -EINVAL if input parameters are invalid.
 * - -ENOMEM if kernel memory allocation fails.
 * - -EFAULT if copying data to user space fails.
 */
SYSCALL_DEFINE4(nymya_3361_qrng_range,
    uint64_t __user *, user_out,
    uint64_t, min,
    uint64_t, max,
    size_t, count) {
    // The actual logic, including input validation, memory allocation/deallocation,
    // QRNG simulation, and copy_to_user, is now encapsulated in the
    // nymya_3361_qrng_range function.
    return nymya_3361_qrng_range(user_out, min, max, count);
}

#endif

```

---

## File: `nymya_complex_math.c`

### Content

```c
// Attempt to detect kernel environment if __KERNEL__ is not defined by build system.
// This is a workaround for build systems that might not consistently define __KERNEL__.
#ifndef __KERNEL__
    #if defined(__linux__) && defined(__GNUC__)
        // Check for common kernel headers that are unlikely to be in userspace.
        // This relies on GCC's __has_include extension.
        #if __has_include(<linux/kernel.h>) || __has_include(<linux/module.h>) || __has_include(<linux/init.h>)
            #define __KERNEL__ 1
        #endif
    #endif
#endif

// Define __maybe_unused if not already defined
#ifndef __maybe_unused
    #define __maybe_unused __attribute__((__unused__))
#endif

#include "nymya.h"

#ifndef __KERNEL__
    #include <math.h>   // for cos(), sin(), cexp() in user mode
    #include <complex.h> // for I in user mode
#else
    // No math.h for kernel. Fixed-point math functions are in nymya.h.
#endif

#ifdef __KERNEL__

// Kernel mode: complex_double is a struct with re, im (fixed-point)

/**
 * nymya_kernel_cexp - Calculates e^(i * theta) for fixed-point complex numbers in kernel mode.
 * @theta_fp: The angle in fixed-point format.
 * @result: Pointer to a complex_double struct to store the result.
 */
static __maybe_unused void nymya_kernel_cexp(int64_t theta_fp, complex_double *result) {
    result->re = fixed_point_cos(theta_fp);
    result->im = fixed_point_sin(theta_fp);
}

/**
 * nymya_kernel_cmul - Multiplies two fixed-point complex_double numbers in kernel mode.
 * @a: Pointer to the first complex_double operand.
 * @b: Pointer to the second complex_double operand.
 * @result: Pointer to a complex_double struct to store the product.
 */
static __maybe_unused void nymya_kernel_cmul(const complex_double *a, const complex_double *b, complex_double *result) {
    result->re = fixed_point_mul(a->re, b->re) - fixed_point_mul(a->im, b->im);
    result->im = fixed_point_mul(a->re, b->im) + fixed_point_mul(a->im, b->re);
}

#else

// User mode: complex_double is _Complex double (native floating-point complex)

/**
 * nymya_kernel_cexp - Calculates e^(i * theta) for native complex doubles in user mode.
 * @theta: The angle in double-precision floating-point.
 *
 * Returns:
 * complex_double representing e^(i * theta).
 */
static complex_double nymya_kernel_cexp(double theta) {
    return cexp(I * theta);
}

/**
 * nymya_kernel_cmul - Multiplies two native complex_double numbers in user mode.
 * @a: The first complex_double operand.
 * @b: The second complex_double operand.
 *
 * Returns:
 * The product (a * b) as a complex_double.
 */
static complex_double nymya_kernel_cmul(complex_double a, complex_double b) {
    return a * b;
}

#endif


```

---

## File: `nymya_enter_syscall_print_funcs.c`

### Content

```c
// src/nymya_enter_syscall_print_funcs.c
//
// Defines the nymya_enter_syscall_print_funcs function for both kernel and userland.
// In the kernel, it uses pr_info for logging. In userland, it uses printf.

#include "nymya.h" // Assumed to define common types like uint64_t

#ifdef __KERNEL__
    int nymya_enter_syscall_print_funcs(uint64_t syscall_id, uint64_t qubit_id);

    #include <linux/kernel.h> // For pr_info
    #include <linux/types.h>  // For uint64_t if not already in nymya.h
    #include <linux/module.h> // Required for EXPORT_SYMBOL_GPL

    /**
     * nymya_enter_syscall_print_funcs - Kernel-side implementation for syscall entry event logging.
     * @syscall_id: The ID of the syscall being entered.
     * @qubit_id: The ID of the primary qubit involved (or 0 if not applicable).
     *
     * This function provides a basic logging mechanism for syscall entries within the kernel.
     * It uses pr_info to output a message to the kernel log.
     *
     * Returns: 0 on success.
     */
    int nymya_enter_syscall_print_funcs(uint64_t syscall_id, uint64_t qubit_id) {
        // For kernel logging (pr_info), %llu is generally correct for uint64_t
        pr_info("NYMYA_SYSCALL_ENTER: SyscallID=%llu, QubitID=%llu\n", syscall_id, qubit_id);
        return 0;
    }
    // Export the symbol so other kernel modules/code can call it directly.
    EXPORT_SYMBOL_GPL(nymya_enter_syscall_print_funcs);

#else // Userland implementation

    #include <stdio.h>    // For printf
    #include <stdint.h>   // For uint64_t
    #include <inttypes.h> // For PRIu64 macro

    /**
     * nymya_enter_syscall_print_funcs - Userland implementation for syscall entry event logging.
     * @syscall_id: The ID of the syscall being entered.
     * @qubit_id: The ID of the primary qubit involved (or 0 if not applicable).
     *
     * This function provides a basic logging mechanism for syscall entries in userland.
     * It uses printf to output a message to standard output.
     * This is useful for debugging and tracing in user-space applications.
     *
     * Returns: 0 on success.
     */
    int nymya_enter_syscall_print_funcs(uint64_t syscall_id, uint64_t qubit_id) {
        // Using PRIu64 for platform-independent printing of uint64_t
        printf("USERLAND_SYSCALL_ENTER: SyscallID=%" PRIu64 ", QubitID=%" PRIu64 "\n", syscall_id, qubit_id);
        return 0;
    }

#endif // __KERNEL__


```

