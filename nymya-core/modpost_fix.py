import os
import glob
import subprocess
import time
import sys

def run_git_command(command, cwd=None):
    """Executes a git command and prints its output."""
    try:
        result = subprocess.run(command, cwd=cwd, capture_output=True, text=True, check=True)
        print(f"Git stdout:\n{result.stdout}")
        if result.stderr:
            print(f"Git stderr:\n{result.stderr}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"Git command failed: {' '.join(command)}")
        print(f"Error stdout:\n{e.stdout}")
        print(f"Error stderr:\n{e.stderr}")
        return False

def document_c_files_to_markdown(project_root, output_md_file="documented_c_files.md"):
    """
    Scans for .c files recursively, documents their content into a Markdown file,
    and commits the changes after each file is processed.
    """
    output_path = os.path.join(project_root, output_md_file)

    # Initialize or clear the Markdown file with a header
    print(f"Initializing/clearing {output_md_file}...")
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write("# Documented C Files from nymya-core Project\n\n")
        f.write("This document was automatically generated by a script to capture the content of .c files.\n\n")

    # Add and commit the initial Markdown file with just the header
    print(f"Committing initial state of {output_md_file}...")
    if run_git_command(['git', 'add', output_path], cwd=project_root):
        run_git_command(['git', 'commit', '-m', f"docs: Initial commit for {output_md_file}"], cwd=project_root)
        time.sleep(5) # Give git a moment
    else:
        print(f"Warning: Could not commit initial state of {output_md_file}. Continuing without initial commit.")

    print(f"\nStarting documentation process for .c files in {project_root}...")

    # Find all .c files recursively in the project_root
    # Use os.walk for more robust traversal than glob for large/complex directory structures
    c_files = []
    for dirpath, _, filenames in os.walk(project_root):
        for filename in filenames:
            if filename.endswith('.c'):
                c_files.append(os.path.join(dirpath, filename))
    
    if not c_files:
        print("No .c files found to document.")
        return

    # Sort files for consistent output order
    c_files.sort()

    for file_path in c_files:
        relative_path = os.path.relpath(file_path, project_root)
        file_name = os.path.basename(file_path)

        print(f"Processing: {relative_path}")

        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                file_content = f.read()

            # Append to Markdown file
            with open(output_path, 'a', encoding='utf-8') as md_f:
                md_f.write(f"---\n\n")
                md_f.write(f"## File: `{relative_path}`\n\n")
                md_f.write(f"### Content\n\n")
                md_f.write(f"```c\n{file_content}\n```\n\n")
            
            print(f"Appended content of {relative_path} to {output_md_file}")

            # Commit after each file is appended
            if run_git_command(['git', 'add', output_path], cwd=project_root):
                commit_message = f"docs: Documented {file_name} in {output_md_file}"
                run_git_command(['git', 'commit', '-m', commit_message], cwd=project_root)
                print(f"Committed changes for {file_name}.")
                time.sleep(5) # Small pause to allow git to process and for clarity
            else:
                print(f"Warning: Failed to add/commit {output_md_file} after processing {file_name}.")

            # Add 1-minute delay after processing each file
            print(f"Waiting for 1 minute before processing the next file...")
            time.sleep(60)

        except Exception as e:
            print(f"Error processing {file_path}: {e}")
            # Continue to next file even if one fails

    print(f"\nDocumentation process complete. All .c files processed and documented in {output_md_file}.")


def main():
    project_root = os.path.expanduser("~/nymyaOS/nymya-core")
    if not os.path.isdir(project_root):
        print(f"Error: Project root directory not found at {project_root}")
        print("Please adjust 'project_root' variable in the script to your actual nymya-core path.")
        sys.exit(1)
    os.chdir(project_root)
    print(f"Changed directory to: {os.getcwd()}")

    print("\nEnsuring you are on 'gemini_autofix' branch...")
    if not run_git_command(['git', 'checkout', 'gemini_autofix']):
        print("Failed to checkout 'gemini_autofix'. Please ensure the branch exists and is clean.")
        sys.exit(1)
    run_git_command(['git', 'pull', 'origin', 'gemini_autofix'])

    document_c_files_to_markdown(project_root)

    print("\nDocumentation script finished.")
    print("Pushing all documentation changes to 'gemini_autofix' branch...")
    run_git_command(['git', 'push', 'origin', 'gemini_autofix'])
    print("All automated documentation applied and pushed to 'gemini_autofix'.")

if __name__ == "__main__":
    main()
