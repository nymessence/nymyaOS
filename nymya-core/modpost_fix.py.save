import os
import subprocess
import re
import sys
import time # Added for sleep functionality

# Import the Google Generative AI client library
# You might need to install this: pip install google-generativeai
try:
    import google.generativeai as genai
except ImportError:
    print("Error: 'google-generativeai' library not found.")
    print("Please install it using: pip install google-generativeai")
    sys.exit(1)

def get_gemini_api_key():
    """Reads the Gemini API key from ~/.gemini_token."""
    api_key_path = os.path.expanduser("~/.gemini_token")
    if not os.path.exists(api_key_path):
        print(f"Error: API key file not found at {api_key_path}")
        print("Please create this file and put your Gemini API key inside it.")
        sys.exit(1)
    with open(api_key_path, 'r') as f:
        api_key = f.read().strip()
    if not api_key:
        print(f"Error: API key file {api_key_path} is empty.")
        sys.exit(1)
    return api_key

# Global model instance, initialized in main
gemini_model = None

def configure_gemini():
    """Confgures the Gemini API client."""
    api_key = get_gemini_api_key()
    genai.configure(api_key=api_key)
    # Using the specified model: gemini-2.5-flash-preview-05-20 (equivalent to gemini-2.5-flash)
    return genai.GenerativeModel('gemini-2.5-flash-preview-05-20')

def run_git_command(command, cwd=None):
    """Executes a git command and prints its output."""
    try:
        result = subprocess.run(command, cwd=cwd, capture_output=True, text=True, check=True)
        print(f"Git stdout:\n{result.stdout}")
        if result.stderr:
            print(f"Git stderr:\n{result.stderr}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"Git command failed: {' '.join(command)}")
        print(f"Error stdout:\n{e.stdout}")
        print(f"Error stderr:\n{e.stderr}")
        return False

def get_llm_fixed_code(file_path, error_description):
    """
    Sends file content and error description to Gemini API to get a fixed version.
    Parses the response to extract the C code block or Makefile block.
    """
    global gemini_model
    if gemini_model is None:
        print("Error: Gemini model not configured. Call configure_gemini() first.")
        return None

    try:
        with open(file_path, 'r') as f:
            file_content = f.read()

        # Determine the expected code block type based on file extension
        if file_path.endswith('Makefile') or file_path.endswith('.mk'):
            code_block_type = "Makefile"
        else:
            code_block_type = "c"

        prompt = f"""
You are an expert C kernel developer. I am encountering a compilation error.
Here is the error description:
{error_description}

Here is the content of the file '{os.path.basename(file_path)}' that needs to be fixed:
```{code_block_type}
{file_content}
```

Please provide ONLY the complete, corrected {code_block_type} code for the file. Do not include any explanations, comments outside the code, or markdown other than the ```{code_block_type} and ``` block. Ensure the code is ready to be written directly to the file.
"""
        print(f"Sending request to Gemini for {file_path}...")
        # Exponential backoff for API calls
        retries = 0
        max_retries = 5
        while retries < max_retries:
            try:
                response = gemini_model.generate_content(prompt)
                response_text = response.candidates[0].content.parts[0].text
                break # Success, break out of retry loop
            except Exception as e:
                retries += 1
                wait_time = 2 ** retries # Exponential backoff
                print(f"API call failed ({e}). Retrying in {wait_time} seconds... (Attempt {retries}/{max_retries})")
                time.sleep(wait_time)
        else: # This block executes if loop completes without break (i.e., all retries failed)
            print("Max retries reached. Failed to get response from Gemini API.")
            return None

        # Strip any leading/trailing whitespace/newlines from the entire response text
        response_text = response_text.strip()

        # Extract code block from response based on determined type
        # The regex now accounts for optional language tags and newlines more robustly
        code_match = re.search(rf"```(?:{code_block_type})?\s*\n?(.*?)```", response_text, re.DOTALL)
        if code_match:
            fixed_code = code_match.group(1).strip()
            print("Received fixed code from Gemini.")
            return fixed_code
        else:
            print(f"Warning: Could not extract {code_block_type} code block from Gemini's response.")
            print(f"Gemini's raw response (first 500 chars):\n{response_text[:500]}...") # Print first 500 chars for debugging
            return None

    except Exception as e:
        print(f"Error calling Gemini API for {file_path}: {e}")
        return None

def apply_llm_fix_and_commit(file_path, symbol_name, error_description_for_llm, commit_prefix):
    """
    Generic function to apply LLM fix, write to file, and commit.
    """
    print(f"\nAttempting to fix '{symbol_name}' in '{file_path}' using LLM...")
    fixed_content = get_llm_fixed_code(file_path, error_description_for_llm)

    if fixed_content:
        try:
            with open(file_path, 'w') as f:
                f.write(fixed_content)
            print(f"Successfully fixed '{symbol_name}' in '{file_path}' using LLM.")
            if run_git_command(['git', 'add', file_path]):
                commit_message = f"{commit_prefix}: LLM fixed {os.path.basename(file_path)}"
                run_git_command(['git', 'commit', '-m', commit_message])
                print(f"Waiting for 30 seconds after commit...")
                time.sleep(30)
            return True
        except Exception as e:
            print(f"Error writing fixed content to {file_path}: {e}")
            return False
    return False


def fix_undefined_symbols_by_makefile_inclusion(makefile_path, project_root):
    """
    Fixes 'undefined!' errors for various symbols by modifying the Makefile
    to ensure their source files are included in the kernel build.
    This is now entirely LLM-driven.
    """
    print(f"\nAttempting to fix 'undefined!' symbols by modifying '{makefile_path}' using LLM...")
    try:
        with open(makefile_path, 'r') as f:
            content = f.read()

        # List of C files that are commonly filtered out but needed
        files_to_ensure_included = [
            "complex_mul.c",
            "complex_exp_i.c",
            "fixed_point_square.c",
            "fixed_point_mul.c",
            "fixed_sin.c",
            "make_complex.c",
            "nymya_3303_pauli_x.c",
            "fixed_complex_multiply.c",
            "nymya_exit_syscall_print_funcs.c",
            "nymya_event_class_syscall_enter.c",
            "nymya_enter_syscall_print_funcs.c",
            "nymya_event_class_syscall_exit.c",
            "log.c",
            "nymya_complex_math.c",
        ]

        # Construct a very specific prompt for the Makefile modification
        makefile_prompt = f"""
You are an expert in Linux kernel Makefiles.
Here is the current content of my Makefile:
```Makefile
{content}
```
I am encountering 'modpost' errors indicating that the following C files are undefined or exported without definition:
{', '.join(files_to_ensure_included)}

The kernel module is built by the 'kernel' target in this Makefile.
Inside the 'kernel' target, there's a loop that symlinks source files into the `$(KERNEL_SRC_DIR)` directory.
Currently, this loop only symlinks files starting with `nymya_` (i.e., `nymya_*.c`).
This is causing issues because other necessary `.c` files (like `complex_mul.c`, `fixed_point_square.c`, `make_complex.c`, etc.) are not being symlinked and thus are not being compiled into the kernel module.

Please provide the complete, corrected Makefile content.
The crucial change is to modify the `kernel` target's source syncing loop:
Change `@for f in $(wildcard nymya_*.c); do \\`
TO: `@for f in $(wildcard *.c); do \\`
This will ensure *all* `.c` files in the current directory are symlinked to `$(KERNEL_SRC_DIR)`, allowing them to be compiled into the kernel module.
Also, ensure the `nymya_syscalls-objs` line in the generated Makefile (within the 'kernel' target) correctly reflects *all* `.o` files from these `.c` files.
Provide ONLY the complete Makefile content. Do not include any explanations or markdown other than the ```Makefile and ``` block.
"""
        llm_makefile_content = get_llm_fixed_code(makefile_path, makefile_prompt)
        
        if llm_makefile_content:
            try:
                with open(makefi
